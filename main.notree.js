"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  SERVICE_TOKENS: () => SERVICE_TOKENS,
  default: () => CognitiveRazorPlugin
});
module.exports = __toCommonJS(main_exports);

// src/types.ts
var DEFAULT_ENDPOINTS = {
  openai: "https://api.openai.com/v1"
};
var DEFAULT_UI_STATE = {
  sectionCollapsed: {
    createConcept: false,
    duplicates: false,
    queueStatus: true,
    recentOps: true
  },
  sortPreferences: {}
};
function ok(value) {
  return { ok: true, value };
}
function err(code, message, details) {
  return { ok: false, error: { code, message, details } };
}
var CognitiveRazorError = class extends Error {
  code;
  details;
  constructor(code, message, details) {
    super(message);
    this.name = "CognitiveRazorError";
    this.code = code;
    this.details = details;
  }
};
function isErrResult(value) {
  if (!value || typeof value !== "object") return false;
  const candidate = value;
  if (candidate.ok !== false) return false;
  const errObj = candidate.error;
  return !!errObj && typeof errObj.code === "string" && typeof errObj.message === "string";
}
function toErr(error, fallbackCode = "E500_INTERNAL_ERROR", fallbackMessage = "\u53D1\u751F\u672A\u77E5\u9519\u8BEF") {
  if (isErrResult(error)) {
    return error;
  }
  if (error instanceof CognitiveRazorError) {
    return err(error.code, error.message, error.details);
  }
  if (error instanceof Error) {
    return err(fallbackCode, error.message || fallbackMessage, { stack: error.stack });
  }
  return err(fallbackCode, fallbackMessage, error);
}
function safeErrorMessage(error, fallback2 = "\u64CD\u4F5C\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5") {
  if (isErrResult(error)) {
    return `[${error.error.code}] ${error.error.message}`;
  }
  if (error instanceof CognitiveRazorError) {
    return `[${error.code}] ${error.message}`;
  }
  return fallback2;
}

// src/data/settings-store.ts
var DEFAULT_DIRECTORY_SCHEME = {
  Domain: "1-\u9886\u57DF",
  Issue: "2-\u8BAE\u9898",
  Theory: "3-\u7406\u8BBA",
  Entity: "4-\u5B9E\u4F53",
  Mechanism: "5-\u673A\u5236"
};
var REQUIRED_SETTINGS_FIELDS = [
  "version",
  "language",
  "namingTemplate",
  "directoryScheme",
  "similarityThreshold",
  "concurrency",
  "autoRetry",
  "maxRetryAttempts",
  "maxSnapshots",
  "maxSnapshotAgeDays",
  "enableAutoVerify",
  "providers",
  "defaultProviderId",
  "taskModels",
  "imageGeneration",
  "logLevel",
  "embeddingDimension",
  "providerTimeoutMs"
];
var DEFAULT_TASK_TIMEOUT_MS = 3 * 60 * 1e3;
var DEFAULT_TASK_HISTORY = 300;
var SCALAR_SETTINGS_SPECS = [
  { key: "version", type: "string", required: true },
  { key: "language", type: "string", required: true, allowed: ["zh", "en"] },
  { key: "namingTemplate", type: "string", required: true },
  { key: "similarityThreshold", type: "number", required: true, min: 0, max: 1 },
  { key: "concurrency", type: "number", required: true, integer: true, min: 1 },
  { key: "autoRetry", type: "boolean", required: true },
  { key: "maxRetryAttempts", type: "number", required: true, integer: true, min: 0 },
  { key: "maxSnapshots", type: "number", required: true, integer: true, min: 1 },
  { key: "maxSnapshotAgeDays", type: "number", required: true, integer: true, min: 1 },
  { key: "enableAutoVerify", type: "boolean", required: true },
  { key: "defaultProviderId", type: "string", required: true },
  { key: "logLevel", type: "string", required: true, allowed: ["debug", "info", "warn", "error"] },
  { key: "embeddingDimension", type: "number", required: true, integer: true, min: 1 },
  { key: "providerTimeoutMs", type: "number", required: true, integer: true, min: 1e3 },
  // 历史版本兼容：这些字段允许缺失，由 mergeSettings/ensureBackwardCompatibility 补齐默认值
  { key: "taskTimeoutMs", type: "number", required: false, integer: true, min: 1e3 },
  { key: "maxTaskHistory", type: "number", required: false, integer: true, min: 50 }
];
var REQUIRED_DIRECTORY_SCHEME_FIELDS = [
  "Domain",
  "Issue",
  "Theory",
  "Entity",
  "Mechanism"
];
var TASK_TYPES = [
  "define",
  "tag",
  "write",
  "amend",
  "merge",
  "index",
  "verify",
  "image-generate"
];
var DEFAULT_TASK_MODEL_CONFIGS = {
  define: {
    providerId: "",
    model: "gemini-3-flash-preview",
    temperature: 0.3,
    topP: 1
  },
  tag: {
    providerId: "",
    model: "gemini-3-flash-preview",
    temperature: 0.5,
    topP: 1
  },
  write: {
    providerId: "",
    model: "gemini-3-flash-preview",
    temperature: 0.7,
    topP: 1
  },
  amend: {
    providerId: "",
    model: "gemini-3-flash-preview",
    temperature: 0.7,
    topP: 1
  },
  merge: {
    providerId: "",
    model: "gemini-3-flash-preview",
    temperature: 0.7,
    topP: 1
  },
  index: {
    providerId: "",
    model: "text-embedding-3-small",
    embeddingDimension: 1536
  },
  verify: {
    providerId: "",
    model: "gemini-3-flash-preview",
    temperature: 0.3,
    topP: 1
  },
  "image-generate": {
    providerId: "",
    model: "gemini-3-pro-image-preview"
  }
};
var PARAM_RECOMMENDATIONS = {
  temperature: {
    define: { min: 0.2, max: 0.5, recommended: "0.3-0.5" },
    tag: { min: 0.3, max: 0.7, recommended: "0.5" },
    write: { min: 0.5, max: 1, recommended: "0.7-0.9" },
    verify: { min: 0.2, max: 0.5, recommended: "0.3" }
  },
  topP: {
    default: { min: 0.8, max: 1, recommended: "0.8-1.0" }
  },
  embeddingDimension: {
    recommended: "1536",
    options: [256, 512, 1024, 1536, 3072]
  }
};
var DEFAULT_IMAGE_SETTINGS = {
  enabled: true,
  defaultSize: "1024x1024",
  defaultImageSize: "2K",
  defaultAspectRatio: "1:1",
  defaultQuality: "standard",
  defaultStyle: "natural",
  contextWindowSize: 500
};
function createDefaultTaskModels() {
  const taskModels = {};
  for (const taskType of TASK_TYPES) {
    taskModels[taskType] = { ...DEFAULT_TASK_MODEL_CONFIGS[taskType] };
  }
  return taskModels;
}
var DEFAULT_SETTINGS = {
  version: "1.0.0",
  // 基础设置
  language: "zh",
  // 命名设置 (G-10: 命名规范性公理)
  namingTemplate: "{{chinese}} ({{english}})",
  // 存储设置
  directoryScheme: DEFAULT_DIRECTORY_SCHEME,
  // 去重设置 (G-02: 语义唯一性公理, A-FUNC-04: 语义去重检测)
  similarityThreshold: 0.85,
  // 队列设置
  concurrency: 1,
  autoRetry: true,
  maxRetryAttempts: 3,
  taskTimeoutMs: DEFAULT_TASK_TIMEOUT_MS,
  maxTaskHistory: DEFAULT_TASK_HISTORY,
  // 快照设置
  maxSnapshots: 100,
  maxSnapshotAgeDays: 30,
  // A-FUNC-02: 可配置的快照保留天数
  // 功能开关
  enableAutoVerify: false,
  // Provider 配置
  providers: {},
  defaultProviderId: "",
  // 任务模型配置
  taskModels: createDefaultTaskModels(),
  // 图片生成配置
  imageGeneration: { ...DEFAULT_IMAGE_SETTINGS },
  // 日志级别
  logLevel: "info",
  // 嵌入向量维度（text-embedding-3-small 支持 512-3072，默认 1536）
  embeddingDimension: 1536,
  // Provider 请求超时（毫秒，默认 60000 = 60秒）
  providerTimeoutMs: 6e4,
  // 工作台 UI 状态
  uiState: { ...DEFAULT_UI_STATE, sectionCollapsed: { ...DEFAULT_UI_STATE.sectionCollapsed }, sortPreferences: {} }
};
var SettingsStore = class {
  plugin;
  settings;
  listeners = [];
  /**
   * 构造函数
   * @param plugin Obsidian Plugin 实例
   */
  constructor(plugin) {
    this.plugin = plugin;
    this.settings = this.createDefaultSettingsSnapshot();
  }
  /** 加载设置 */
  async loadSettings() {
    try {
      const raw = await this.plugin.loadData();
      if (!raw) {
        this.settings = { ...DEFAULT_SETTINGS };
        await this.saveSettings();
        return ok(void 0);
      }
      const data = this.normalizeLegacySettings(raw);
      const compatibilityResult = this.checkVersionCompatibility(data.version);
      if (!compatibilityResult.ok) {
        this.settings = { ...DEFAULT_SETTINGS };
        await this.saveSettings();
        return ok(void 0);
      }
      const validationResult = this.validateSettingsDetailed(data);
      if (!validationResult.valid) {
        this.settings = { ...DEFAULT_SETTINGS };
        await this.saveSettings();
        return ok(void 0);
      }
      this.settings = this.mergeSettings(DEFAULT_SETTINGS, data);
      this.ensureBackwardCompatibility();
      return ok(void 0);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to load settings",
        error
      );
    }
  }
  /**
   * 获取设置
   */
  getSettings() {
    return { ...this.settings };
  }
  /**
   * 更新设置
   */
  async updateSettings(partial) {
    try {
      const mergeResult = this.mergePartialSettings(partial);
      if (!mergeResult.ok) {
        return mergeResult;
      }
      const validation = this.validateSettingsDetailed(mergeResult.value);
      if (!validation.valid) {
        return err(
          "E101_INVALID_INPUT",
          "\u8BBE\u7F6E\u6821\u9A8C\u5931\u8D25",
          { errors: validation.errors }
        );
      }
      this.settings = mergeResult.value;
      await this.saveSettings();
      this.notifyListeners();
      return ok(void 0);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to update settings",
        error
      );
    }
  }
  /**
   * 导出设置
   */
  exportSettings() {
    return JSON.stringify(this.serializeSettings(true), null, 2);
  }
  /**
   * 导入设置
   */
  async importSettings(json) {
    try {
      const raw = JSON.parse(json);
      const data = this.normalizeLegacySettings(raw);
      if (!this.validateSettings(data)) {
        return err(
          "E101_INVALID_INPUT",
          "Invalid settings format",
          { json }
        );
      }
      const compatibilityResult = this.checkVersionCompatibility(data.version);
      if (!compatibilityResult.ok) {
        return compatibilityResult;
      }
      this.settings = this.mergeSettings(DEFAULT_SETTINGS, data);
      await this.saveSettings();
      this.notifyListeners();
      return ok(void 0);
    } catch (error) {
      return err(
        "E101_INVALID_INPUT",
        "Failed to parse settings JSON",
        error
      );
    }
  }
  /**
   * 重置为默认值
   */
  async resetToDefaults() {
    try {
      this.settings = { ...DEFAULT_SETTINGS };
      await this.saveSettings();
      this.notifyListeners();
      return ok(void 0);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to reset settings",
        error
      );
    }
  }
  /**
   * 订阅设置变更
   */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /**
   * 保存设置到磁盘
   */
  async saveSettings() {
    await this.plugin.saveData(this.serializeSettings());
  }
  /**
   * 通知所有监听器
   */
  notifyListeners() {
    const settingsCopy = { ...this.settings };
    for (const listener of this.listeners) {
      listener(settingsCopy);
    }
  }
  /** 创建默认设置快照，避免引用共享 */
  createDefaultSettingsSnapshot() {
    return {
      ...DEFAULT_SETTINGS,
      directoryScheme: { ...DEFAULT_SETTINGS.directoryScheme },
      providers: { ...DEFAULT_SETTINGS.providers },
      taskModels: createDefaultTaskModels(),
      imageGeneration: { ...DEFAULT_IMAGE_SETTINGS },
      uiState: { ...DEFAULT_UI_STATE, sectionCollapsed: { ...DEFAULT_UI_STATE.sectionCollapsed }, sortPreferences: {} }
    };
  }
  /**
   * 序列化设置
   */
  serializeSettings(redactAllApiKeys = false) {
    const providers = {};
    for (const [id, config] of Object.entries(this.settings.providers)) {
      providers[id] = {
        ...config,
        apiKey: redactAllApiKeys ? "" : config.apiKey
      };
    }
    return {
      ...this.settings,
      providers
    };
  }
  /**
   * 检查版本兼容性
   */
  checkVersionCompatibility(version) {
    const currentMajor = DEFAULT_SETTINGS.version.split(".")[0];
    const loadedMajor = version.split(".")[0];
    if (currentMajor !== loadedMajor) {
      return err(
        "E101_INVALID_INPUT",
        `Incompatible settings version: ${version} (current: ${DEFAULT_SETTINGS.version})`,
        { version, currentVersion: DEFAULT_SETTINGS.version }
      );
    }
    return ok(void 0);
  }
  /**
   * 验证设置结构（简单布尔返回）
   * @param data 待验证的数据
   * @returns 是否为有效的 PluginSettings
   */
  validateSettings(data) {
    const result = this.validateSettingsDetailed(data);
    return result.valid;
  }
  /** 详细验证设置结构 */
  validateSettingsDetailed(data) {
    const errors = [];
    if (typeof data !== "object" || data === null) {
      errors.push({
        field: "root",
        message: "Settings must be a non-null object",
        expectedType: "object",
        actualType: data === null ? "null" : typeof data,
        severity: "error"
      });
      return { valid: false, errors };
    }
    const settings = data;
    this.validateScalarSettings(settings, errors);
    this.validateDirectoryScheme(settings.directoryScheme, errors);
    if (typeof settings.providers !== "object" || settings.providers === null) {
      errors.push({
        field: "providers",
        message: "providers must be an object",
        expectedType: "object",
        actualType: settings.providers === null ? "null" : typeof settings.providers,
        severity: "error"
      });
    } else {
      for (const [providerId, providerConfig] of Object.entries(settings.providers)) {
        if (typeof providerConfig !== "object" || providerConfig === null) {
          errors.push({
            field: `providers.${providerId}`,
            message: "provider config must be an object",
            expectedType: "ProviderConfig",
            actualType: providerConfig === null ? "null" : typeof providerConfig,
            severity: "error"
          });
          continue;
        }
        const cfg = providerConfig;
        if (typeof cfg.apiKey !== "string") {
          errors.push({
            field: `providers.${providerId}.apiKey`,
            message: "apiKey must be a string",
            expectedType: "string",
            actualType: typeof cfg.apiKey,
            severity: "error"
          });
        }
        if (cfg.baseUrl !== void 0 && typeof cfg.baseUrl !== "string") {
          errors.push({
            field: `providers.${providerId}.baseUrl`,
            message: "baseUrl must be a string",
            expectedType: "string",
            actualType: typeof cfg.baseUrl,
            severity: "error"
          });
        }
        if (cfg.baseUrl !== void 0 && typeof cfg.baseUrl === "string" && cfg.baseUrl !== "") {
          try {
            new URL(cfg.baseUrl);
          } catch {
            errors.push({
              field: `providers.${providerId}.baseUrl`,
              message: "baseUrl \u683C\u5F0F\u65E0\u6548",
              severity: "error"
            });
          }
        }
        if (typeof cfg.defaultChatModel !== "string") {
          errors.push({
            field: `providers.${providerId}.defaultChatModel`,
            message: "defaultChatModel must be a string",
            expectedType: "string",
            actualType: typeof cfg.defaultChatModel,
            severity: "error"
          });
        }
        if (typeof cfg.defaultEmbedModel !== "string") {
          errors.push({
            field: `providers.${providerId}.defaultEmbedModel`,
            message: "defaultEmbedModel must be a string",
            expectedType: "string",
            actualType: typeof cfg.defaultEmbedModel,
            severity: "error"
          });
        }
        if (typeof cfg.enabled !== "boolean") {
          errors.push({
            field: `providers.${providerId}.enabled`,
            message: "enabled must be a boolean",
            expectedType: "boolean",
            actualType: typeof cfg.enabled,
            severity: "error"
          });
        }
      }
    }
    this.validateTaskModels(settings.taskModels, errors);
    this.validateTaskModelProviderRefs(settings.taskModels, settings.providers, errors);
    if (settings.imageGeneration !== void 0) {
      const img = settings.imageGeneration;
      if (typeof img !== "object" || img === null) {
        errors.push({
          field: "imageGeneration",
          message: "imageGeneration must be an object",
          expectedType: "object",
          actualType: img === null ? "null" : typeof img,
          severity: "error"
        });
      } else {
        if (typeof img.enabled !== "boolean") {
          errors.push({
            field: "imageGeneration.enabled",
            message: "imageGeneration.enabled must be a boolean",
            expectedType: "boolean",
            actualType: typeof img.enabled,
            severity: "error"
          });
        }
        if (typeof img.defaultSize !== "string") {
          errors.push({
            field: "imageGeneration.defaultSize",
            message: "imageGeneration.defaultSize must be a string",
            expectedType: "string",
            actualType: typeof img.defaultSize,
            severity: "error"
          });
        }
        if (img.defaultImageSize !== void 0 && typeof img.defaultImageSize !== "string") {
          errors.push({
            field: "imageGeneration.defaultImageSize",
            message: "imageGeneration.defaultImageSize must be a string",
            expectedType: "string",
            actualType: typeof img.defaultImageSize,
            severity: "error"
          });
        }
        if (img.defaultAspectRatio !== void 0 && typeof img.defaultAspectRatio !== "string") {
          errors.push({
            field: "imageGeneration.defaultAspectRatio",
            message: "imageGeneration.defaultAspectRatio must be a string",
            expectedType: "string",
            actualType: typeof img.defaultAspectRatio,
            severity: "error"
          });
        }
        if (typeof img.defaultQuality !== "string") {
          errors.push({
            field: "imageGeneration.defaultQuality",
            message: "imageGeneration.defaultQuality must be a string",
            expectedType: "string",
            actualType: typeof img.defaultQuality,
            severity: "error"
          });
        }
        if (typeof img.defaultStyle !== "string") {
          errors.push({
            field: "imageGeneration.defaultStyle",
            message: "imageGeneration.defaultStyle must be a string",
            expectedType: "string",
            actualType: typeof img.defaultStyle,
            severity: "error"
          });
        }
        if (typeof img.contextWindowSize !== "number") {
          errors.push({
            field: "imageGeneration.contextWindowSize",
            message: "imageGeneration.contextWindowSize must be a number",
            expectedType: "number",
            actualType: typeof img.contextWindowSize,
            severity: "error"
          });
        }
      }
    }
    return { valid: errors.filter((e) => e.severity === "error").length === 0, errors };
  }
  validateScalarSettings(settings, errors) {
    for (const spec of SCALAR_SETTINGS_SPECS) {
      const value = settings[spec.key];
      if (value === void 0) {
        if (spec.required) {
          errors.push({
            field: spec.key,
            message: `${spec.key} is required`,
            expectedType: spec.type,
            actualType: "undefined",
            severity: "error"
          });
        }
        continue;
      }
      if (spec.type === "string") {
        if (typeof value !== "string") {
          errors.push({
            field: spec.key,
            message: `${spec.key} must be a string`,
            expectedType: "string",
            actualType: value === null ? "null" : typeof value,
            severity: "error"
          });
          continue;
        }
        if (spec.allowed && !spec.allowed.includes(value)) {
          errors.push({
            field: spec.key,
            message: `${spec.key} must be one of: ${spec.allowed.join(", ")}`,
            expectedType: spec.allowed.join(" | "),
            actualType: `'${value}'`,
            severity: "error"
          });
        }
        continue;
      }
      if (spec.type === "boolean") {
        if (typeof value !== "boolean") {
          errors.push({
            field: spec.key,
            message: `${spec.key} must be a boolean`,
            expectedType: "boolean",
            actualType: value === null ? "null" : typeof value,
            severity: "error"
          });
        }
        continue;
      }
      if (typeof value !== "number" || Number.isNaN(value)) {
        errors.push({
          field: spec.key,
          message: `${spec.key} must be a number`,
          expectedType: "number",
          actualType: value === null ? "null" : typeof value,
          severity: "error"
        });
        continue;
      }
      if (spec.integer && !Number.isInteger(value)) {
        errors.push({
          field: spec.key,
          message: `${spec.key} must be an integer`,
          expectedType: "integer",
          actualType: String(value),
          severity: "error"
        });
        continue;
      }
      if (spec.min !== void 0 && value < spec.min) {
        errors.push({
          field: spec.key,
          message: `${spec.key} must be >= ${spec.min}`,
          expectedType: `number (>=${spec.min})`,
          actualType: String(value),
          severity: "error"
        });
      }
      if (spec.max !== void 0 && value > spec.max) {
        errors.push({
          field: spec.key,
          message: `${spec.key} must be <= ${spec.max}`,
          expectedType: `number (<=${spec.max})`,
          actualType: String(value),
          severity: "error"
        });
      }
    }
  }
  applyScalarUpdates(partial, target) {
    for (const spec of SCALAR_SETTINGS_SPECS) {
      const value = partial[spec.key];
      if (value === void 0) {
        continue;
      }
      if (spec.type === "string") {
        if (typeof value !== "string") {
          return err("E101_INVALID_INPUT", `${spec.key} \u5FC5\u987B\u662F\u5B57\u7B26\u4E32`);
        }
        if (spec.allowed && !spec.allowed.includes(value)) {
          return err("E101_INVALID_INPUT", `${spec.key} \u4E0D\u5408\u6CD5`);
        }
        Reflect.set(target, spec.key, value);
        continue;
      }
      if (spec.type === "boolean") {
        if (typeof value !== "boolean") {
          return err("E101_INVALID_INPUT", `${spec.key} \u5FC5\u987B\u662F\u5E03\u5C14\u503C`);
        }
        Reflect.set(target, spec.key, value);
        continue;
      }
      if (typeof value !== "number" || Number.isNaN(value)) {
        return err("E101_INVALID_INPUT", `${spec.key} \u5FC5\u987B\u662F\u6570\u5B57`);
      }
      if (spec.integer && !Number.isInteger(value)) {
        return err("E101_INVALID_INPUT", `${spec.key} \u5FC5\u987B\u662F\u6574\u6570`);
      }
      if (spec.min !== void 0 && value < spec.min) {
        return err("E101_INVALID_INPUT", `${spec.key} \u5FC5\u987B >= ${spec.min}`);
      }
      if (spec.max !== void 0 && value > spec.max) {
        return err("E101_INVALID_INPUT", `${spec.key} \u5FC5\u987B <= ${spec.max}`);
      }
      Reflect.set(target, spec.key, value);
    }
    return ok(void 0);
  }
  /** 验证 DirectoryScheme 结构 */
  validateDirectoryScheme(directoryScheme, errors) {
    if (typeof directoryScheme !== "object" || directoryScheme === null) {
      errors.push({
        field: "directoryScheme",
        message: "directoryScheme must be an object",
        expectedType: "object",
        actualType: directoryScheme === null ? "null" : typeof directoryScheme,
        severity: "error"
      });
      return;
    }
    const scheme = directoryScheme;
    for (const field of REQUIRED_DIRECTORY_SCHEME_FIELDS) {
      if (typeof scheme[field] !== "string") {
        errors.push({
          field: `directoryScheme.${field}`,
          message: `directoryScheme.${field} must be a string`,
          expectedType: "string",
          actualType: typeof scheme[field],
          severity: "error"
        });
      }
    }
  }
  /** 验证 TaskModels 结构 */
  validateTaskModels(taskModels, errors) {
    if (typeof taskModels !== "object" || taskModels === null) {
      errors.push({
        field: "taskModels",
        message: "taskModels must be an object",
        expectedType: "object",
        actualType: taskModels === null ? "null" : typeof taskModels,
        severity: "error"
      });
      return;
    }
    const models = taskModels;
    for (const taskType of TASK_TYPES) {
      const model = models[taskType];
      if (typeof model !== "object" || model === null) {
        errors.push({
          field: `taskModels.${taskType}`,
          message: `taskModels.${taskType} must be an object`,
          expectedType: "TaskModelConfig",
          actualType: model === null ? "null" : typeof model,
          severity: "error"
        });
        continue;
      }
      const modelConfig = model;
      if (typeof modelConfig.providerId !== "string") {
        errors.push({
          field: `taskModels.${taskType}.providerId`,
          message: `taskModels.${taskType}.providerId must be a string`,
          expectedType: "string",
          actualType: typeof modelConfig.providerId,
          severity: "error"
        });
      }
      if (typeof modelConfig.model !== "string") {
        errors.push({
          field: `taskModels.${taskType}.model`,
          message: `taskModels.${taskType}.model must be a string`,
          expectedType: "string",
          actualType: typeof modelConfig.model,
          severity: "error"
        });
      }
      if (modelConfig.temperature !== void 0 && typeof modelConfig.temperature !== "number") {
        errors.push({
          field: `taskModels.${taskType}.temperature`,
          message: `taskModels.${taskType}.temperature must be a number`,
          expectedType: "number",
          actualType: typeof modelConfig.temperature,
          severity: "error"
        });
      }
      if (modelConfig.topP !== void 0 && typeof modelConfig.topP !== "number") {
        errors.push({
          field: `taskModels.${taskType}.topP`,
          message: `taskModels.${taskType}.topP must be a number`,
          expectedType: "number",
          actualType: typeof modelConfig.topP,
          severity: "error"
        });
      }
      if (modelConfig.maxTokens !== void 0 && typeof modelConfig.maxTokens !== "number") {
        errors.push({
          field: `taskModels.${taskType}.maxTokens`,
          message: `taskModels.${taskType}.maxTokens must be a number`,
          expectedType: "number",
          actualType: typeof modelConfig.maxTokens,
          severity: "error"
        });
      }
    }
  }
  /** TaskModel → Provider 引用交叉校验（需求 21.3） */
  validateTaskModelProviderRefs(taskModels, providers, errors) {
    if (typeof taskModels !== "object" || taskModels === null) return;
    if (typeof providers !== "object" || providers === null) return;
    const models = taskModels;
    const providerMap = providers;
    for (const taskType of TASK_TYPES) {
      const model = models[taskType];
      if (typeof model !== "object" || model === null) continue;
      const providerId = model.providerId;
      if (typeof providerId !== "string" || providerId === "") continue;
      if (!providerMap[providerId]) {
        errors.push({
          field: `taskModels.${taskType}.providerId`,
          message: `\u5F15\u7528\u7684 Provider "${providerId}" \u4E0D\u5B58\u5728\uFF0C\u5C06\u56DE\u9000\u5230\u9ED8\u8BA4 Provider`,
          severity: "warning"
        });
      }
    }
  }
  /** 合并部分设置并进行类型检查 */
  mergePartialSettings(partial) {
    const next2 = {
      ...this.settings,
      directoryScheme: { ...this.settings.directoryScheme },
      providers: { ...this.settings.providers },
      taskModels: { ...this.settings.taskModels },
      imageGeneration: { ...this.settings.imageGeneration }
    };
    const scalarResult = this.applyScalarUpdates(partial, next2);
    if (!scalarResult.ok) {
      return scalarResult;
    }
    if (partial.directoryScheme !== void 0) {
      if (!this.isPlainObject(partial.directoryScheme)) {
        return err("E101_INVALID_INPUT", "directoryScheme \u5FC5\u987B\u662F\u5BF9\u8C61");
      }
      next2.directoryScheme = {
        ...next2.directoryScheme,
        ...partial.directoryScheme
      };
    }
    if (partial.providers !== void 0) {
      if (!this.isPlainObject(partial.providers)) {
        return err("E101_INVALID_INPUT", "providers \u5FC5\u987B\u662F\u5BF9\u8C61");
      }
      const mergedProviders = { ...next2.providers };
      for (const [providerId, providerConfig] of Object.entries(partial.providers)) {
        const existing = mergedProviders[providerId];
        const normalized = this.normalizeProviderConfig(existing, providerConfig);
        if (!normalized.ok) {
          return normalized;
        }
        mergedProviders[providerId] = normalized.value;
      }
      next2.providers = mergedProviders;
    }
    if (partial.taskModels !== void 0) {
      if (!this.isPlainObject(partial.taskModels)) {
        return err("E101_INVALID_INPUT", "taskModels \u5FC5\u987B\u662F\u5BF9\u8C61");
      }
      const mergedTaskModels = { ...next2.taskModels };
      for (const [taskType, config] of Object.entries(partial.taskModels)) {
        const existing = mergedTaskModels[taskType];
        if (!existing) {
          continue;
        }
        if (!this.isPlainObject(config)) {
          return err("E101_INVALID_INPUT", `taskModels.${taskType} \u5FC5\u987B\u662F\u5BF9\u8C61`);
        }
        mergedTaskModels[taskType] = {
          ...existing,
          ...config
        };
      }
      next2.taskModels = mergedTaskModels;
    }
    if (partial.imageGeneration !== void 0) {
      if (!this.isPlainObject(partial.imageGeneration)) {
        return err("E101_INVALID_INPUT", "imageGeneration \u5FC5\u987B\u662F\u5BF9\u8C61");
      }
      next2.imageGeneration = {
        ...next2.imageGeneration,
        ...partial.imageGeneration
      };
    }
    if (partial.uiState !== void 0) {
      if (!this.isPlainObject(partial.uiState)) {
        return err("E101_INVALID_INPUT", "uiState \u5FC5\u987B\u662F\u5BF9\u8C61");
      }
      const currentUI = next2.uiState ?? { ...DEFAULT_UI_STATE };
      next2.uiState = {
        ...currentUI,
        ...partial.uiState,
        sectionCollapsed: {
          ...currentUI.sectionCollapsed ?? {},
          ...partial.uiState?.sectionCollapsed ?? {}
        },
        sortPreferences: {
          ...currentUI.sortPreferences ?? {},
          ...partial.uiState?.sortPreferences ?? {}
        }
      };
    }
    return ok(next2);
  }
  /**
   * 合并设置（深度合并）
   */
  mergeSettings(defaults, loaded) {
    const merged = { ...defaults };
    for (const key2 in loaded) {
      if (Object.prototype.hasOwnProperty.call(loaded, key2)) {
        const value = loaded[key2];
        const defaultValue = defaults[key2];
        if (value !== void 0) {
          if (typeof value === "object" && value !== null && !Array.isArray(value) && typeof defaultValue === "object") {
            Object.assign(merged, {
              [key2]: {
                ...defaultValue,
                ...value
              }
            });
          } else {
            Object.assign(merged, { [key2]: value });
          }
        }
      }
    }
    return merged;
  }
  /**
   * 兼容旧版设置字段：enableGrounding → enableAutoVerify
   *
   * 说明：
   * - 文档 SSOT 以 enableAutoVerify 为准
   * - 旧字段仍可能存在于用户的 data.json / 导入文件中
   */
  normalizeLegacySettings(raw) {
    if (!this.isPlainObject(raw)) {
      return raw;
    }
    const normalized = { ...raw };
    if (!Object.prototype.hasOwnProperty.call(normalized, "enableAutoVerify") && typeof normalized.enableGrounding === "boolean") {
      normalized.enableAutoVerify = normalized.enableGrounding;
    }
    if (Object.prototype.hasOwnProperty.call(normalized, "enableGrounding")) {
      delete normalized.enableGrounding;
    }
    if (Object.prototype.hasOwnProperty.call(normalized, "topK")) {
      delete normalized.topK;
    }
    return normalized;
  }
  /** 向后兼容：填充新字段缺省值，修复缺失的任务模型配置 */
  ensureBackwardCompatibility() {
    if (!this.settings.imageGeneration) {
      this.settings.imageGeneration = { ...DEFAULT_IMAGE_SETTINGS };
    } else {
      this.settings.imageGeneration = {
        ...DEFAULT_IMAGE_SETTINGS,
        ...this.settings.imageGeneration
      };
    }
    const taskModels = {
      ...createDefaultTaskModels(),
      ...this.settings.taskModels
    };
    for (const taskType of TASK_TYPES) {
      if (!taskModels[taskType]) {
        taskModels[taskType] = { ...DEFAULT_TASK_MODEL_CONFIGS[taskType] };
      } else {
        taskModels[taskType] = {
          ...DEFAULT_TASK_MODEL_CONFIGS[taskType],
          ...taskModels[taskType]
        };
      }
    }
    this.settings.taskModels = taskModels;
  }
  normalizeProviderConfig(existing, incoming) {
    if (!this.isPlainObject(incoming)) {
      return err("E101_INVALID_INPUT", "provider \u914D\u7F6E\u5FC5\u987B\u662F\u5BF9\u8C61");
    }
    const incomingConfig = incoming;
    const base = existing ? { ...existing } : {
      apiKey: "",
      baseUrl: void 0,
      defaultChatModel: "gpt-4o",
      defaultEmbedModel: "text-embedding-3-small",
      enabled: true
    };
    if (incomingConfig.apiKey !== void 0) {
      if (typeof incomingConfig.apiKey !== "string") {
        return err("E101_INVALID_INPUT", "provider.apiKey \u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
      }
      base.apiKey = incomingConfig.apiKey.trim();
    }
    if (incomingConfig.baseUrl !== void 0) {
      if (incomingConfig.baseUrl !== null && typeof incomingConfig.baseUrl !== "string") {
        return err("E101_INVALID_INPUT", "provider.baseUrl \u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
      }
      base.baseUrl = incomingConfig.baseUrl?.trim() || void 0;
    }
    if (incomingConfig.defaultChatModel !== void 0) {
      if (typeof incomingConfig.defaultChatModel !== "string") {
        return err("E101_INVALID_INPUT", "provider.defaultChatModel \u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
      }
      base.defaultChatModel = incomingConfig.defaultChatModel.trim();
    }
    if (incomingConfig.defaultEmbedModel !== void 0) {
      if (typeof incomingConfig.defaultEmbedModel !== "string") {
        return err("E101_INVALID_INPUT", "provider.defaultEmbedModel \u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
      }
      base.defaultEmbedModel = incomingConfig.defaultEmbedModel.trim();
    }
    if (incomingConfig.enabled !== void 0) {
      if (typeof incomingConfig.enabled !== "boolean") {
        return err("E101_INVALID_INPUT", "provider.enabled \u5FC5\u987B\u662F\u5E03\u5C14\u503C");
      }
      base.enabled = incomingConfig.enabled;
    }
    return ok(base);
  }
  isPlainObject(value) {
    return typeof value === "object" && value !== null && !Array.isArray(value);
  }
  // 便捷方法
  /** 更新部分设置 */
  async update(partial) {
    return this.updateSettings(partial);
  }
  /**
   * 重置指定任务模型配置到默认值
   */
  async resetTaskModel(taskType) {
    if (!DEFAULT_TASK_MODEL_CONFIGS[taskType]) {
      return err("E101_INVALID_INPUT", `\u672A\u77E5\u7684\u4EFB\u52A1\u7C7B\u578B: ${taskType}`);
    }
    const taskModels = {
      ...this.settings.taskModels,
      [taskType]: { ...DEFAULT_TASK_MODEL_CONFIGS[taskType] }
    };
    return this.updateSettings({ taskModels });
  }
  /**
   * 重置所有任务模型配置到默认值
   */
  async resetAllTaskModels() {
    const taskModels = createDefaultTaskModels();
    return this.updateSettings({ taskModels });
  }
  /**
   * 判断任务模型配置是否为默认值
   */
  isTaskModelDefault(taskType) {
    const current = this.settings.taskModels[taskType];
    const defaults = DEFAULT_TASK_MODEL_CONFIGS[taskType];
    if (!current || !defaults) return false;
    return current.providerId === defaults.providerId && current.model === defaults.model && current.temperature === defaults.temperature && current.topP === defaults.topP && current.reasoning_effort === defaults.reasoning_effort && current.maxTokens === defaults.maxTokens && current.embeddingDimension === defaults.embeddingDimension;
  }
  /**
   * 设置默认 Provider
   */
  async setDefaultProvider(providerId) {
    return this.updateSettings({ defaultProviderId: providerId });
  }
  /**
   * 添加 Provider
   */
  async addProvider(id, config) {
    const providers = { ...this.settings.providers, [id]: config };
    const updates = { providers };
    if (Object.keys(this.settings.providers).length === 0) {
      updates.defaultProviderId = id;
      const taskModels = { ...this.settings.taskModels };
      for (const taskType of TASK_TYPES) {
        if (taskModels[taskType] && !taskModels[taskType].providerId) {
          taskModels[taskType] = {
            ...taskModels[taskType],
            providerId: id
          };
        }
      }
      updates.taskModels = taskModels;
    }
    return this.updateSettings(updates);
  }
  /**
   * 更新 Provider
   */
  async updateProvider(id, updates) {
    const currentConfig = this.settings.providers[id];
    if (!currentConfig) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider \u4E0D\u5B58\u5728: ${id}`);
    }
    const providers = {
      ...this.settings.providers,
      [id]: { ...currentConfig, ...updates }
    };
    return this.updateSettings({ providers });
  }
  /**
   * 移除 Provider
   */
  async removeProvider(id) {
    const providers = { ...this.settings.providers };
    delete providers[id];
    const updates = { providers };
    if (this.settings.defaultProviderId === id) {
      const remainingIds = Object.keys(providers);
      updates.defaultProviderId = remainingIds.length > 0 ? remainingIds[0] : "";
    }
    return this.updateSettings(updates);
  }
  /**
   * 导出设置（返回 Result）
   */
  async export() {
    try {
      return ok(this.exportSettings());
    } catch (error) {
      return err("E500_INTERNAL_ERROR", "\u5BFC\u51FA\u8BBE\u7F6E\u5931\u8D25", error);
    }
  }
  /**
   * 导入设置（importSettings 的别名）
   */
  async import(json) {
    return this.importSettings(json);
  }
  /**
   * 重置设置（resetToDefaults 的别名）
   */
  async reset() {
    return this.resetToDefaults();
  }
};

// src/data/file-storage.ts
function mapFsErrorToErrorCode(error) {
  const candidate = error;
  const code = typeof candidate?.code === "string" ? candidate.code : "";
  if (code === "ENOENT") {
    return "E301_FILE_NOT_FOUND";
  }
  if (code === "EACCES" || code === "EPERM") {
    return "E302_PERMISSION_DENIED";
  }
  if (code === "ENOSPC") {
    return "E303_DISK_FULL";
  }
  return "E500_INTERNAL_ERROR";
}
var DATA_DIR = "data";
var SNAPSHOTS_DIR = `${DATA_DIR}/snapshots`;
var VECTORS_DIR = `${DATA_DIR}/vectors`;
var QUEUE_STATE_FILE = `${DATA_DIR}/queue-state.json`;
var VECTOR_INDEX_META_FILE = `${VECTORS_DIR}/index.json`;
var DUPLICATE_PAIRS_FILE = `${DATA_DIR}/duplicate-pairs.json`;
var SNAPSHOTS_INDEX_FILE = `${SNAPSHOTS_DIR}/index.json`;
var APP_LOG_FILE = `${DATA_DIR}/app.log`;
var DEFAULT_QUEUE_STATE = {
  version: "2.0.0",
  pendingTasks: [],
  paused: false
};
var DEFAULT_DUPLICATE_PAIRS = {
  version: "1.0.0",
  pairs: [],
  dismissedPairs: []
};
var DEFAULT_SNAPSHOT_INDEX = {
  version: "1.0.0",
  snapshots: [],
  retentionPolicy: {
    maxCount: 100,
    maxAgeDays: 30
  }
};
var DEFAULT_VECTOR_INDEX_META = {
  version: "3.0",
  lastUpdated: Date.now(),
  stats: {
    totalConcepts: 0,
    byType: {
      Domain: 0,
      Issue: 0,
      Theory: 0,
      Entity: 0,
      Mechanism: 0
    }
  },
  concepts: {}
};
var FileStorage = class {
  vault;
  basePath;
  initialized = false;
  /** 构造函数 */
  constructor(vault, basePath) {
    this.vault = vault;
    this.basePath = basePath || "";
  }
  /** 解析完整路径 */
  resolvePath(relativePath) {
    if (!this.basePath) {
      return relativePath;
    }
    return `${this.basePath}/${relativePath}`;
  }
  /** 初始化目录结构 */
  async initialize() {
    try {
      const dataDirResult = await this.ensureDir(DATA_DIR);
      if (!dataDirResult.ok) {
        return dataDirResult;
      }
      const snapshotsDirResult = await this.ensureDir(SNAPSHOTS_DIR);
      if (!snapshotsDirResult.ok) {
        return snapshotsDirResult;
      }
      const vectorsDirResult = await this.ensureDir(VECTORS_DIR);
      if (!vectorsDirResult.ok) {
        return vectorsDirResult;
      }
      const types = ["Domain", "Issue", "Theory", "Entity", "Mechanism"];
      for (const type of types) {
        const typeDirResult = await this.ensureDir(`${VECTORS_DIR}/${type}`);
        if (!typeDirResult.ok) {
          return typeDirResult;
        }
      }
      const initResults = await Promise.all([
        this.initializeFileIfNotExists(QUEUE_STATE_FILE, DEFAULT_QUEUE_STATE),
        this.initializeFileIfNotExists(DUPLICATE_PAIRS_FILE, DEFAULT_DUPLICATE_PAIRS),
        this.initializeFileIfNotExists(SNAPSHOTS_INDEX_FILE, DEFAULT_SNAPSHOT_INDEX),
        this.initializeFileIfNotExists(VECTOR_INDEX_META_FILE, DEFAULT_VECTOR_INDEX_META)
      ]);
      for (const result of initResults) {
        if (!result.ok) {
          return result;
        }
      }
      this.initialized = true;
      return ok(void 0);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        "\u521D\u59CB\u5316\u76EE\u5F55\u7ED3\u6784\u5931\u8D25",
        error
      );
    }
  }
  /** 检查是否已初始化 */
  isInitialized() {
    return this.initialized;
  }
  /** 如果文件不存在则初始化 */
  async initializeFileIfNotExists(path, defaultContent) {
    const fileExists = await this.exists(path);
    if (!fileExists) {
      const content = JSON.stringify(defaultContent, null, 2);
      const writeResult = await this.write(path, content);
      if (!writeResult.ok) {
        const error = writeResult;
        console.error(`[FileStorage] Failed to initialize file: ${path}`, error.error.message);
      }
      return writeResult;
    }
    return ok(void 0);
  }
  /** 读取文件 */
  async read(path) {
    try {
      const fullPath = this.resolvePath(path);
      const content = await this.vault.adapter.read(fullPath);
      return ok(content);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        `Failed to read file: ${path}`,
        error
      );
    }
  }
  /** 写入文件（普通写入） */
  async write(path, content) {
    try {
      const fullPath = this.resolvePath(path);
      const dirPath = path.substring(0, path.lastIndexOf("/"));
      if (dirPath) {
        const dirResult = await this.ensureDir(dirPath);
        if (!dirResult.ok) {
          return dirResult;
        }
      }
      await this.vault.adapter.write(fullPath, content);
      return ok(void 0);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        `Failed to write file: ${path}`,
        error
      );
    }
  }
  /** 原子写入文件（临时文件 + 校验 + 重命名） */
  async atomicWrite(path, content) {
    const fullPath = this.resolvePath(path);
    const tempPath = `${fullPath}.tmp`;
    const backupPath = `${fullPath}.bak`;
    try {
      const dirPath = path.substring(0, path.lastIndexOf("/"));
      if (dirPath) {
        const dirResult = await this.ensureDir(dirPath);
        if (!dirResult.ok) {
          return dirResult;
        }
      }
      await this.vault.adapter.write(tempPath, content);
      const verifyResult = await this.verifyWriteIntegrity(tempPath, content);
      if (!verifyResult.ok) {
        await this.cleanupTempFile(tempPath);
        return verifyResult;
      }
      let targetExists = false;
      try {
        const originalContent = await this.vault.adapter.read(fullPath);
        targetExists = true;
        await this.vault.adapter.write(backupPath, originalContent);
        try {
          await this.vault.adapter.remove(fullPath);
        } catch (removeError) {
          const e = removeError;
          if (e.code !== "ENOENT") {
            throw removeError;
          }
        }
      } catch (backupError) {
        const e = backupError;
        if (e.code !== "ENOENT") {
          await this.cleanupTempFile(tempPath);
          return err(
            mapFsErrorToErrorCode(backupError),
            `Failed to backup/remove original file: ${path}`,
            backupError
          );
        }
      }
      try {
        await this.vault.adapter.rename(tempPath, fullPath);
        await this.cleanupTempFile(backupPath);
      } catch (renameError) {
        try {
          const tempContent = await this.vault.adapter.read(tempPath);
          await this.vault.adapter.write(fullPath, tempContent);
          await this.cleanupTempFile(tempPath);
          await this.cleanupTempFile(backupPath);
        } catch (copyError) {
          if (targetExists) {
            try {
              const backupContent = await this.vault.adapter.read(backupPath);
              await this.vault.adapter.write(fullPath, backupContent);
            } catch {
            }
          }
          await this.cleanupTempFile(tempPath);
          await this.cleanupTempFile(backupPath);
          throw copyError;
        }
      }
      return ok(void 0);
    } catch (error) {
      await this.cleanupTempFile(tempPath);
      return err(
        mapFsErrorToErrorCode(error),
        `Atomic write failed for file: ${path}`,
        error
      );
    }
  }
  /** 校验写入完整性 */
  async verifyWriteIntegrity(tempPath, expectedContent) {
    try {
      const actualContent = await this.vault.adapter.read(tempPath);
      if (actualContent !== expectedContent) {
        return err(
          "E500_INTERNAL_ERROR",
          "Write integrity check failed: content mismatch",
          { expected: expectedContent.length, actual: actualContent.length }
        );
      }
      return ok(void 0);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        "Failed to verify write integrity",
        error
      );
    }
  }
  /** 清理临时文件 */
  async cleanupTempFile(tempPath) {
    try {
      await this.vault.adapter.stat(tempPath);
      await this.vault.adapter.remove(tempPath);
    } catch {
    }
  }
  /** 删除文件 */
  async delete(path) {
    try {
      const exists = await this.exists(path);
      if (!exists) {
        return ok(void 0);
      }
      const fullPath = this.resolvePath(path);
      await this.vault.adapter.remove(fullPath);
      return ok(void 0);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        `Failed to delete file: ${path}`,
        error
      );
    }
  }
  /** 检查文件是否存在 */
  async exists(path) {
    try {
      const fullPath = this.resolvePath(path);
      await this.vault.adapter.stat(fullPath);
      return true;
    } catch {
      return false;
    }
  }
  /** 确保目录存在 */
  async ensureDir(path) {
    try {
      const fullPath = this.resolvePath(path);
      try {
        const stat = await this.vault.adapter.stat(fullPath);
        if (stat && stat.type === "folder") {
          return ok(void 0);
        }
      } catch {
      }
      const parts = fullPath.split("/");
      let currentPath = "";
      for (const part of parts) {
        if (!part) continue;
        currentPath = currentPath ? `${currentPath}/${part}` : part;
        try {
          const stat = await this.vault.adapter.stat(currentPath);
          if (stat && stat.type !== "folder") {
            return err(
              "E500_INTERNAL_ERROR",
              `Path exists but is not a directory: ${currentPath}`
            );
          }
        } catch {
          try {
            await this.vault.adapter.mkdir(currentPath);
          } catch (mkdirError) {
            try {
              const stat = await this.vault.adapter.stat(currentPath);
              if (stat && stat.type === "folder") {
                continue;
              }
            } catch {
              return err(
                mapFsErrorToErrorCode(mkdirError),
                `Failed to create directory: ${currentPath}`,
                mkdirError
              );
            }
          }
        }
      }
      try {
        const finalStat = await this.vault.adapter.stat(fullPath);
        if (!finalStat || finalStat.type !== "folder") {
          return err(
            "E500_INTERNAL_ERROR",
            `Directory was not created successfully: ${path}`
          );
        }
      } catch (verifyError) {
        return err(
          mapFsErrorToErrorCode(verifyError),
          `Failed to verify directory creation: ${path}`,
          verifyError
        );
      }
      return ok(void 0);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        `Failed to create directory: ${path}`,
        error
      );
    }
  }
  /** 写入向量文件 */
  async writeVectorFile(type, conceptId, data) {
    const path = `${VECTORS_DIR}/${type}/${conceptId}.json`;
    const content = JSON.stringify(data, null, 2);
    return this.write(path, content);
  }
  /**
   * 读取向量文件
   * @param type 知识类型
   * @param conceptId 概念 UID
   */
  async readVectorFile(type, conceptId) {
    const path = `${VECTORS_DIR}/${type}/${conceptId}.json`;
    const readResult = await this.read(path);
    if (!readResult.ok) {
      return readResult;
    }
    try {
      const data = JSON.parse(readResult.value);
      return ok(data);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        `Failed to parse vector file: ${path}`,
        error
      );
    }
  }
  /**
   * 删除向量文件
   * @param type 知识类型
   * @param conceptId 概念 UID
   */
  async deleteVectorFile(type, conceptId) {
    const path = `${VECTORS_DIR}/${type}/${conceptId}.json`;
    return this.delete(path);
  }
  /**
   * 读取向量索引元数据
   */
  async readVectorIndexMeta() {
    const readResult = await this.read(VECTOR_INDEX_META_FILE);
    if (!readResult.ok) {
      return readResult;
    }
    try {
      const meta = JSON.parse(readResult.value);
      return ok(meta);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        `Failed to parse vector index meta`,
        error
      );
    }
  }
  /**
   * 写入向量索引元数据
   */
  async writeVectorIndexMeta(meta) {
    const content = JSON.stringify(meta, null, 2);
    return this.write(VECTOR_INDEX_META_FILE, content);
  }
  /**
   * 重命名文件
   * @param oldPath 原路径
   * @param newPath 新路径
   */
  async rename(oldPath, newPath) {
    try {
      const fullOldPath = this.resolvePath(oldPath);
      const fullNewPath = this.resolvePath(newPath);
      await this.vault.adapter.rename(fullOldPath, fullNewPath);
      return ok(void 0);
    } catch (error) {
      return err(
        mapFsErrorToErrorCode(error),
        `Failed to rename file: ${oldPath} -> ${newPath}`,
        error
      );
    }
  }
};

// src/data/error-codes.ts
var ERROR_CODE_INFO = {
  // E1xx 输入/校验（不可重试）
  E101_INVALID_INPUT: {
    code: "E101_INVALID_INPUT",
    name: "INVALID_INPUT",
    description: "\u8F93\u5165\u683C\u5F0F\u9519\u8BEF\u6216\u65E0\u6548",
    category: "INPUT_VALIDATION",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5\u8F93\u5165\u5185\u5BB9\u6216\u5FC5\u8981\u53C2\u6570\u540E\u91CD\u8BD5\u3002"
  },
  E102_MISSING_FIELD: {
    code: "E102_MISSING_FIELD",
    name: "MISSING_FIELD",
    description: "\u5FC5\u9700\u5B57\u6BB5\u7F3A\u5931",
    category: "INPUT_VALIDATION",
    retryable: false,
    fixSuggestion: "\u8BF7\u8865\u5168\u5FC5\u8981\u5B57\u6BB5\u540E\u91CD\u8BD5\u3002"
  },
  // E2xx Provider/AI（通常可重试）
  E201_PROVIDER_TIMEOUT: {
    code: "E201_PROVIDER_TIMEOUT",
    name: "PROVIDER_TIMEOUT",
    description: "Provider \u8BF7\u6C42\u8D85\u65F6",
    category: "PROVIDER_AI",
    retryable: true,
    fixSuggestion: "\u53EF\u7A0D\u540E\u91CD\u8BD5\uFF0C\u6216\u5728\u8BBE\u7F6E\u4E2D\u63D0\u9AD8\u8D85\u65F6\u65F6\u95F4/\u5207\u6362\u6A21\u578B\u3002"
  },
  E202_RATE_LIMITED: {
    code: "E202_RATE_LIMITED",
    name: "RATE_LIMITED",
    description: "\u89E6\u53D1\u901F\u7387\u9650\u5236 (429)",
    category: "PROVIDER_AI",
    retryable: true,
    fixSuggestion: "\u8BF7\u7A0D\u540E\u91CD\u8BD5\uFF0C\u6216\u964D\u4F4E\u5E76\u53D1/\u5347\u7EA7\u5957\u9910\u3002"
  },
  E203_INVALID_API_KEY: {
    code: "E203_INVALID_API_KEY",
    name: "INVALID_API_KEY",
    description: "API \u5BC6\u94A5\u65E0\u6548 (401/403)",
    category: "PROVIDER_AI",
    retryable: false,
    fixSuggestion: "\u8BF7\u524D\u5F80\u8BBE\u7F6E\u9875\u9762\u68C0\u67E5\u5E76\u66F4\u65B0 API Key\u3002"
  },
  E204_PROVIDER_ERROR: {
    code: "E204_PROVIDER_ERROR",
    name: "PROVIDER_ERROR",
    description: "Provider \u8C03\u7528\u5931\u8D25\uFF08\u975E\u8D85\u65F6/\u975E\u9274\u6743/\u975E\u9650\u6D41\uFF09",
    category: "PROVIDER_AI",
    retryable: true,
    fixSuggestion: "\u8BF7\u91CD\u8BD5\uFF1B\u82E5\u6301\u7EED\u5931\u8D25\u8BF7\u68C0\u67E5 Provider \u72B6\u6001\u4E0E\u7F51\u7EDC\u3002"
  },
  E210_MODEL_OUTPUT_PARSE_FAILED: {
    code: "E210_MODEL_OUTPUT_PARSE_FAILED",
    name: "MODEL_OUTPUT_PARSE_FAILED",
    description: "\u6A21\u578B\u8F93\u51FA\u975E JSON \u6216\u89E3\u6790\u5931\u8D25",
    category: "PROVIDER_AI",
    retryable: true,
    fixSuggestion: "\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\u5E76\u5F3A\u5316\u8F93\u51FA\u7EA6\u675F\u3002"
  },
  E211_MODEL_SCHEMA_VIOLATION: {
    code: "E211_MODEL_SCHEMA_VIOLATION",
    name: "MODEL_SCHEMA_VIOLATION",
    description: "\u6A21\u578B\u8F93\u51FA\u4E0D\u7B26\u5408 Schema",
    category: "PROVIDER_AI",
    retryable: true,
    fixSuggestion: "\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\u5E76\u63D0\u793A\u6A21\u578B\u4FEE\u6B63\u7ED3\u6784\u3002"
  },
  E212_MODEL_CONSTRAINT_VIOLATION: {
    code: "E212_MODEL_CONSTRAINT_VIOLATION",
    name: "MODEL_CONSTRAINT_VIOLATION",
    description: "\u6A21\u578B\u8F93\u51FA\u8FDD\u53CD\u4E1A\u52A1\u7EA6\u675F",
    category: "PROVIDER_AI",
    retryable: true,
    fixSuggestion: "\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\uFF1B\u82E5\u6301\u7EED\u5931\u8D25\u8BF7\u68C0\u67E5\u8F93\u5165\u662F\u5426\u8FC7\u4E8E\u542B\u6DF7\u3002"
  },
  E213_SAFETY_VIOLATION: {
    code: "E213_SAFETY_VIOLATION",
    name: "SAFETY_VIOLATION",
    description: "\u89E6\u53D1\u5B89\u5168\u8FB9\u754C",
    category: "PROVIDER_AI",
    retryable: false,
    fixSuggestion: "\u8BF7\u4FEE\u6539\u8F93\u5165\u5185\u5BB9\uFF0C\u907F\u514D\u89E6\u53D1\u5B89\u5168\u9650\u5236\u3002"
  },
  // E3xx 系统/IO/状态（视情况）
  E301_FILE_NOT_FOUND: {
    code: "E301_FILE_NOT_FOUND",
    name: "FILE_NOT_FOUND",
    description: "\u6587\u4EF6\u4E0D\u5B58\u5728",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5\u6587\u4EF6\u8DEF\u5F84\u6216\u5237\u65B0 Vault \u72B6\u6001\u540E\u91CD\u8BD5\u3002"
  },
  E302_PERMISSION_DENIED: {
    code: "E302_PERMISSION_DENIED",
    name: "PERMISSION_DENIED",
    description: "\u6CA1\u6709\u6587\u4EF6\u64CD\u4F5C\u6743\u9650",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5 Vault/\u7CFB\u7EDF\u6743\u9650\u6216\u5173\u95ED\u5360\u7528\u6587\u4EF6\u7684\u7A0B\u5E8F\u3002"
  },
  E303_DISK_FULL: {
    code: "E303_DISK_FULL",
    name: "DISK_FULL",
    description: "\u78C1\u76D8\u7A7A\u95F4\u4E0D\u8DB3",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u91CA\u653E\u78C1\u76D8\u7A7A\u95F4\u540E\u91CD\u8BD5\u3002"
  },
  E304_SNAPSHOT_FAILED: {
    code: "E304_SNAPSHOT_FAILED",
    name: "SNAPSHOT_FAILED",
    description: "\u5FEB\u7167\u521B\u5EFA\u5931\u8D25",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5\u5FEB\u7167\u76EE\u5F55\u6743\u9650\u4E0E\u78C1\u76D8\u7A7A\u95F4\u3002"
  },
  E305_VECTOR_MISMATCH: {
    code: "E305_VECTOR_MISMATCH",
    name: "VECTOR_MISMATCH",
    description: "\u5411\u91CF\u7EF4\u5EA6\u4E0D\u5339\u914D",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u786E\u8BA4 embedding \u6A21\u578B\u4E0E dimensions \u4E00\u81F4\uFF0C\u5FC5\u8981\u65F6\u91CD\u5EFA\u7D22\u5F15\u3002"
  },
  E310_INVALID_STATE: {
    code: "E310_INVALID_STATE",
    name: "INVALID_STATE",
    description: "\u72B6\u6001\u4E0D\u6B63\u786E\u6216\u524D\u7F6E\u6761\u4EF6\u4E0D\u6EE1\u8DB3",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u6309\u6D41\u7A0B\u64CD\u4F5C\u6216\u5237\u65B0\u540E\u91CD\u8BD5\u3002"
  },
  E311_NOT_FOUND: {
    code: "E311_NOT_FOUND",
    name: "NOT_FOUND",
    description: "\u8D44\u6E90\u6216\u5BF9\u8C61\u4E0D\u5B58\u5728",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5\u76EE\u6807\u662F\u5426\u4ECD\u5B58\u5728\u6216\u5237\u65B0\u540E\u91CD\u8BD5\u3002"
  },
  E320_TASK_CONFLICT: {
    code: "E320_TASK_CONFLICT",
    name: "TASK_CONFLICT",
    description: "\u4EFB\u52A1/\u9501\u51B2\u7A81\u6216\u5E76\u53D1\u9650\u5236",
    category: "SYSTEM_IO",
    retryable: false,
    fixSuggestion: "\u8BF7\u7B49\u5F85\u5F53\u524D\u4EFB\u52A1\u5B8C\u6210\uFF0C\u6216\u53D6\u6D88\u540E\u518D\u8BD5\u3002"
  },
  // E4xx 配置（不可重试）
  E401_PROVIDER_NOT_CONFIGURED: {
    code: "E401_PROVIDER_NOT_CONFIGURED",
    name: "PROVIDER_NOT_CONFIGURED",
    description: "Provider \u672A\u914D\u7F6E",
    category: "CONFIG",
    retryable: false,
    fixSuggestion: "\u8BF7\u5148\u5728\u8BBE\u7F6E\u9875\u914D\u7F6E Provider \u4E0E API Key\u3002"
  },
  E404_TEMPLATE_NOT_FOUND: {
    code: "E404_TEMPLATE_NOT_FOUND",
    name: "TEMPLATE_NOT_FOUND",
    description: "Prompt \u6A21\u677F\u4E0D\u5B58\u5728\u6216\u672A\u52A0\u8F7D",
    category: "CONFIG",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5 prompts \u76EE\u5F55\u4E0E\u6A21\u677F\u6587\u4EF6\u662F\u5426\u5B8C\u6574\u3002"
  },
  E405_TEMPLATE_INVALID: {
    code: "E405_TEMPLATE_INVALID",
    name: "TEMPLATE_INVALID",
    description: "Prompt \u6A21\u677F\u4E0D\u7B26\u5408\u5951\u7EA6\uFF08\u533A\u5757/\u69FD\u4F4D/\u5360\u4F4D\u7B26\u6821\u9A8C\u5931\u8D25\uFF09",
    category: "CONFIG",
    retryable: false,
    fixSuggestion: "\u8BF7\u68C0\u67E5\u6A21\u677F\u533A\u5757\u7ED3\u6784\u3001\u69FD\u4F4D\u6620\u5C04\u4E0E\u5360\u4F4D\u7B26\u662F\u5426\u4E00\u81F4\u3002"
  },
  // E5xx 内部错误（不可重试）
  E500_INTERNAL_ERROR: {
    code: "E500_INTERNAL_ERROR",
    name: "INTERNAL_ERROR",
    description: "\u5185\u90E8\u7A0B\u5E8F\u9519\u8BEF\u6216\u672A\u9884\u671F\u5F02\u5E38",
    category: "INTERNAL",
    retryable: false,
    fixSuggestion: "\u8BF7\u91CD\u8BD5\u6216\u91CD\u542F\u63D2\u4EF6\uFF0C\u5982\u6301\u7EED\u51FA\u73B0\u8BF7\u53CD\u9988\u65E5\u5FD7\u3002"
  }
};
function isValidErrorCode(code) {
  return code in ERROR_CODE_INFO;
}
function getErrorCodeInfo(code) {
  if (!isValidErrorCode(code)) {
    return void 0;
  }
  return ERROR_CODE_INFO[code];
}
function getErrorCategory(code) {
  return getErrorCodeInfo(code)?.category ?? "UNKNOWN";
}
function isRetryableErrorCode(code) {
  return getErrorCodeInfo(code)?.retryable ?? false;
}
function getFixSuggestion(code) {
  return getErrorCodeInfo(code)?.fixSuggestion;
}
var ErrorRegistry = class {
  definitions = /* @__PURE__ */ new Map();
  /**
   * 注册一个错误码定义。若已存在则覆盖。
   */
  register(def) {
    this.definitions.set(def.code, def);
  }
  /**
   * 批量注册错误码定义。
   */
  registerAll(defs) {
    for (const def of defs) {
      this.register(def);
    }
  }
  /**
   * 获取错误码定义，不存在时返回 undefined。
   */
  get(code) {
    return this.definitions.get(code);
  }
  /**
   * 判断错误码是否可重试。未注册的错误码返回 false。
   */
  isRetryable(code) {
    return this.definitions.get(code)?.retryable ?? false;
  }
  /**
   * 格式化错误消息：将 description 模板中的 `{param}` 占位符替换为 params 中的实际值。
   * - 未提供 params 或 params 中缺少对应 key 时，该占位符替换为空字符串
   * - 确保输出不含未解析的 `{param}` 占位符
   * - 错误码未注册时返回 "Unknown error: <code>"
   */
  formatMessage(code, params) {
    const def = this.definitions.get(code);
    if (!def) {
      return `Unknown error: ${code}`;
    }
    let message = def.description;
    if (params) {
      for (const [key2, value] of Object.entries(params)) {
        message = message.replaceAll(`{${key2}}`, value);
      }
    }
    message = message.replace(/\{[a-zA-Z_][a-zA-Z0-9_]*\}/g, "");
    return message;
  }
  /**
   * 获取所有已注册的错误码列表。
   */
  getAllCodes() {
    return Array.from(this.definitions.keys());
  }
  /**
   * 获取已注册错误码数量。
   */
  get size() {
    return this.definitions.size;
  }
};
function createDefaultErrorRegistry() {
  const registry = new ErrorRegistry();
  for (const def of Object.values(ERROR_CODE_INFO)) {
    registry.register(def);
  }
  return registry;
}
var defaultErrorRegistry = createDefaultErrorRegistry();

// src/data/logger.ts
var LOG_LEVEL_PRIORITY = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3
};
var DEFAULT_EVENTS = {
  debug: "DEBUG",
  info: "INFO",
  warn: "WARNING",
  error: "ERROR"
};
function formatShortTime(isoString) {
  const date = new Date(isoString);
  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");
  const seconds = date.getSeconds().toString().padStart(2, "0");
  const ms = date.getMilliseconds().toString().padStart(3, "0");
  return `${hours}:${minutes}:${seconds}.${ms}`;
}
function formatDateTime(isoString) {
  const date = new Date(isoString);
  const month = (date.getMonth() + 1).toString().padStart(2, "0");
  const day = date.getDate().toString().padStart(2, "0");
  const hours = date.getHours().toString().padStart(2, "0");
  const minutes = date.getMinutes().toString().padStart(2, "0");
  const seconds = date.getSeconds().toString().padStart(2, "0");
  return `${month}-${day} ${hours}:${minutes}:${seconds}`;
}
var SENSITIVE_KEYS = ["apikey", "token", "secret", "authorization", "password", "api_key"];
function sanitizeContext(context) {
  const sanitized = {};
  for (const [key2, value] of Object.entries(context)) {
    if (SENSITIVE_KEYS.some((sk) => key2.toLowerCase().includes(sk))) {
      sanitized[key2] = "[REDACTED]";
    } else if (Array.isArray(value)) {
      sanitized[key2] = value.map(
        (item) => typeof item === "object" && item !== null ? sanitizeContext(item) : item
      );
    } else if (typeof value === "object" && value !== null) {
      sanitized[key2] = sanitizeContext(value);
    } else {
      sanitized[key2] = value;
    }
  }
  return sanitized;
}
function sanitizeStack(stack2) {
  let result = stack2;
  for (const sk of SENSITIVE_KEYS) {
    const patterns = [
      new RegExp(`(${sk})\\s*[=:]\\s*["']?[^\\s"',}\\]]+["']?`, "gi"),
      new RegExp(`(${sk})\\s*[=:]\\s*"[^"]*"`, "gi")
    ];
    for (const pattern of patterns) {
      result = result.replace(pattern, `$1=[REDACTED]`);
    }
  }
  return result;
}
var Logger = class _Logger {
  logBuffer = [];
  maxLogSize;
  currentSize = 0;
  logFilePath;
  fileStorage;
  minLevel;
  initialized = false;
  consoleEnabled = true;
  sessionId;
  currentTraceId = null;
  groupStack = [];
  constructor(logFilePath, fileStorage, minLevel = "info", maxLogSize = 1024 * 1024) {
    this.logFilePath = logFilePath;
    this.fileStorage = fileStorage;
    this.minLevel = minLevel;
    this.maxLogSize = maxLogSize;
    this.sessionId = this.generateSessionId();
  }
  /** 生成会话 ID */
  generateSessionId() {
    const now2 = /* @__PURE__ */ new Date();
    const dateStr = now2.toISOString().slice(0, 10).replace(/-/g, "");
    const timeStr = now2.toISOString().slice(11, 19).replace(/:/g, "");
    const random = Math.random().toString(36).slice(2, 6);
    return `${dateStr}-${timeStr}-${random}`;
  }
  /** 生成追踪 ID */
  generateTraceId() {
    const timestamp2 = Date.now().toString(36);
    const random = Math.random().toString(36).slice(2, 8);
    return `${timestamp2}-${random}`;
  }
  /** 设置当前追踪 ID（用于关联同一操作的多条日志） */
  setTraceId(traceId) {
    this.currentTraceId = traceId;
  }
  /** 获取当前追踪 ID */
  getTraceId() {
    return this.currentTraceId;
  }
  /** 开始一个带追踪 ID 的操作 */
  startTrace(operation) {
    const traceId = this.generateTraceId();
    this.currentTraceId = traceId;
    this.debug("Trace", `\u5F00\u59CB\u8FFD\u8E2A: ${operation}`, { event: "TRACE_START", operation });
    return traceId;
  }
  /** 结束当前追踪 */
  endTrace(operation) {
    if (this.currentTraceId) {
      this.debug("Trace", `\u7ED3\u675F\u8FFD\u8E2A: ${operation}`, { event: "TRACE_END", operation });
      this.currentTraceId = null;
    }
  }
  /** 初始化 Logger */
  async initialize() {
    if (this.initialized) return;
    try {
      let fileExists = false;
      if (this.fileStorage.exists) {
        fileExists = await this.fileStorage.exists(this.logFilePath);
      } else {
        try {
          await this.fileStorage.read(this.logFilePath);
          fileExists = true;
        } catch {
          fileExists = false;
        }
      }
      if (fileExists) {
        const existingContent = await this.fileStorage.read(this.logFilePath);
        if (existingContent) {
          const lines = existingContent.split("\n").filter((line) => line.trim());
          this.logBuffer = lines;
          this.currentSize = new TextEncoder().encode(existingContent).length;
          if (this.currentSize > this.maxLogSize) {
            this.rotateLog(0);
          }
        }
      }
      this.initialized = true;
      this.logSessionStart();
    } catch (error) {
      console.error("Logger initialization failed:", error);
      this.initialized = true;
    }
  }
  /** 记录会话开始 */
  logSessionStart() {
    const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
    const startEntry = {
      timestamp: timestamp2,
      level: "info",
      module: "Session",
      event: "SESSION_START",
      message: `\u65B0\u4F1A\u8BDD\u5F00\u59CB [${this.sessionId}]`,
      context: {
        sessionId: this.sessionId,
        separator: true
      }
    };
    const logLine = this.formatLogEntry(startEntry);
    this.logBuffer.push(logLine);
    this.currentSize += new TextEncoder().encode(logLine + "\n").length;
    this.writeToFile().catch((err2) => {
      console.error("Failed to write session start:", err2);
    });
  }
  /** 开始日志分组 */
  startGroup(groupName) {
    this.groupStack.push(groupName);
    this.debug("Group", `\u250C\u2500 ${groupName}`, { event: "GROUP_START", groupName });
  }
  /** 结束日志分组 */
  endGroup() {
    const groupName = this.groupStack.pop();
    if (groupName) {
      this.debug("Group", `\u2514\u2500 ${groupName} \u5B8C\u6210`, { event: "GROUP_END", groupName });
    }
  }
  /** 记录带耗时的操作 */
  async withTiming(module2, operation, fn) {
    const startTime = Date.now();
    try {
      const result = await fn();
      const duration = Date.now() - startTime;
      this.info(module2, `${operation} \u5B8C\u6210 (${duration}ms)`, {
        event: "TIMING",
        operation,
        durationMs: duration
      });
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      this.error(module2, `${operation} \u5931\u8D25 (${duration}ms)`, error, {
        event: "TIMING_ERROR",
        operation,
        durationMs: duration
      });
      throw error;
    }
  }
  /** 记录耗时指标 */
  timing(module2, operation, durationMs, context) {
    this.info(module2, `${operation} (${durationMs}ms)`, {
      event: "TIMING",
      operation,
      durationMs,
      ...context
    });
  }
  /** 调试日志 */
  debug(module2, message, context) {
    this.log("debug", module2, message, void 0, context);
  }
  /** 信息日志 */
  info(module2, message, context) {
    this.log("info", module2, message, void 0, context);
  }
  /** 警告日志 */
  warn(module2, message, context) {
    this.log("warn", module2, message, void 0, context);
  }
  /** 错误日志 */
  error(module2, message, error, context) {
    this.log("error", module2, message, error, context);
  }
  /** 带错误码的错误日志 */
  errorWithCode(module2, errorCode, message, error, context) {
    const codeInfo = isValidErrorCode(errorCode) ? getErrorCodeInfo(errorCode) : void 0;
    const enrichedContext = {
      ...context,
      errorCode,
      event: context?.event || "ERROR"
    };
    if (codeInfo) {
      enrichedContext.errorCodeName = codeInfo.name;
      enrichedContext.errorCategory = codeInfo.category;
      enrichedContext.retryable = codeInfo.retryable;
    }
    this.logWithErrorCode("error", module2, message, errorCode, error, enrichedContext);
  }
  /** 获取日志内容 */
  getLogContent() {
    return this.logBuffer.join("\n");
  }
  /** 清空日志 */
  clear() {
    this.logBuffer = [];
    this.currentSize = 0;
  }
  /** 获取当前日志大小（字节） */
  getCurrentSize() {
    return this.currentSize;
  }
  /** 获取最大日志大小（字节） */
  getMaxLogSize() {
    return this.maxLogSize;
  }
  /** 获取日志条目数量 */
  getEntryCount() {
    return this.logBuffer.length;
  }
  /** 设置最小日志级别 */
  setMinLevel(level) {
    this.minLevel = level;
  }
  /** 设置日志级别 */
  setLogLevel(level) {
    this.minLevel = level;
  }
  /** 获取当前日志级别 */
  getLogLevel() {
    return this.minLevel;
  }
  /** 设置是否启用控制台输出 */
  setConsoleEnabled(enabled) {
    this.consoleEnabled = enabled;
  }
  /** 获取控制台输出是否启用 */
  isConsoleEnabled() {
    return this.consoleEnabled;
  }
  /** 获取会话 ID */
  getSessionId() {
    return this.sessionId;
  }
  /** 核心日志方法 */
  log(level, module2, message, error, context) {
    if (!this.shouldLog(level)) {
      return;
    }
    const event2 = context?.event || DEFAULT_EVENTS[level];
    let cleanContext;
    if (context) {
      const { event: _, ...rest } = context;
      cleanContext = Object.keys(rest).length > 0 ? rest : void 0;
    }
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      module: module2,
      event: event2,
      message
    };
    if (this.currentTraceId) {
      entry.traceId = this.currentTraceId;
    }
    if (cleanContext && Object.keys(cleanContext).length > 0) {
      entry.context = sanitizeContext(cleanContext);
    }
    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack ? sanitizeStack(error.stack) : void 0
      };
    }
    const logLine = this.formatLogEntry(entry);
    const logLineSize = new TextEncoder().encode(logLine + "\n").length;
    if (this.currentSize + logLineSize > this.maxLogSize) {
      this.rotateLog(logLineSize);
    }
    this.logBuffer.push(logLine);
    this.currentSize += logLineSize;
    this.outputToConsole(entry);
    this.writeToFile().catch((err2) => {
      console.error("Failed to write log to file:", err2);
    });
  }
  /** 带错误码的日志方法 */
  logWithErrorCode(level, module2, message, errorCode, error, context) {
    if (!this.shouldLog(level)) {
      return;
    }
    const event2 = context?.event || DEFAULT_EVENTS[level];
    let cleanContext;
    if (context) {
      const {
        event: _,
        errorCode: __,
        errorCodeName: ___,
        errorCategory: ____,
        retryable: _____,
        ...rest
      } = context;
      cleanContext = Object.keys(rest).length > 0 ? rest : void 0;
    }
    const codeInfo = isValidErrorCode(errorCode) ? getErrorCodeInfo(errorCode) : void 0;
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      module: module2,
      event: event2,
      message
    };
    if (this.currentTraceId) {
      entry.traceId = this.currentTraceId;
    }
    if (cleanContext && Object.keys(cleanContext).length > 0) {
      entry.context = sanitizeContext(cleanContext);
    }
    entry.error = {
      name: error?.name || codeInfo?.name || "Error",
      message: error?.message || message,
      stack: error?.stack ? sanitizeStack(error.stack) : void 0,
      code: errorCode,
      codeName: codeInfo?.name,
      fixSuggestion: codeInfo?.fixSuggestion
    };
    const logLine = this.formatLogEntry(entry);
    const logLineSize = new TextEncoder().encode(logLine + "\n").length;
    if (this.currentSize + logLineSize > this.maxLogSize) {
      this.rotateLog(logLineSize);
    }
    this.logBuffer.push(logLine);
    this.currentSize += logLineSize;
    this.outputToConsole(entry);
    this.writeToFile().catch((err2) => {
      console.error("Failed to write log to file:", err2);
    });
  }
  /** 检查日志级别 */
  shouldLog(level) {
    return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[this.minLevel];
  }
  /** 格式化日志（统一为 JSON Lines） */
  formatLogEntry(entry) {
    return JSON.stringify(entry);
  }
  /** 格式化上下文 */
  formatContext(context) {
    const parts = [];
    for (const [key2, value] of Object.entries(context)) {
      if (value === void 0 || value === null) continue;
      if (key2 === "separator") continue;
      let valueStr;
      if (typeof value === "string") {
        valueStr = value.length > 30 ? value.slice(0, 30) + "..." : value;
      } else if (typeof value === "number") {
        valueStr = String(value);
      } else if (typeof value === "boolean") {
        valueStr = String(value);
      } else {
        valueStr = JSON.stringify(value);
        if (valueStr.length > 50) {
          valueStr = valueStr.slice(0, 50) + "...";
        }
      }
      parts.push(`${key2}=${valueStr}`);
    }
    return parts.length > 0 ? `{${parts.join(", ")}}` : "";
  }
  /** 解析日志行 */
  static parseLogEntry(logLine) {
    try {
      if (logLine.startsWith("{")) {
        const parsed = JSON.parse(logLine);
        if (typeof parsed.timestamp === "string" && typeof parsed.level === "string" && typeof parsed.module === "string" && typeof parsed.event === "string" && typeof parsed.message === "string") {
          return parsed;
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  /** 循环日志 */
  rotateLog(newEntrySize) {
    const targetSize = this.maxLogSize - newEntrySize;
    while (this.logBuffer.length > 0 && this.currentSize > targetSize) {
      const removedLine = this.logBuffer.shift();
      if (removedLine) {
        const removedSize = new TextEncoder().encode(removedLine + "\n").length;
        this.currentSize -= removedSize;
      }
    }
  }
  /** 写入文件 */
  async writeToFile() {
    try {
      const content = this.getLogContent();
      await this.fileStorage.write(this.logFilePath, content);
    } catch (error) {
      console.error("Failed to write log file:", error);
    }
  }
  /** 输出到控制台 */
  outputToConsole(entry) {
    if (!this.consoleEnabled) {
      return;
    }
    const formattedMsg = this.formatConsoleOutput(entry);
    switch (entry.level) {
      case "debug":
        console.debug(formattedMsg);
        break;
      case "info":
        console.info(formattedMsg);
        break;
      case "warn":
        console.warn(formattedMsg);
        break;
      case "error":
        if (entry.error?.stack) {
          console.error(formattedMsg, "\n", entry.error.stack);
        } else {
          console.error(formattedMsg);
        }
        break;
    }
  }
  /** 格式化控制台 */
  formatConsoleOutput(entry) {
    const time = formatShortTime(entry.timestamp);
    const prefix = `[CR][${entry.level.toUpperCase()}]`;
    const traceStr = entry.traceId ? ` [${entry.traceId.slice(-6)}]` : "";
    let msg = `${time} ${prefix}[${entry.module}]${traceStr} ${entry.message}`;
    if (entry.context && Object.keys(entry.context).length > 0) {
      const contextStr = this.formatContext(entry.context);
      if (contextStr) {
        msg += ` ${contextStr}`;
      }
    }
    if (entry.error && entry.level === "error") {
      msg += `
  \u2514\u2500 ${entry.error.code || ""} ${entry.error.message}`;
      if (entry.error.fixSuggestion) {
        msg += `
     \u{1F4A1} ${entry.error.fixSuggestion}`;
      }
    }
    return msg;
  }
  // 日志查询和过滤
  /** 按级别过滤 */
  filterByLevel(level) {
    const entries = [];
    const minPriority = LOG_LEVEL_PRIORITY[level];
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry && LOG_LEVEL_PRIORITY[entry.level] >= minPriority) {
        entries.push(entry);
      }
    }
    return entries;
  }
  /** 按模块过滤日志 */
  filterByModule(module2) {
    const entries = [];
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry && entry.module === module2) {
        entries.push(entry);
      }
    }
    return entries;
  }
  /** 按追踪 ID 过滤日志 */
  filterByTraceId(traceId) {
    const entries = [];
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry && entry.traceId === traceId) {
        entries.push(entry);
      }
    }
    return entries;
  }
  /** 按事件类型过滤日志 */
  filterByEvent(event2) {
    const entries = [];
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry && entry.event === event2) {
        entries.push(entry);
      }
    }
    return entries;
  }
  /** 按时间范围过滤日志 */
  filterByTimeRange(startTime, endTime) {
    const entries = [];
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry) {
        const entryTime = new Date(entry.timestamp);
        if (entryTime >= startTime && entryTime <= endTime) {
          entries.push(entry);
        }
      }
    }
    return entries;
  }
  /** 搜索日志消息 */
  search(keyword) {
    const entries = [];
    const lowerKeyword = keyword.toLowerCase();
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry) {
        const searchText = `${entry.module} ${entry.message} ${entry.event}`.toLowerCase();
        if (searchText.includes(lowerKeyword)) {
          entries.push(entry);
        }
      }
    }
    return entries;
  }
  /** 获取最近 N 条日志 */
  getRecentEntries(count) {
    const entries = [];
    const startIndex = Math.max(0, this.logBuffer.length - count);
    for (let i = startIndex; i < this.logBuffer.length; i++) {
      const entry = _Logger.parseLogEntry(this.logBuffer[i]);
      if (entry) {
        entries.push(entry);
      }
    }
    return entries;
  }
  /** 获取错误摘要 */
  getErrorSummary() {
    const summary = {
      count: 0,
      byModule: {},
      byCode: {}
    };
    for (const line of this.logBuffer) {
      const entry = _Logger.parseLogEntry(line);
      if (entry && entry.level === "error") {
        summary.count++;
        summary.byModule[entry.module] = (summary.byModule[entry.module] || 0) + 1;
        if (entry.error?.code) {
          summary.byCode[entry.error.code] = (summary.byCode[entry.error.code] || 0) + 1;
        }
      }
    }
    return summary;
  }
  /** 导出日志（JSON Lines） */
  exportAsJsonLines() {
    return this.getLogContent();
  }
};

// src/data/validator.ts
var Validator = class {
  /** 验证输出 */
  async validate(output, schema4, _rules, _context) {
    const parseResult = this.tryParseJson(output);
    if (!parseResult.ok) {
      return { valid: false, errors: [parseResult.error] };
    }
    const data = parseResult.data;
    const schemaErrors = this.validateSchema(data, schema4);
    if (schemaErrors.length > 0) {
      return { valid: false, errors: schemaErrors };
    }
    const requiredFieldErrors = this.validateRequiredFields(data, schema4);
    if (requiredFieldErrors.length > 0) {
      return { valid: false, errors: requiredFieldErrors };
    }
    return {
      valid: true,
      data
    };
  }
  /** 容错 JSON 解析 */
  tryParseJson(output) {
    const trimmed = output.trim();
    const buildParseError = () => ({
      code: "E210_MODEL_OUTPUT_PARSE_FAILED",
      type: "ParseError",
      message: "\u6A21\u578B\u8F93\u51FA\u975E JSON \u6216\u89E3\u6790\u5931\u8D25",
      rawOutput: trimmed.substring(0, 500),
      fixInstruction: "\u786E\u4FDD\u8F93\u51FA\u4E3A\u7EAF JSON\uFF0C\u7981\u6B62\u4F7F\u7528\u4EE3\u7801\u5757\u6216\u989D\u5916\u6587\u672C"
    });
    try {
      return { ok: true, data: JSON.parse(trimmed) };
    } catch {
      return { ok: false, error: buildParseError() };
    }
  }
  /** Schema 校验 */
  validateSchema(data, schema4) {
    const errors = [];
    const schemaProps = schema4.properties;
    if (!schemaProps) {
      return errors;
    }
    for (const [key2, propSchema] of Object.entries(schemaProps)) {
      const value = data[key2];
      const expectedType = propSchema.type;
      if (value === void 0 || value === null) {
        continue;
      }
      const actualType = Array.isArray(value) ? "array" : typeof value;
      if (expectedType === "array" && !Array.isArray(value)) {
        errors.push({
          code: "E211_MODEL_SCHEMA_VIOLATION",
          type: "SchemaError",
          message: `\u5B57\u6BB5 "${key2}" \u5E94\u4E3A\u6570\u7EC4`,
          location: key2,
          fixInstruction: `\u8BF7\u5C06 "${key2}" \u8F93\u51FA\u4E3A\u6570\u7EC4`
        });
      } else if (expectedType === "object" && (typeof value !== "object" || Array.isArray(value))) {
        errors.push({
          code: "E211_MODEL_SCHEMA_VIOLATION",
          type: "SchemaError",
          message: `\u5B57\u6BB5 "${key2}" \u5E94\u4E3A\u5BF9\u8C61`,
          location: key2,
          fixInstruction: `\u8BF7\u5C06 "${key2}" \u8F93\u51FA\u4E3A\u5BF9\u8C61`
        });
      } else if (expectedType !== "array" && expectedType !== "object" && expectedType !== actualType) {
        errors.push({
          code: "E211_MODEL_SCHEMA_VIOLATION",
          type: "SchemaError",
          message: `\u5B57\u6BB5 "${key2}" \u7C7B\u578B\u5E94\u4E3A "${expectedType}"\uFF0C\u5B9E\u9645\u4E3A "${actualType}"`,
          location: key2,
          fixInstruction: `\u8BF7\u5C06 "${key2}" \u8F93\u51FA\u4E3A "${expectedType}" \u7C7B\u578B`
        });
      }
    }
    return errors;
  }
  /** 必填字段检查 */
  validateRequiredFields(data, schema4) {
    const errors = [];
    const required = schema4.required;
    if (!required) {
      return errors;
    }
    for (const field of required) {
      const value = data[field];
      if (value === void 0 || value === null) {
        errors.push({
          code: "E211_MODEL_SCHEMA_VIOLATION",
          type: "MissingField",
          message: `\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5 "${field}"`,
          location: field,
          fixInstruction: `\u8BF7\u8865\u5168 "${field}" \u5B57\u6BB5`
        });
      } else if (typeof value === "string" && value.trim() === "") {
        errors.push({
          code: "E211_MODEL_SCHEMA_VIOLATION",
          type: "MissingField",
          message: `\u5FC5\u586B\u5B57\u6BB5 "${field}" \u4E3A\u7A7A`,
          location: field,
          fixInstruction: `\u8BF7\u4E3A "${field}" \u63D0\u4F9B\u975E\u7A7A\u503C`
        });
      }
    }
    return errors;
  }
};

// src/locales/zh.json
var zh_default = {
  common: {
    confirm: "\u786E\u8BA4",
    cancel: "\u53D6\u6D88",
    save: "\u4FDD\u5B58",
    delete: "\u5220\u9664",
    edit: "\u7F16\u8F91",
    add: "\u6DFB\u52A0",
    close: "\u5173\u95ED",
    loading: "\u52A0\u8F7D\u4E2D...",
    success: "\u6210\u529F",
    error: "\u9519\u8BEF",
    warning: "\u8B66\u544A"
  },
  commands: {
    openWorkbench: "\u6253\u5F00\u5DE5\u4F5C\u53F0",
    createConcept: "\u521B\u5EFA\u6982\u5FF5",
    improveNote: "\u6539\u8FDB\u7B14\u8BB0",
    expandNote: "\u62D3\u5C55\u5F53\u524D\u7B14\u8BB0",
    mergeDuplicates: "\u5408\u5E76\u91CD\u590D\u5BF9"
  },
  workbench: {
    title: "\u5DE5\u4F5C\u53F0",
    buttons: {
      improveNote: "\u6539\u8FDB\u5F53\u524D\u7B14\u8BB0",
      expand: "\u62D3\u5C55\u5F53\u524D\u7B14\u8BB0",
      insertImage: "\u63D2\u5165\u56FE\u7247",
      verify: "\u4E8B\u5B9E\u6838\u67E5",
      openNoteHint: "\u6253\u5F00\u4E00\u7BC7 Markdown \u7B14\u8BB0\u4EE5\u4F7F\u7528\u6539\u8FDB\u3001\u62D3\u5C55\u7B49\u5DE5\u5177"
    },
    createConcept: {
      title: "\u521B\u5EFA\u6982\u5FF5",
      placeholder: "\u8F93\u5165\u6982\u5FF5\u63CF\u8FF0...",
      startButton: "\u5F00\u59CB",
      defining: "\u5B9A\u4E49\u4E2D...",
      selectType: "\u8BF7\u9009\u62E9\u6982\u5FF5\u7C7B\u578B",
      create: "\u521B\u5EFA",
      clear: "\u6E05\u7A7A\u8F93\u5165"
    },
    amendModal: {
      title: "\u4FEE\u8BA2\u7B14\u8BB0",
      placeholder: "\u8BF7\u8F93\u5165\u4FEE\u8BA2\u6307\u4EE4\uFF08\u4F8B\u5982\uFF1A\u8865\u5145\u66F4\u591A\u793A\u4F8B\u3001\u4F18\u5316\u5B9A\u4E49\u3001\u6DFB\u52A0\u76F8\u5173\u7406\u8BBA\uFF09"
    },
    duplicates: {
      title: "\u91CD\u590D\u6982\u5FF5",
      empty: "\u6682\u65E0\u91CD\u590D\u6982\u5FF5",
      dismiss: "\u5FFD\u7565",
      compare: "\u5BF9\u6BD4",
      compareAria: "\u5BF9\u6BD4\u5408\u5E76",
      dismissAria: "\u5FFD\u7565\u6B64\u91CD\u590D\u5BF9"
    },
    queueStatus: {
      title: "\u961F\u5217\u72B6\u6001",
      active: "\u8FD0\u884C\u4E2D",
      paused: "\u5DF2\u6682\u505C",
      pending: "\u5F85\u5904\u7406",
      running: "\u6267\u884C\u4E2D",
      failed: "\u5931\u8D25",
      clearPending: "\u6E05\u9664\u5F85\u5904\u7406",
      retryFailed: "\u91CD\u8BD5\u5931\u8D25",
      pauseQueue: "\u6682\u505C\u961F\u5217",
      resumeQueue: "\u6062\u590D\u961F\u5217",
      queueResumed: "\u961F\u5217\u5DF2\u6062\u590D\u8FD0\u884C",
      cancel: "\u53D6\u6D88",
      noTasks: "\u961F\u5217\u4E2D\u6682\u65E0\u4EFB\u52A1",
      clearPendingConfirmTitle: "\u786E\u8BA4\u6E05\u7A7A\u5F85\u5904\u7406",
      clearPendingConfirmMessage: "\u662F\u5426\u53D6\u6D88\u6240\u6709\u5F85\u5904\u7406\u4EFB\u52A1\uFF1F"
    },
    recentOps: {
      title: "\u64CD\u4F5C\u5386\u53F2",
      empty: "\u6682\u65E0\u53EF\u64A4\u9500\u7684\u64CD\u4F5C",
      undo: "\u64A4\u9500",
      view: "\u67E5\u770B",
      viewAria: "\u67E5\u770B\u5FEB\u7167",
      undoAria: "\u64A4\u9500\u6B64\u64CD\u4F5C",
      clearAll: "\u6E05\u7A7A\u5168\u90E8",
      clearAllConfirmTitle: "\u786E\u8BA4\u6E05\u7A7A",
      clearAllConfirmMessage: "\u786E\u5B9A\u8981\u6E05\u7A7A\u6240\u6709\u5FEB\u7167\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002",
      moreSnapshots: "\u8FD8\u6709 {count} \u4E2A\u66F4\u65E9\u7684\u5FEB\u7167",
      viewSnapshotFailed: "\u8BFB\u53D6\u5FEB\u7167\u5931\u8D25",
      undoFailed: "\u6062\u590D\u5931\u8D25",
      timeJustNow: "\u521A\u521A",
      timeMinutesAgo: "{minutes} \u5206\u949F\u524D",
      timeHoursAgo: "{hours} \u5C0F\u65F6\u524D",
      timeDaysAgo: "{days} \u5929\u524D",
      operationLabels: {
        enrich: "\u6807\u8BB0",
        merge: "\u5408\u5E76",
        amend: "\u4FEE\u8BA2",
        manualEdit: "\u624B\u52A8\u7F16\u8F91",
        standardize: "\u5B9A\u4E49",
        create: "\u521B\u5EFA\u7B14\u8BB0",
        fallback: "\u64CD\u4F5C"
      }
    },
    notifications: {
      systemNotInitialized: "\u7CFB\u7EDF\u672A\u521D\u59CB\u5316",
      enterDescription: "\u8BF7\u8F93\u5165\u6982\u5FF5\u63CF\u8FF0",
      standardizeFailed: "\u5B9A\u4E49\u5931\u8D25",
      standardizeComplete: "\u5B9A\u4E49\u5B8C\u6210\uFF0C\u8BF7\u9009\u62E9\u7C7B\u578B",
      pluginNotInitialized: "\u63D2\u4EF6\u672A\u521D\u59CB\u5316",
      openMarkdownFirst: "\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u7B14\u8BB0",
      createFailed: "\u521B\u5EFA\u5931\u8D25",
      conceptCreated: "\u6982\u5FF5\u521B\u5EFA\u5DF2\u542F\u52A8",
      selectDuplicates: "\u8BF7\u5148\u9009\u62E9\u8981\u5408\u5E76\u7684\u91CD\u590D\u5BF9",
      batchMergeConfirm: "\u786E\u5B9A\u8981\u5408\u5E76\u9009\u4E2D\u7684\u91CD\u590D\u5BF9\u5417\uFF1F",
      batchMergeComplete: "\u6279\u91CF\u5408\u5E76\u5B8C\u6210",
      batchDismissConfirm: "\u786E\u5B9A\u8981\u5FFD\u7565\u9009\u4E2D\u7684\u91CD\u590D\u5BF9\u5417\uFF1F",
      batchDismissComplete: "\u6279\u91CF\u5FFD\u7565\u5B8C\u6210",
      fileNotFound: "\u6587\u4EF6\u4E0D\u5B58\u5728",
      previewFailed: "\u663E\u793A\u9884\u89C8\u5931\u8D25",
      mergeTaskCreated: "\u5408\u5E76\u4EFB\u52A1\u5DF2\u521B\u5EFA",
      duplicateManagerNotInitialized: "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316",
      orchestratorNotInitialized: "\u7BA1\u7EBF\u7F16\u6392\u5668\u672A\u521D\u59CB\u5316",
      dismissFailed: "\u5FFD\u7565\u5931\u8D25",
      dismissSuccess: "\u5DF2\u5FFD\u7565\u91CD\u590D\u5BF9",
      queueResumed: "\u961F\u5217\u5DF2\u6062\u590D\u8FD0\u884C",
      queuePaused: "\u961F\u5217\u5DF2\u6682\u505C",
      taskCancelled: "\u4EFB\u52A1\u5DF2\u53D6\u6D88",
      cancelFailed: "\u53D6\u6D88\u5931\u8D25",
      retryComplete: "\u5DF2\u91CD\u8BD5\u5931\u8D25\u4EFB\u52A1",
      clearComplete: "\u5DF2\u6E05\u9664\u4EFB\u52A1",
      undoFailed: "\u64A4\u9500\u5931\u8D25",
      undoSuccess: "\u64A4\u9500\u6210\u529F",
      undoSuccessRestored: "\u64A4\u9500\u6210\u529F\uFF08\u6587\u4EF6\u5DF2\u6062\u590D\uFF09",
      confirmCreateFailed: "\u786E\u8BA4\u521B\u5EFA\u5931\u8D25",
      confirmCreateWaiting: "\u5DF2\u786E\u8BA4\u521B\u5EFA\uFF0C\u7B49\u5F85\u5185\u5BB9\u751F\u6210",
      standardizeUpdated: "\u5DF2\u66F4\u65B0\u5B9A\u4E49\u7ED3\u679C",
      undoDismissSuccess: "\u5DF2\u64A4\u9500\u5FFD\u7565\uFF0C\u91CD\u590D\u5BF9\u5DF2\u6062\u590D\u5230\u5F85\u5904\u7406\u5217\u8868",
      deletePairSuccess: "\u5DF2\u5220\u9664\u91CD\u590D\u5BF9\u8BB0\u5F55",
      writeFailed: "\u5199\u5165\u5931\u8D25",
      writeSuccess: "\u5DF2\u5199\u5165\uFF0C\u652F\u6301\u64A4\u9500",
      writePreviewFailed: "\u65E0\u6CD5\u751F\u6210\u5199\u5165\u9884\u89C8",
      amendCancelled: "\u5DF2\u53D6\u6D88\u4FEE\u8BA2",
      writeCancelled: "\u5DF2\u53D6\u6D88\u5199\u5165",
      amendCompleted: "\u4FEE\u8BA2\u5B8C\u6210",
      mergeCompleted: "\u5408\u5E76\u5B8C\u6210",
      mergeCancelled: "\u5DF2\u53D6\u6D88\u5408\u5E76",
      mergeStarted: "\u5408\u5E76\u4EFB\u52A1\u5DF2\u542F\u52A8\uFF0C\u8BF7\u7B49\u5F85 AI \u751F\u6210\u5408\u5E76\u5185\u5BB9...",
      improveStarted: "\u6539\u8FDB\u4EFB\u52A1\u5DF2\u542F\u52A8\uFF0C\u8BF7\u7B49\u5F85 AI \u751F\u6210\u6539\u8FDB\u5185\u5BB9...",
      verifyStarted: "\u6838\u67E5\u4EFB\u52A1\u5DF2\u542F\u52A8\uFF0C\u8BF7\u7B49\u5F85 AI \u751F\u6210\u6838\u67E5\u62A5\u544A...",
      imageTaskCreated: "\u56FE\u7247\u751F\u6210\u4EFB\u52A1\u5DF2\u521B\u5EFA",
      imageGenerationFailed: "\u56FE\u7247\u751F\u6210\u4EFB\u52A1\u521B\u5EFA\u5931\u8D25",
      featureDisabled: "\u529F\u80FD\u5DF2\u5173\u95ED",
      workbenchNotInitialized: "\u5DE5\u4F5C\u53F0\u672A\u521D\u59CB\u5316\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5",
      startFailed: "\u542F\u52A8\u5931\u8D25: {message}",
      commandFailed: "\u547D\u4EE4\u6267\u884C\u5931\u8D25: {message}",
      noPendingDuplicates: "\u6CA1\u6709\u5F85\u5904\u7406\u7684\u91CD\u590D\u5BF9",
      pendingDuplicatesHint: "\u6709 {count} \u4E2A\u5F85\u5904\u7406\u7684\u91CD\u590D\u5BF9\uFF0C\u8BF7\u5728\u5DE5\u4F5C\u53F0\u4E2D\u9009\u62E9\u8981\u5408\u5E76\u7684\u91CD\u590D\u5BF9",
      improveInstructionRequired: "\u8BF7\u8F93\u5165\u4FEE\u8BA2\u6307\u4EE4",
      conceptLocked: "\u8BE5\u6982\u5FF5\u6B63\u5728\u88AB\u5904\u7406\u4E2D\uFF0C\u8BF7\u7A0D\u540E\u518D\u8BD5",
      clearFailed: "\u6E05\u7A7A\u5931\u8D25",
      compareNoContent: "\u65E0\u6CD5\u8BFB\u53D6\u7B14\u8BB0\u5185\u5BB9",
      compareFailed: "\u6253\u5F00\u5BF9\u6BD4\u5931\u8D25"
    }
  },
  expand: {
    titlePrefix: "\u62D3\u5C55\uFF1A",
    stats: {
      total: "\u5019\u9009\u603B\u6570",
      creatable: "\u53EF\u521B\u5EFA",
      existing: "\u5DF2\u5B58\u5728",
      invalid: "\u4E0D\u53EF\u521B\u5EFA"
    },
    selectAll: "\u5168\u9009",
    deselectAll: "\u5168\u4E0D\u9009",
    confirm: "\u521B\u5EFA\u5DF2\u9009",
    empty: "\u6682\u65E0\u5019\u9009\u9879",
    status: {
      existing: "\u5DF2\u5B58\u5728",
      invalid: "\u4E0D\u53EF\u521B\u5EFA"
    },
    looseStructureHint: "\u672A\u627E\u5230\u6807\u51C6\u7AE0\u8282\uFF0C\u5DF2\u56DE\u9000\u5168\u5C40\u626B\u63CF\uFF0C\u7ED3\u679C\u53EF\u80FD\u4E0D\u5B8C\u6574",
    abstractTitlePrefix: "\u62BD\u8C61\uFF1A",
    abstractInstruction: "\u9009\u62E9\u81F3\u5C11 1 \u4E2A\u76F8\u4F3C\u6982\u5FF5\uFF0C\u4E0E\u5F53\u524D\u7B14\u8BB0\u4E00\u8D77\u751F\u6210\u66F4\u9AD8\u5C42\u6982\u5FF5\u3002",
    abstractConfirm: "\u751F\u6210",
    similarity: "\u76F8\u4F3C\u5EA6",
    notInitialized: "\u62D3\u5C55\u529F\u80FD\u672A\u521D\u59CB\u5316",
    started: "\u5DF2\u542F\u52A8 {count} \u4E2A\u521B\u5EFA\u4EFB\u52A1",
    startedWithFailures: "\u5DF2\u542F\u52A8 {started} \u4E2A\u4EFB\u52A1\uFF0C{failed} \u4E2A\u672A\u80FD\u542F\u52A8"
  },
  settings: {
    title: "Cognitive Razor \u8BBE\u7F6E",
    tabs: {
      general: "\u901A\u7528",
      providers: "AI \u670D\u52A1",
      advanced: "\u9AD8\u7EA7",
      system: "\u7CFB\u7EDF"
    },
    groups: {
      interface: "\u754C\u9762",
      languageDisplay: "\u8BED\u8A00\u4E0E\u663E\u793A",
      knowledgeStorage: "\u77E5\u8BC6\u5B58\u50A8",
      automation: "\u81EA\u52A8\u5316",
      deduplication: "\u53BB\u91CD",
      performance: "\u6027\u80FD",
      directory: "\u76EE\u5F55\u7ED3\u6784",
      typeDirectories: "\u7C7B\u578B\u76EE\u5F55",
      vectorEmbedding: "\u5411\u91CF\u5D4C\u5165",
      taskModels: "\u4EFB\u52A1\u6A21\u578B\u914D\u7F6E",
      snapshots: "\u5FEB\u7167\u4E0E\u64A4\u9500",
      logging: "\u65E5\u5FD7",
      dataManagement: "\u6570\u636E\u7BA1\u7406"
    },
    language: {
      name: "\u8BED\u8A00",
      desc: "\u9009\u62E9\u754C\u9762\u8BED\u8A00",
      zh: "\u4E2D\u6587",
      en: "English"
    },
    similarityThreshold: {
      name: "\u76F8\u4F3C\u5EA6\u9608\u503C",
      desc: "\u7528\u4E8E\u68C0\u6D4B\u91CD\u590D\u6982\u5FF5\u7684\u76F8\u4F3C\u5EA6\u9608\u503C (0-1)"
    },
    maxSnapshots: {
      name: "\u6700\u5927\u5FEB\u7167\u6570\u91CF",
      desc: "\u7528\u4E8E\u64A4\u9500\u64CD\u4F5C\u7684\u6700\u5927\u5FEB\u7167\u6570\u91CF"
    },
    maxSnapshotAgeDays: {
      name: "\u5FEB\u7167\u4FDD\u7559\u5929\u6570",
      desc: "\u8D85\u8FC7\u6B64\u5929\u6570\u7684\u5FEB\u7167\u5C06\u88AB\u81EA\u52A8\u6E05\u7406"
    },
    concurrency: {
      name: "\u5E76\u53D1\u4EFB\u52A1\u6570",
      desc: "\u540C\u65F6\u6267\u884C\u7684\u6700\u5927\u4EFB\u52A1\u6570"
    },
    units: {
      days: "\u5929"
    },
    provider: {
      title: "AI Provider \u914D\u7F6E",
      addButton: "\u6DFB\u52A0 Provider",
      addDesc: "\u914D\u7F6E AI \u670D\u52A1\u63D0\u4F9B\u5546\uFF08\u652F\u6301 OpenAI \u6807\u51C6\u683C\u5F0F\uFF0C\u53EF\u901A\u8FC7\u81EA\u5B9A\u4E49\u7AEF\u70B9\u517C\u5BB9\u5176\u4ED6\u670D\u52A1\uFF09",
      noProvider: "\u5C1A\u672A\u914D\u7F6E\u4EFB\u4F55 Provider\u3002\u8BF7\u6DFB\u52A0\u81F3\u5C11\u4E00\u4E2A Provider \u4EE5\u4F7F\u7528\u63D2\u4EF6\u529F\u80FD\u3002",
      addFirstProvider: "\u70B9\u51FB\u4E0A\u65B9\u6309\u94AE\u6DFB\u52A0\u60A8\u7684\u7B2C\u4E00\u4E2A AI Provider",
      defaultProvider: "\u9ED8\u8BA4 Provider",
      defaultProviderDesc: "\u9009\u62E9\u9ED8\u8BA4\u4F7F\u7528\u7684 AI Provider",
      testConnection: "\u6D4B\u8BD5\u8FDE\u63A5",
      setDefault: "\u8BBE\u4E3A\u9ED8\u8BA4",
      status: "\u72B6\u6001",
      enabled: "\u542F\u7528",
      disabled: "\u7981\u7528",
      model: "\u6A21\u578B"
    },
    importExport: {
      title: "\u5BFC\u5165\u5BFC\u51FA",
      export: "\u5BFC\u51FA",
      exportDesc: "\u5BFC\u51FA\u5F53\u524D\u914D\u7F6E\u4E3A JSON \u6587\u4EF6",
      import: "\u5BFC\u5165",
      importDesc: "\u4ECE JSON \u6587\u4EF6\u5BFC\u5165\u914D\u7F6E",
      reset: "\u91CD\u7F6E",
      resetDesc: "\u5C06\u6240\u6709\u8BBE\u7F6E\u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u503C"
    },
    advanced: {
      title: "\u9AD8\u7EA7\u8BBE\u7F6E",
      namingTemplate: {
        name: "\u547D\u540D\u6A21\u677F",
        desc: "\u7B14\u8BB0\u6587\u4EF6\u540D\u6A21\u677F\u3002\u652F\u6301\u7684\u5360\u4F4D\u7B26\uFF1A{{chinese}} (\u4E2D\u6587\u540D), {{english}} (\u82F1\u6587\u540D), {{type}} (\u7C7B\u578B\u82F1\u6587), {{type_cn}} (\u7C7B\u578B\u4E2D\u6587), {{uid}} (\u552F\u4E00\u6807\u8BC6\u7B26)"
      },
      directoryScheme: {
        title: "\u76EE\u5F55\u65B9\u6848",
        desc: "\u4E3A\u6BCF\u79CD\u77E5\u8BC6\u7C7B\u578B\u914D\u7F6E\u5B58\u50A8\u76EE\u5F55"
      },
      taskModels: {
        title: "\u4EFB\u52A1\u6A21\u578B\u914D\u7F6E",
        desc: "\u4E3A\u4E0D\u540C\u4EFB\u52A1\u7C7B\u578B\u914D\u7F6E\u4F7F\u7528\u7684\u6A21\u578B\u548C\u53C2\u6570",
        providerAndModel: "Provider \u548C\u6A21\u578B",
        useDefaultProvider: "\u4F7F\u7528\u9ED8\u8BA4 Provider",
        configureProviderFirst: "\u8BF7\u5148\u914D\u7F6E Provider",
        modelName: "\u6A21\u578B\u540D\u79F0",
        modelNamePlaceholder: "\u6A21\u578B\u540D\u79F0",
        notSet: "\u4E0D\u8BBE\u7F6E",
        low: "\u4F4E",
        medium: "\u4E2D",
        high: "\u9AD8",
        advancedParams: "\u9AD8\u7EA7\u53C2\u6570\u914D\u7F6E"
      },
      temperature: {
        name: "Temperature",
        desc: "\u63A7\u5236\u751F\u6210\u5185\u5BB9\u7684\u968F\u673A\u6027 (0-2)\uFF0C\u8F83\u4F4E\u503C\u66F4\u786E\u5B9A\uFF0C\u8F83\u9AD8\u503C\u66F4\u521B\u610F"
      },
      topP: {
        name: "Top P",
        desc: "\u6838\u91C7\u6837\u53C2\u6570 (0-1)\uFF0C\u63A7\u5236\u751F\u6210\u5185\u5BB9\u7684\u591A\u6837\u6027"
      },
      reasoningEffort: {
        name: "Reasoning Effort",
        desc: "\u63A8\u7406\u5F3A\u5EA6\uFF08\u7528\u4E8E\u652F\u6301\u63A8\u7406\u7684\u6A21\u578B\uFF0C\u5982 o1, o3\uFF09"
      },
      embedding: {
        title: "\u5D4C\u5165\u53C2\u6570",
        dimension: "\u5411\u91CF\u7EF4\u5EA6",
        dimensionDesc: "\u5D4C\u5165\u5411\u91CF\u7684\u7EF4\u5EA6\uFF08text-embedding-3-small \u652F\u6301 256-3072\uFF09",
        dimensionWarning: "\u4FEE\u6539\u7EF4\u5EA6\u540E\u9700\u8981\u91CD\u5EFA\u5411\u91CF\u7D22\u5F15\uFF0C\u73B0\u6709\u7684\u5411\u91CF\u6570\u636E\u5C06\u5931\u6548"
      },
      features: {
        title: "\u529F\u80FD\u5F00\u5173",
        enableAutoVerify: "\u542F\u7528\u81EA\u52A8\u6821\u9A8C\uFF08Verify\uFF09",
        enableAutoVerifyDesc: "\u5728\u5199\u5165\u843D\u76D8\u540E\u81EA\u52A8\u6267\u884C Verify\uFF0C\u5E76\u5C06\u62A5\u544A\u8FFD\u52A0\u5230\u7B14\u8BB0\u672B\u5C3E\uFF08\u4F1A\u589E\u52A0\u4E00\u6B21 LLM \u8C03\u7528\uFF09"
      },
      queue: {
        title: "\u961F\u5217\u53C2\u6570",
        autoRetry: "\u81EA\u52A8\u91CD\u8BD5",
        autoRetryDesc: "\u4EFB\u52A1\u5931\u8D25\u65F6\u81EA\u52A8\u91CD\u8BD5",
        maxRetryAttempts: "\u6700\u5927\u91CD\u8BD5\u6B21\u6570",
        maxRetryAttemptsDesc: "\u4EFB\u52A1\u5931\u8D25\u65F6\u7684\u6700\u5927\u91CD\u8BD5\u6B21\u6570",
        taskTimeout: "\u4EFB\u52A1\u8D85\u65F6\u65F6\u95F4",
        taskTimeoutDesc: "\u5355\u4E2A\u4EFB\u52A1\u7684\u6700\u5927\u6267\u884C\u65F6\u957F\uFF08\u6BEB\u79D2\uFF0C\u9ED8\u8BA4 180000 = 3\u5206\u949F\uFF09",
        maxTaskHistory: "\u4EFB\u52A1\u5386\u53F2\u4E0A\u9650",
        maxTaskHistoryDesc: "\u4FDD\u7559\u7684\u5DF2\u5B8C\u6210/\u5931\u8D25/\u53D6\u6D88\u4EFB\u52A1\u6570\u91CF\u4E0A\u9650\uFF08\u9ED8\u8BA4 300\uFF09",
        providerTimeout: "Provider \u8BF7\u6C42\u8D85\u65F6",
        providerTimeoutDesc: "API \u8BF7\u6C42\u7684\u8D85\u65F6\u65F6\u95F4\uFF08\u6BEB\u79D2\uFF0C\u9ED8\u8BA4 1800000 = 30\u5206\u949F\uFF09"
      },
      logging: {
        title: "\u65E5\u5FD7\u8BBE\u7F6E",
        logLevel: "\u65E5\u5FD7\u7EA7\u522B",
        logLevelDesc: "\u8BBE\u7F6E\u65E5\u5FD7\u8BB0\u5F55\u7684\u8BE6\u7EC6\u7A0B\u5EA6",
        clearLogs: "\u6E05\u9664\u65E5\u5FD7",
        clearLogsDesc: "\u6E05\u7A7A\u6240\u6709\u65E5\u5FD7\u6587\u4EF6",
        levels: {
          debug: "\u8C03\u8BD5",
          info: "\u4FE1\u606F",
          warn: "\u8B66\u544A",
          error: "\u9519\u8BEF"
        }
      }
    }
  },
  setupWizard: {
    title: "\u914D\u7F6E AI Provider",
    steps: {
      welcome: "\u6B22\u8FCE",
      provider: "AI \u670D\u52A1",
      directory: "\u76EE\u5F55",
      complete: "\u5B8C\u6210"
    },
    welcome: {
      title: "\u6B22\u8FCE\u4F7F\u7528 Cognitive Razor",
      subtitle: "\u5C06\u60F3\u6CD5\u5FEB\u901F\u8F6C\u5316\u4E3A\u7ED3\u6784\u5316\u6982\u5FF5\uFF0C\u5E76\u6301\u7EED\u6F14\u8FDB\u77E5\u8BC6\u56FE\u8C31\u3002",
      featureDefineTagWrite: "\u5B9A\u4E49 -> \u6807\u6CE8 -> \u5199\u4F5C\uFF1A\u5B8C\u6574\u521B\u5EFA\u7BA1\u7EBF",
      featureMergeAmend: "\u5408\u5E76\u4E0E\u4FEE\u8BA2\uFF1A\u5B89\u5168\u7684 Diff \u786E\u8BA4",
      featureVector: "\u5411\u91CF\u7D22\u5F15\uFF1A\u53BB\u91CD\u4E0E\u76F8\u4F3C\u68C0\u7D22",
      languageName: "\u8BED\u8A00",
      languageDesc: "\u9009\u62E9\u754C\u9762\u8BED\u8A00",
      languageOptionZh: "\u4E2D\u6587",
      languageOptionEn: "English"
    },
    provider: {
      title: "\u914D\u7F6E AI Provider",
      apiKeyHintBeforeLink: "\u4ECE ",
      apiKeyHintAfterLink: " \u83B7\u53D6 API Key",
      apiKeyDesc: "\u672C\u5730\u4FDD\u5B58\uFF0C\u4E0D\u4F1A\u4E0A\u4F20",
      customEndpointName: "\u81EA\u5B9A\u4E49\u7AEF\u70B9",
      customEndpointDesc: "\u7559\u7A7A\u4F7F\u7528 Gemini OpenAI \u517C\u5BB9\u7AEF\u70B9",
      chatModelName: "\u804A\u5929\u6A21\u578B",
      embedModelName: "\u5D4C\u5165\u6A21\u578B"
    },
    directory: {
      title: "\u521D\u59CB\u5316\u76EE\u5F55",
      subtitle: "\u5C06\u4E3A 5 \u4E2A\u6982\u5FF5\u7C7B\u578B\u521B\u5EFA\u76EE\u5F55\u7ED3\u6784\u3002"
    },
    complete: {
      title: "\u914D\u7F6E\u5B8C\u6210",
      subtitle: "Cognitive Razor \u5DF2\u51C6\u5907\u5C31\u7EEA\uFF0C\u6253\u5F00\u5DE5\u4F5C\u53F0\u5F00\u59CB\u4F7F\u7528\u3002"
    },
    actions: {
      getStarted: "\u5F00\u59CB\u914D\u7F6E",
      back: "\u4E0A\u4E00\u6B65",
      saveAndValidate: "\u4FDD\u5B58\u5E76\u6821\u9A8C",
      createAndContinue: "\u521B\u5EFA\u76EE\u5F55\u5E76\u7EE7\u7EED",
      openWorkbench: "\u6253\u5F00\u5DE5\u4F5C\u53F0",
      saving: "\u4FDD\u5B58\u4E2D...",
      creating: "\u521B\u5EFA\u4E2D...",
      skipAndContinue: "\u8DF3\u8FC7\u5E76\u7EE7\u7EED"
    },
    validation: {
      idle: "\u5C1A\u672A\u6821\u9A8C",
      checking: "\u6B63\u5728\u6821\u9A8C\u8FDE\u63A5...",
      ok: "\u8FDE\u63A5\u6B63\u5E38",
      offline: "\u7F51\u7EDC\u4E0D\u53EF\u7528\uFF0C\u53EF\u8DF3\u8FC7\u7EE7\u7EED",
      error: "\u6821\u9A8C\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u914D\u7F6E",
      offlineSaved: "\u7F51\u7EDC\u4E0D\u53EF\u7528\uFF0C\u914D\u7F6E\u5DF2\u4FDD\u5B58\uFF0C\u53EF\u8DF3\u8FC7\u7EE7\u7EED",
      failedWithMessage: "\u6821\u9A8C\u5931\u8D25\uFF1A{message}",
      offlineSavedByError: "\u7F51\u7EDC\u9519\u8BEF\uFF0C\u914D\u7F6E\u5DF2\u4FDD\u5B58\uFF0C\u53EF\u8DF3\u8FC7\u7EE7\u7EED"
    },
    directoryStatus: {
      idle: "\u5C1A\u672A\u521D\u59CB\u5316\u76EE\u5F55",
      creating: "\u6B63\u5728\u521B\u5EFA\u76EE\u5F55...",
      done: "\u76EE\u5F55\u5DF2\u521D\u59CB\u5316",
      error: "\u76EE\u5F55\u521D\u59CB\u5316\u5931\u8D25",
      createFailed: "\u521B\u5EFA\u76EE\u5F55\u5931\u8D25"
    },
    notices: {
      enterApiKey: "\u8BF7\u8F93\u5165 API Key",
      enterProviderId: "\u8BF7\u8F93\u5165 Provider ID",
      invalidEndpointUrl: "\u7AEF\u70B9 URL \u65E0\u6548: {message}",
      saveFailed: "\u4FDD\u5B58\u5931\u8D25: {message}",
      validationSkippedOffline: "\u7F51\u7EDC\u4E0D\u53EF\u7528\uFF0C\u5DF2\u8DF3\u8FC7\u5728\u7EBF\u6821\u9A8C",
      validationSkippedNetworkError: "\u7F51\u7EDC\u9519\u8BEF\uFF0C\u5DF2\u8DF3\u8FC7\u6821\u9A8C",
      saveErrorFallback: "\u4FDD\u5B58\u51FA\u9519",
      saveError: "\u4FDD\u5B58\u51FA\u9519: {message}"
    }
  },
  modals: {
    addProvider: {
      title: "\u6DFB\u52A0 AI Provider"
    },
    editProvider: {
      title: "\u7F16\u8F91 AI Provider"
    },
    providerConfig: {
      description: "\u914D\u7F6E\u517C\u5BB9 OpenAI \u7684 API \u670D\u52A1\uFF08\u5982 Gemini\u3001OpenAI\u3001Azure OpenAI \u7B49\uFF09\u3002",
      sections: {
        basic: "\u57FA\u7840\u914D\u7F6E",
        endpoint: "\u7AEF\u70B9\u914D\u7F6E",
        model: "\u9ED8\u8BA4\u6A21\u578B"
      },
      fields: {
        providerId: "Provider ID",
        providerIdDesc: "\u552F\u4E00\u6807\u8BC6\uFF0C\u4F8B\u5982 my-openai",
        apiKey: "API Key",
        apiKeyDesc: "\u4F60\u7684 API \u5BC6\u94A5",
        endpoint: "API \u7AEF\u70B9",
        endpointDesc: "\u7559\u7A7A\u4F7F\u7528\u9ED8\u8BA4 Gemini \u7AEF\u70B9\u3002",
        chatModel: "\u804A\u5929\u6A21\u578B",
        chatModelDesc: "\u7528\u4E8E\u751F\u6210\u7C7B\u4EFB\u52A1",
        embedModel: "\u5D4C\u5165\u6A21\u578B",
        embedModelDesc: "\u7528\u4E8E\u5411\u91CF\u5D4C\u5165\u4E0E\u8BED\u4E49\u68C0\u7D22"
      },
      showSecret: "\u663E\u793A",
      hideSecret: "\u9690\u85CF",
      errors: {
        providerIdRequired: "\u8BF7\u8F93\u5165 Provider ID",
        apiKeyRequired: "\u8BF7\u8F93\u5165 API Key",
        saveFailed: "\u4FDD\u5B58\u5931\u8D25",
        invalidUrlProtocol: "URL \u5FC5\u987B\u4EE5 http:// \u6216 https:// \u5F00\u5934",
        invalidUrl: "URL \u683C\u5F0F\u65E0\u6548"
      }
    }
  },
  notices: {
    providerAdded: "Provider {id} \u5DF2\u6DFB\u52A0",
    providerUpdated: "Provider {id} \u5DF2\u66F4\u65B0",
    providerDeleted: "Provider {id} \u5DF2\u5220\u9664",
    providerSetDefault: "\u9ED8\u8BA4 Provider \u5DF2\u8BBE\u7F6E\u4E3A: {id}",
    connectionSuccess: "\u8FDE\u63A5\u6210\u529F\uFF01\n\u804A\u5929: {chat}\n\u5D4C\u5165: {embedding}\n\u53EF\u7528\u6A21\u578B: {models} \u4E2A",
    connectionFailed: "\u8FDE\u63A5\u5931\u8D25: {error}",
    settingsExported: "\u914D\u7F6E\u5DF2\u5BFC\u51FA",
    settingsImported: "\u914D\u7F6E\u5DF2\u5BFC\u5165",
    settingsReset: "\u914D\u7F6E\u5DF2\u91CD\u7F6E",
    logsCleared: "\u65E5\u5FD7\u5DF2\u6E05\u9664",
    noLogsToClean: "\u6CA1\u6709\u65E5\u5FD7\u6587\u4EF6\u9700\u8981\u6E05\u9664",
    languageChanged: "\u8BED\u8A00\u5DF2\u5207\u6362\u4E3A: {language}",
    logLevelChanged: "\u65E5\u5FD7\u7EA7\u522B\u5DF2\u8BBE\u7F6E\u4E3A: {level}\uFF08\u5C06\u5728\u4E0B\u6B21\u542F\u52A8\u65F6\u751F\u6548\uFF09",
    groundingEnabled: "\u6821\u9A8C\u5DF2\u542F\u7528",
    groundingDisabled: "\u6821\u9A8C\u5DF2\u7981\u7528",
    networkRestored: "\u7F51\u7EDC\u5DF2\u6062\u590D\uFF0C\u961F\u5217\u53EF\u7EE7\u7EED\u8FD0\u884C",
    networkOffline: "AI \u670D\u52A1\u79BB\u7EBF\uFF0C\u961F\u5217\u5DF2\u6682\u505C"
  },
  confirmDialogs: {
    deleteProvider: {
      title: "\u5220\u9664 Provider",
      message: '\u786E\u5B9A\u8981\u5220\u9664 Provider "{id}" \u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002'
    },
    resetSettings: {
      title: "\u91CD\u7F6E\u8BBE\u7F6E",
      message: "\u786E\u5B9A\u8981\u91CD\u7F6E\u6240\u6709\u8BBE\u7F6E\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002"
    },
    deleteDuplicatePair: {
      title: "\u786E\u8BA4\u5220\u9664",
      message: "\u786E\u5B9A\u8981\u6C38\u4E45\u5220\u9664\u8FD9\u4E2A\u91CD\u590D\u5BF9\u8BB0\u5F55\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002"
    }
  },
  taskTypes: {
    define: { name: "\u5B9A\u4E49", desc: "\u6807\u51C6\u5316\u8F93\u5165\u5E76\u786E\u5B9A\u77E5\u8BC6\u7C7B\u578B" },
    tag: { name: "\u6807\u8BB0", desc: "\u751F\u6210\u522B\u540D\u4E0E\u6807\u7B7E" },
    amend: { name: "\u4FEE\u8BA2", desc: "\u5BF9\u73B0\u6709\u5185\u5BB9\u8FDB\u884C\u589E\u91CF\u4F18\u5316" },
    merge: { name: "\u5408\u5E76", desc: "\u878D\u5408\u8BED\u4E49\u91CD\u590D\u7684\u6982\u5FF5" },
    index: { name: "\u7D22\u5F15", desc: "\u751F\u6210\u8BED\u4E49\u5411\u91CF\u4EE5\u4FBF\u68C0\u7D22" },
    write: { name: "\u64B0\u5199", desc: "\u751F\u6210\u5B8C\u6574\u6B63\u6587\u6216\u5408\u5E76\u5185\u5BB9" },
    verify: { name: "\u6821\u9A8C", desc: "\u9A8C\u8BC1\u751F\u6210\u5185\u5BB9\u7684\u51C6\u786E\u6027" },
    "image-generate": { name: "\u56FE\u50CF\u751F\u6210", desc: "\u751F\u6210\u56FE\u7247\u5E76\u63D2\u5165\u7B14\u8BB0" }
  },
  crTypes: {
    Domain: "\u9886\u57DF",
    Issue: "\u8BAE\u9898",
    Theory: "\u7406\u8BBA",
    Entity: "\u5B9E\u4F53",
    Mechanism: "\u673A\u5236"
  },
  crTypeDirectories: {
    Domain: "\u77E5\u8BC6\u9886\u57DF\u7684\u5B58\u50A8\u76EE\u5F55\u3002\u9ED8\u8BA4: 1-\u9886\u57DF\uFF0C\u652F\u6301\u76F8\u5BF9\u8DEF\u5F84\u5982 CR/1-\u9886\u57DF",
    Issue: "\u95EE\u9898\u8BAE\u9898\u7684\u5B58\u50A8\u76EE\u5F55\u3002\u9ED8\u8BA4: 2-\u8BAE\u9898\uFF0C\u652F\u6301\u76F8\u5BF9\u8DEF\u5F84\u5982 CR/2-\u8BAE\u9898",
    Theory: "\u7406\u8BBA\u5B66\u8BF4\u7684\u5B58\u50A8\u76EE\u5F55\u3002\u9ED8\u8BA4: 3-\u7406\u8BBA\uFF0C\u652F\u6301\u76F8\u5BF9\u8DEF\u5F84\u5982 CR/3-\u7406\u8BBA",
    Entity: "\u5B9E\u4F53\u5BF9\u8C61\u7684\u5B58\u50A8\u76EE\u5F55\u3002\u9ED8\u8BA4: 4-\u5B9E\u4F53\uFF0C\u652F\u6301\u76F8\u5BF9\u8DEF\u5F84\u5982 CR/4-\u5B9E\u4F53",
    Mechanism: "\u673A\u5236\u539F\u7406\u7684\u5B58\u50A8\u76EE\u5F55\u3002\u9ED8\u8BA4: 5-\u673A\u5236\uFF0C\u652F\u6301\u76F8\u5BF9\u8DEF\u5F84\u5982 CR/5-\u673A\u5236"
  },
  taskModels: {
    title: "\u4EFB\u52A1\u6A21\u578B\u914D\u7F6E",
    resetAll: "\u91CD\u7F6E\u5168\u90E8",
    resetAllConfirm: "\u786E\u5B9A\u8981\u5C06\u6240\u6709\u4EFB\u52A1\u914D\u7F6E\u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u503C\u5417\uFF1F\u6B64\u64CD\u4F5C\u4E0D\u53EF\u64A4\u9500\u3002",
    reset: "\u91CD\u7F6E",
    resetConfirm: "\u786E\u5B9A\u8981\u5C06\u6B64\u4EFB\u52A1\u914D\u7F6E\u91CD\u7F6E\u4E3A\u9ED8\u8BA4\u503C\u5417\uFF1F",
    isDefault: "\u9ED8\u8BA4\u503C",
    isCustom: "\u81EA\u5B9A\u4E49",
    recommended: "\u63A8\u8350",
    fields: {
      provider: "Provider",
      providerDesc: "\u9009\u62E9 AI Provider\uFF08\u7559\u7A7A\u5219\u4F7F\u7528\u9ED8\u8BA4 Provider\uFF09",
      useDefaultProvider: "\u4F7F\u7528\u9ED8\u8BA4 Provider",
      model: "\u6A21\u578B\u540D\u79F0",
      modelDesc: "\u6307\u5B9A\u4F7F\u7528\u7684\u6A21\u578B\uFF08\u5982 gemini-3-flash-preview\uFF09",
      temperature: "Temperature",
      temperatureDesc: "\u63A7\u5236\u751F\u6210\u5185\u5BB9\u7684\u968F\u673A\u6027 (0-2)\uFF0C\u8F83\u4F4E\u503C\u66F4\u786E\u5B9A\uFF0C\u8F83\u9AD8\u503C\u66F4\u521B\u610F",
      topP: "Top P",
      topPDesc: "\u6838\u91C7\u6837\u53C2\u6570 (0-1)\uFF0C\u63A7\u5236\u751F\u6210\u5185\u5BB9\u7684\u591A\u6837\u6027",
      maxTokens: "\u6700\u5927\u8F93\u51FA Tokens",
      maxTokensDesc: "\u9650\u5236\u6A21\u578B\u8F93\u51FA token \u4E0A\u9650\uFF08\u7559\u7A7A\u8868\u793A\u4E0D\u9650\u5236\uFF09",
      reasoningEffort: "\u63A8\u7406\u5F3A\u5EA6",
      reasoningEffortDesc: "\u7528\u4E8E\u652F\u6301\u63A8\u7406\u7684\u6A21\u578B\uFF08\u5982 o1, o3\uFF09",
      embeddingDimension: "\u5D4C\u5165\u7EF4\u5EA6",
      embeddingDimensionDesc: "\u5411\u91CF\u5D4C\u5165\u7684\u7EF4\u5EA6\u5927\u5C0F"
    },
    tasks: {
      define: { name: "Define (\u5B9A\u4E49)", desc: "\u5206\u6790\u548C\u5B9A\u4E49\u6982\u5FF5\u7684\u6838\u5FC3\u542B\u4E49" },
      tag: { name: "Tag (\u6807\u8BB0)", desc: "\u6807\u8BB0\u548C\u5206\u7C7B\u6982\u5FF5" },
      write: { name: "Write (\u64B0\u5199)", desc: "\u64B0\u5199\u548C\u6269\u5C55\u6982\u5FF5\u5185\u5BB9" },
      amend: { name: "Amend (\u4FEE\u8BA2)", desc: "\u5BF9\u5DF2\u6709\u6982\u5FF5\u8FDB\u884C\u589E\u91CF\u4F18\u5316" },
      merge: { name: "Merge (\u5408\u5E76)", desc: "\u878D\u5408\u91CD\u590D\u6982\u5FF5\u5E76\u751F\u6210\u5408\u5E76\u5185\u5BB9" },
      index: { name: "Index (\u7D22\u5F15)", desc: "\u751F\u6210\u8BED\u4E49\u5411\u91CF\u5E76\u5EFA\u7ACB\u7D22\u5F15" },
      verify: { name: "Verify (\u6821\u9A8C)", desc: "\u9A8C\u8BC1\u548C\u68C0\u67E5\u6982\u5FF5\u8D28\u91CF" },
      "image-generate": { name: "Image (\u56FE\u50CF)", desc: "\u751F\u6210\u56FE\u7247\u5E76\u63D2\u5165\u7B14\u8BB0" }
    },
    reasoningEffortOptions: {
      notSet: "\u4E0D\u8BBE\u7F6E",
      low: "\u4F4E",
      medium: "\u4E2D",
      high: "\u9AD8"
    },
    validation: {
      temperature: "Temperature \u9700\u5728 0-2 \u4E4B\u95F4",
      topP: "Top P \u9700\u5728 0-1 \u4E4B\u95F4",
      maxTokens: "\u6700\u5927\u8F93\u51FA Tokens \u9700\u4E3A\u6B63\u6574\u6570"
    }
  },
  imageGeneration: {
    title: "\u56FE\u7247\u751F\u6210\u8BBE\u7F6E",
    enabled: { name: "\u542F\u7528\u56FE\u7247\u751F\u6210", desc: "\u5141\u8BB8\u5728\u7B14\u8BB0\u4E2D\u63D2\u5165 AI \u751F\u6210\u7684\u56FE\u7247" },
    defaultSize: {
      name: "\u9ED8\u8BA4\u56FE\u7247\u5C3A\u5BF8",
      desc: "\u751F\u6210\u56FE\u7247\u7684\u9ED8\u8BA4\u5C3A\u5BF8",
      square: "\u6B63\u65B9\u5F62 (1024\xD71024)",
      landscape: "\u6A2A\u5411 (1792\xD71024)",
      portrait: "\u7EB5\u5411 (1024\xD71792)"
    },
    defaultQuality: {
      name: "\u56FE\u7247\u8D28\u91CF",
      desc: "standard: \u6807\u51C6\u8D28\u91CF\uFF0Chd: \u9AD8\u6E05\u8D28\u91CF\uFF08\u6D88\u8017\u66F4\u591A token\uFF09",
      standard: "\u6807\u51C6",
      hd: "\u9AD8\u6E05"
    },
    defaultStyle: {
      name: "\u56FE\u7247\u98CE\u683C",
      desc: "vivid: \u9C9C\u8273\u751F\u52A8\uFF0Cnatural: \u81EA\u7136\u771F\u5B9E",
      vivid: "\u9C9C\u8273",
      natural: "\u81EA\u7136"
    },
    defaultAspectRatio: {
      name: "\u5BBD\u9AD8\u6BD4",
      desc: "\uFF08\u5DF2\u5E9F\u5F03\uFF09\u65E7\u5B57\u6BB5\uFF0C\u4E0D\u518D\u7528\u4E8E\u56FE\u7247\u751F\u6210\uFF1B\u8BF7\u4F7F\u7528\u300C\u9ED8\u8BA4\u56FE\u7247\u5C3A\u5BF8\u300D"
    },
    defaultImageSize: {
      name: "\u8F93\u51FA\u5206\u8FA8\u7387",
      desc: "\uFF08\u5DF2\u5E9F\u5F03\uFF09\u65E7\u5B57\u6BB5\uFF0C\u4E0D\u518D\u7528\u4E8E\u56FE\u7247\u751F\u6210\uFF1B\u8BF7\u4F7F\u7528\u300C\u9ED8\u8BA4\u56FE\u7247\u5C3A\u5BF8\u300D"
    },
    contextWindowSize: {
      name: "\u4E0A\u4E0B\u6587\u7A97\u53E3\u5927\u5C0F",
      desc: "\u8BFB\u53D6\u5149\u6807\u524D\u540E\u7528\u4E8E\u63D0\u793A\u8BCD\u7684\u5B57\u7B26\u6570"
    }
  },
  diff: {
    modeAmend: "\u4FEE\u8BA2",
    modeMerge: "\u5408\u5E76",
    modeSnapshot: "\u5FEB\u7167\u6062\u590D",
    accept: "\u63A5\u53D7",
    reject: "\u62D2\u7EDD",
    restoreVersion: "\u6062\u590D\u5230\u6B64\u7248\u672C",
    mergedNoteName: "\u5408\u5E76\u540E\u540D\u79F0",
    customName: "\u81EA\u5B9A\u4E49\u540D\u79F0...",
    customNamePlaceholder: "\u8F93\u5165\u81EA\u5B9A\u4E49\u540D\u79F0"
  },
  imageModal: {
    title: "\u751F\u6210\u56FE\u7247",
    promptLabel: "\u63CF\u8FF0\u4F60\u60F3\u8981\u7684\u56FE\u7247",
    promptPlaceholder: "\u4F8B\u5982\uFF1A\u4E00\u5F20\u5C55\u793A\u91CF\u5B50\u7EA0\u7F20\u7684\u7B80\u6D01\u7EBF\u7A3F\u56FE\uFF0C\u5E26\u7CBE\u70BC\u6807\u6CE8\u3002",
    contextPreview: "\u4E0A\u4E0B\u6587\u9884\u89C8",
    generate: "\u751F\u6210",
    cancel: "\u53D6\u6D88",
    promptTooShort: "\u8BF7\u81F3\u5C11\u8F93\u5165 5 \u4E2A\u5B57\u7B26\u3002",
    genericFailure: "\u64CD\u4F5C\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5"
  },
  feedback: {
    undo: "\u64A4\u9500",
    defaultError: "\u64CD\u4F5C\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5"
  }
};

// src/locales/en.json
var en_default = {
  common: {
    confirm: "Confirm",
    cancel: "Cancel",
    save: "Save",
    delete: "Delete",
    edit: "Edit",
    add: "Add",
    close: "Close",
    loading: "Loading...",
    success: "Success",
    error: "Error",
    warning: "Warning"
  },
  commands: {
    openWorkbench: "Open Workbench",
    createConcept: "Create Concept",
    improveNote: "Improve Note",
    expandNote: "Expand Current Note",
    mergeDuplicates: "Merge Duplicates"
  },
  workbench: {
    title: "Workbench",
    buttons: {
      improveNote: "Improve Current Note",
      expand: "Expand Current Note",
      insertImage: "Insert Image",
      verify: "Verify",
      openNoteHint: "Open a Markdown note to use Improve, Expand, and other tools"
    },
    createConcept: {
      title: "Create Concept",
      placeholder: "Enter concept description...",
      startButton: "Start",
      defining: "Defining...",
      selectType: "Please select concept type",
      create: "Create",
      clear: "Clear input"
    },
    amendModal: {
      title: "Amend Note",
      placeholder: "Enter amend instructions (e.g., add examples, refine definition, add related theories)"
    },
    duplicates: {
      title: "Duplicate Concepts",
      empty: "No duplicate concepts",
      dismiss: "Dismiss",
      compare: "Compare",
      compareAria: "Compare and merge",
      dismissAria: "Dismiss this duplicate pair"
    },
    queueStatus: {
      title: "Queue Status",
      active: "Active",
      paused: "Paused",
      pending: "Pending",
      running: "Running",
      failed: "Failed",
      clearPending: "Clear Pending",
      retryFailed: "Retry Failed",
      pauseQueue: "Pause Queue",
      resumeQueue: "Resume Queue",
      queueResumed: "Queue resumed",
      cancel: "Cancel",
      noTasks: "No tasks in queue",
      clearPendingConfirmTitle: "Confirm Clear Pending",
      clearPendingConfirmMessage: "Cancel all pending tasks?"
    },
    recentOps: {
      title: "Operation History",
      empty: "No operations to undo",
      undo: "Undo",
      view: "View",
      viewAria: "View snapshot",
      undoAria: "Undo this operation",
      clearAll: "Clear All",
      clearAllConfirmTitle: "Confirm Clear",
      clearAllConfirmMessage: "Are you sure you want to clear all snapshots? This action cannot be undone.",
      moreSnapshots: "{count} more older snapshots",
      viewSnapshotFailed: "Failed to read snapshot",
      undoFailed: "Restore failed",
      timeJustNow: "Just now",
      timeMinutesAgo: "{minutes} minutes ago",
      timeHoursAgo: "{hours} hours ago",
      timeDaysAgo: "{days} days ago",
      operationLabels: {
        enrich: "Tag",
        merge: "Merge",
        amend: "Amend",
        manualEdit: "Manual edit",
        standardize: "Define",
        create: "Create note",
        fallback: "Operation"
      }
    },
    notifications: {
      systemNotInitialized: "System not initialized",
      enterDescription: "Please enter concept description",
      standardizeFailed: "Definition failed",
      standardizeComplete: "Definition complete, please select type",
      pluginNotInitialized: "Plugin not initialized",
      openMarkdownFirst: "Please open a Markdown note first",
      createFailed: "Creation failed",
      conceptCreated: "Concept creation started",
      selectDuplicates: "Please select duplicates to merge first",
      batchMergeConfirm: "Confirm merging selected duplicate pairs?",
      batchMergeComplete: "Batch merge complete",
      batchDismissConfirm: "Confirm dismissing selected duplicate pairs?",
      batchDismissComplete: "Batch dismiss complete",
      fileNotFound: "File not found",
      previewFailed: "Failed to show preview",
      mergeTaskCreated: "Merge task created",
      duplicateManagerNotInitialized: "Duplicate manager not initialized",
      orchestratorNotInitialized: "Pipeline orchestrator not initialized",
      dismissFailed: "Dismiss failed",
      dismissSuccess: "Duplicate pair dismissed",
      queueResumed: "Queue resumed",
      queuePaused: "Queue paused",
      taskCancelled: "Task cancelled",
      cancelFailed: "Cancel failed",
      retryComplete: "Failed tasks retried",
      clearComplete: "Tasks cleared",
      undoFailed: "Undo failed",
      undoSuccess: "Undo successful",
      undoSuccessRestored: "Undo successful (file restored)",
      confirmCreateFailed: "Confirm create failed",
      confirmCreateWaiting: "Creation confirmed, waiting for content generation",
      standardizeUpdated: "Definition result updated",
      undoDismissSuccess: "Dismiss undone, duplicate pair restored to pending list",
      deletePairSuccess: "Duplicate pair record deleted",
      writeFailed: "Write failed",
      writeSuccess: "Written, undo available",
      writePreviewFailed: "Cannot generate write preview",
      amendCancelled: "Amend cancelled",
      writeCancelled: "Write cancelled",
      amendCompleted: "Amend completed",
      mergeCompleted: "Merge completed",
      mergeCancelled: "Merge cancelled",
      mergeStarted: "Merge task started. Please wait for AI to finish.",
      improveStarted: "Improvement task started. Please wait for AI to finish.",
      verifyStarted: "Verification started. Please wait for AI to finish.",
      imageTaskCreated: "Image generation task queued",
      imageGenerationFailed: "Failed to start image generation",
      featureDisabled: "Feature is disabled",
      workbenchNotInitialized: "Workbench not initialized, please try again later",
      startFailed: "Start failed: {message}",
      commandFailed: "Command failed: {message}",
      noPendingDuplicates: "No pending duplicates",
      pendingDuplicatesHint: "There are {count} pending duplicates. Please select which to merge in the workbench.",
      improveInstructionRequired: "Please enter an amend instruction",
      conceptLocked: "This concept is currently being processed. Please try again later.",
      clearFailed: "Clear failed",
      compareNoContent: "Cannot read note content",
      compareFailed: "Failed to open comparison"
    }
  },
  expand: {
    titlePrefix: "Expand: ",
    stats: {
      total: "Total",
      creatable: "Creatable",
      existing: "Existing",
      invalid: "Not creatable"
    },
    selectAll: "Select All",
    deselectAll: "Deselect All",
    confirm: "Create Selected",
    empty: "No candidates",
    status: {
      existing: "Existing",
      invalid: "Not creatable"
    },
    looseStructureHint: "No standard sections found. Fallback scan may miss items.",
    abstractTitlePrefix: "Abstract: ",
    abstractInstruction: "Pick at least one similar concept to generate a more abstract one with the current note.",
    abstractConfirm: "Generate",
    similarity: "Similarity",
    notInitialized: "Expand is not initialized",
    started: "Started {count} create tasks",
    startedWithFailures: "Started {started} tasks, {failed} failed to start"
  },
  settings: {
    title: "Cognitive Razor Settings",
    tabs: {
      general: "General",
      providers: "AI Providers",
      advanced: "Advanced",
      system: "System"
    },
    groups: {
      interface: "Interface",
      languageDisplay: "Language & Display",
      knowledgeStorage: "Knowledge Storage",
      automation: "Automation",
      deduplication: "Deduplication",
      performance: "Performance",
      directory: "Directory Structure",
      typeDirectories: "Type Directories",
      vectorEmbedding: "Vector Embedding",
      taskModels: "Task Models",
      snapshots: "Snapshots & Undo",
      logging: "Logging",
      dataManagement: "Data Management"
    },
    language: {
      name: "Language",
      desc: "Select interface language",
      zh: "\u4E2D\u6587",
      en: "English"
    },
    similarityThreshold: {
      name: "Similarity Threshold",
      desc: "Similarity threshold for detecting duplicate concepts (0-1)"
    },
    maxSnapshots: {
      name: "Max Snapshots",
      desc: "Maximum number of snapshots for undo operations"
    },
    maxSnapshotAgeDays: {
      name: "Snapshot Retention Days",
      desc: "Snapshots older than this will be automatically cleaned up"
    },
    concurrency: {
      name: "Concurrency",
      desc: "Maximum number of concurrent tasks"
    },
    units: {
      days: "days"
    },
    provider: {
      title: "AI Provider Configuration",
      addButton: "Add Provider",
      addDesc: "Configure AI service provider (supports OpenAI standard format, compatible with other services via custom endpoint)",
      noProvider: "No provider configured yet. Please add at least one provider to use plugin features.",
      addFirstProvider: "Click the button above to add your first AI Provider",
      defaultProvider: "Default Provider",
      defaultProviderDesc: "Select the default AI provider",
      testConnection: "Test Connection",
      setDefault: "Set as Default",
      status: "Status",
      enabled: "Enabled",
      disabled: "Disabled",
      model: "Model"
    },
    importExport: {
      title: "Import/Export",
      export: "Export",
      exportDesc: "Export current configuration as JSON file",
      import: "Import",
      importDesc: "Import configuration from JSON file",
      reset: "Reset",
      resetDesc: "Reset all settings to default values"
    },
    advanced: {
      title: "Advanced Settings",
      namingTemplate: {
        name: "Naming Template",
        desc: "Note filename template. Supported placeholders: {{chinese}} (Chinese name), {{english}} (English name), {{type}} (type in English), {{type_cn}} (type in Chinese), {{uid}} (unique identifier)"
      },
      directoryScheme: {
        title: "Directory Scheme",
        desc: "Configure storage directory for each knowledge type"
      },
      taskModels: {
        title: "Task Model Configuration",
        desc: "Configure models and parameters for different task types",
        providerAndModel: "Provider and Model",
        useDefaultProvider: "Use Default Provider",
        configureProviderFirst: "Please configure Provider first",
        modelName: "Model Name",
        modelNamePlaceholder: "Model name",
        notSet: "Not Set",
        low: "Low",
        medium: "Medium",
        high: "High",
        advancedParams: "Advanced Parameters"
      },
      temperature: {
        name: "Temperature",
        desc: "Controls randomness of generated content (0-2), lower values are more deterministic, higher values are more creative"
      },
      topP: {
        name: "Top P",
        desc: "Nucleus sampling parameter (0-1), controls diversity of generated content"
      },
      reasoningEffort: {
        name: "Reasoning Effort",
        desc: "Reasoning intensity (for models that support reasoning, such as o1, o3)"
      },
      embedding: {
        title: "Embedding Parameters",
        dimension: "Vector Dimension",
        dimensionDesc: "Embedding vector dimension (text-embedding-3-small supports 256-3072)",
        dimensionWarning: "Changing dimension requires rebuilding vector index, existing vector data will be invalidated"
      },
      features: {
        title: "Feature Toggles",
        enableAutoVerify: "Enable Auto Verify",
        enableAutoVerifyDesc: "Run Verify after writing and append a report to the end of the note (adds one LLM call)"
      },
      queue: {
        title: "Queue Parameters",
        autoRetry: "Auto Retry",
        autoRetryDesc: "Automatically retry failed tasks",
        maxRetryAttempts: "Max Retry Attempts",
        maxRetryAttemptsDesc: "Maximum number of retry attempts for failed tasks",
        taskTimeout: "Task Timeout",
        taskTimeoutDesc: "Maximum execution time for a single task (milliseconds, default 180000 = 3 minutes)",
        maxTaskHistory: "Max Task History",
        maxTaskHistoryDesc: "Maximum number of completed/failed/cancelled tasks to retain (default 300)",
        providerTimeout: "Provider Request Timeout",
        providerTimeoutDesc: "Timeout for API requests (milliseconds, default 1800000 = 30 minutes)"
      },
      logging: {
        title: "Logging Settings",
        logLevel: "Log Level",
        logLevelDesc: "Set the verbosity of logging",
        clearLogs: "Clear Logs",
        clearLogsDesc: "Clear all log files",
        levels: {
          debug: "Debug",
          info: "Info",
          warn: "Warning",
          error: "Error"
        }
      }
    }
  },
  setupWizard: {
    title: "Configure AI Provider",
    steps: {
      welcome: "Welcome",
      provider: "AI Service",
      directory: "Directories",
      complete: "Done"
    },
    welcome: {
      title: "Welcome to Cognitive Razor",
      subtitle: "Turn ideas into structured concepts and evolve your knowledge graph.",
      featureDefineTagWrite: "Define -> Tag -> Write: full creation pipeline",
      featureMergeAmend: "Merge & Amend: safe diff confirmation",
      featureVector: "Vector index: deduplication & similarity search",
      languageName: "Language",
      languageDesc: "Select interface language",
      languageOptionZh: "\u4E2D\u6587",
      languageOptionEn: "English"
    },
    provider: {
      title: "Configure AI Provider",
      apiKeyHintBeforeLink: "Get API Key from ",
      apiKeyHintAfterLink: "",
      apiKeyDesc: "Stored locally, never uploaded",
      customEndpointName: "Custom Endpoint",
      customEndpointDesc: "Leave empty to use Gemini OpenAI-compatible endpoint",
      chatModelName: "Chat Model",
      embedModelName: "Embedding Model"
    },
    directory: {
      title: "Initialize directories",
      subtitle: "Create directory structure for the 5 concept types."
    },
    complete: {
      title: "Setup complete",
      subtitle: "Cognitive Razor is ready. Open the Workbench to get started."
    },
    actions: {
      getStarted: "Get started",
      back: "Back",
      saveAndValidate: "Save & Validate",
      createAndContinue: "Create & Continue",
      openWorkbench: "Open Workbench",
      saving: "Saving...",
      creating: "Creating...",
      skipAndContinue: "Skip and continue"
    },
    validation: {
      idle: "Not validated yet",
      checking: "Validating connection...",
      ok: "Connection successful",
      offline: "Network unavailable, you can continue",
      error: "Validation failed, please check configuration",
      offlineSaved: "Network unavailable, config saved, you can continue",
      failedWithMessage: "Validation failed: {message}",
      offlineSavedByError: "Network error, config saved, you can continue"
    },
    directoryStatus: {
      idle: "Directories not initialized",
      creating: "Creating directories...",
      done: "Directories initialized",
      error: "Directory initialization failed",
      createFailed: "Directory creation failed"
    },
    notices: {
      enterApiKey: "Please enter API Key",
      enterProviderId: "Please enter Provider ID",
      invalidEndpointUrl: "Invalid endpoint URL: {message}",
      saveFailed: "Save failed: {message}",
      validationSkippedOffline: "Network unavailable, validation skipped",
      validationSkippedNetworkError: "Network error, validation skipped",
      saveErrorFallback: "Save error",
      saveError: "Save error: {message}"
    }
  },
  modals: {
    addProvider: {
      title: "Add AI Provider"
    },
    editProvider: {
      title: "Edit AI Provider"
    },
    providerConfig: {
      description: "Configure an OpenAI-compatible API service (Gemini, OpenAI, Azure OpenAI, etc.).",
      sections: {
        basic: "Basic Configuration",
        endpoint: "Endpoint Configuration",
        model: "Default Model"
      },
      fields: {
        providerId: "Provider ID",
        providerIdDesc: "Unique identifier, e.g. my-openai",
        apiKey: "API Key",
        apiKeyDesc: "Your API key",
        endpoint: "API Endpoint",
        endpointDesc: "Leave empty to use the default Gemini endpoint.",
        chatModel: "Chat Model",
        chatModelDesc: "Used for generation tasks",
        embedModel: "Embedding Model",
        embedModelDesc: "Used for vector embedding and semantic search"
      },
      showSecret: "Show",
      hideSecret: "Hide",
      errors: {
        providerIdRequired: "Please enter Provider ID",
        apiKeyRequired: "Please enter API Key",
        saveFailed: "Save failed",
        invalidUrlProtocol: "URL must start with http:// or https://",
        invalidUrl: "Invalid URL format"
      }
    }
  },
  notices: {
    providerAdded: "Provider {id} added",
    providerUpdated: "Provider {id} updated",
    providerDeleted: "Provider {id} deleted",
    providerSetDefault: "Default provider set to: {id}",
    connectionSuccess: "Connection successful!\nChat: {chat}\nEmbedding: {embedding}\nAvailable models: {models}",
    connectionFailed: "Connection failed: {error}",
    settingsExported: "Settings exported",
    settingsImported: "Settings imported",
    settingsReset: "Settings reset",
    logsCleared: "Logs cleared",
    noLogsToClean: "No log files to clean",
    languageChanged: "Language changed to: {language}",
    logLevelChanged: "Log level set to: {level} (will take effect on next startup)",
    groundingEnabled: "Verification enabled",
    groundingDisabled: "Verification disabled",
    networkRestored: "Network restored, queue can continue",
    networkOffline: "AI service offline, queue paused"
  },
  confirmDialogs: {
    deleteProvider: {
      title: "Delete Provider",
      message: 'Are you sure you want to delete provider "{id}"? This action cannot be undone.'
    },
    resetSettings: {
      title: "Reset Settings",
      message: "Are you sure you want to reset all settings? This action cannot be undone."
    },
    deleteDuplicatePair: {
      title: "Confirm Delete",
      message: "Are you sure you want to permanently delete this duplicate pair record? This action cannot be undone."
    }
  },
  taskTypes: {
    define: { name: "Define", desc: "Normalize the input and determine the concept type" },
    tag: { name: "Tag", desc: "Generate aliases and tags" },
    amend: { name: "Amend", desc: "Improve existing content incrementally" },
    merge: { name: "Merge", desc: "Merge duplicate concepts" },
    index: { name: "Index", desc: "Produce semantic vectors for retrieval" },
    write: { name: "Write", desc: "Generate full content or merge results" },
    verify: { name: "Verify", desc: "Check the accuracy of generated content" },
    "image-generate": { name: "Image", desc: "Generate images and insert into notes" }
  },
  crTypes: {
    Domain: "Domain",
    Issue: "Issue",
    Theory: "Theory",
    Entity: "Entity",
    Mechanism: "Mechanism"
  },
  crTypeDirectories: {
    Domain: "Storage directory for knowledge domains. Default: 1-\u9886\u57DF, supports relative paths like CR/1-\u9886\u57DF",
    Issue: "Storage directory for issues. Default: 2-\u8BAE\u9898, supports relative paths like CR/2-\u8BAE\u9898",
    Theory: "Storage directory for theories. Default: 3-\u7406\u8BBA, supports relative paths like CR/3-\u7406\u8BBA",
    Entity: "Storage directory for entities. Default: 4-\u5B9E\u4F53, supports relative paths like CR/4-\u5B9E\u4F53",
    Mechanism: "Storage directory for mechanisms. Default: 5-\u673A\u5236, supports relative paths like CR/5-\u673A\u5236"
  },
  taskModels: {
    title: "Task Model Configuration",
    resetAll: "Reset All",
    resetAllConfirm: "Are you sure you want to reset all task configurations to default values? This action cannot be undone.",
    reset: "Reset",
    resetConfirm: "Are you sure you want to reset this task configuration to default values?",
    isDefault: "Default",
    isCustom: "Custom",
    recommended: "Recommended",
    fields: {
      provider: "Provider",
      providerDesc: "Select AI Provider (leave empty to use default Provider)",
      useDefaultProvider: "Use Default Provider",
      model: "Model Name",
      modelDesc: "Specify the model to use (e.g., gemini-3-flash-preview)",
      temperature: "Temperature",
      temperatureDesc: "Controls randomness (0-2), lower values are more deterministic, higher values are more creative",
      topP: "Top P",
      topPDesc: "Nucleus sampling parameter (0-1), controls diversity",
      maxTokens: "Max output tokens",
      maxTokensDesc: "Limit output tokens (leave empty for no limit)",
      reasoningEffort: "Reasoning Effort",
      reasoningEffortDesc: "For models that support reasoning (e.g., o1, o3)",
      embeddingDimension: "Embedding Dimension",
      embeddingDimensionDesc: "Dimension size for vector embeddings"
    },
    tasks: {
      define: { name: "Define", desc: "Analyze and define core concept meaning" },
      tag: { name: "Tag", desc: "Tag and categorize concepts" },
      write: { name: "Write", desc: "Write and expand concept content" },
      amend: { name: "Amend", desc: "Improve existing content" },
      merge: { name: "Merge", desc: "Merge duplicate concepts" },
      index: { name: "Index", desc: "Generate semantic vectors and build index" },
      verify: { name: "Verify", desc: "Validate and check concept quality" },
      "image-generate": { name: "Image", desc: "Generate images and insert into notes" }
    },
    reasoningEffortOptions: {
      notSet: "Not Set",
      low: "Low",
      medium: "Medium",
      high: "High"
    },
    validation: {
      temperature: "Temperature must be between 0 and 2",
      topP: "Top P must be between 0 and 1",
      maxTokens: "Max output tokens must be a positive integer"
    }
  },
  imageGeneration: {
    title: "Image Generation",
    enabled: { name: "Enable image generation", desc: "Allow inserting AI-generated images into notes" },
    defaultSize: {
      name: "Default image size",
      desc: "Default canvas size when generating images",
      square: "Square (1024\xD71024)",
      landscape: "Landscape (1792\xD71024)",
      portrait: "Portrait (1024\xD71792)"
    },
    defaultQuality: {
      name: "Image quality",
      desc: "standard: standard quality, hd: high quality (costs more tokens)",
      standard: "Standard",
      hd: "HD"
    },
    defaultStyle: {
      name: "Image style",
      desc: "vivid: vibrant, natural: realistic",
      vivid: "Vivid",
      natural: "Natural"
    },
    defaultAspectRatio: {
      name: "Aspect ratio",
      desc: 'Deprecated. No longer used for image generation; use "Default image size" instead.'
    },
    defaultImageSize: {
      name: "Output resolution",
      desc: 'Deprecated. No longer used for image generation; use "Default image size" instead.'
    },
    contextWindowSize: {
      name: "Context window size",
      desc: "Characters before/after cursor to include in prompt"
    }
  },
  diff: {
    modeAmend: "Amend",
    modeMerge: "Merge",
    modeSnapshot: "Snapshot Restore",
    accept: "Accept",
    reject: "Reject",
    restoreVersion: "Restore to this version",
    mergedNoteName: "Merged note name",
    customName: "Custom name...",
    customNamePlaceholder: "Enter custom name"
  },
  imageModal: {
    title: "Generate Image",
    promptLabel: "Describe the image you want",
    promptPlaceholder: "Example: A clean line-art diagram showing quantum entanglement with concise labels.",
    contextPreview: "Context preview",
    generate: "Generate",
    cancel: "Cancel",
    promptTooShort: "Please enter at least 5 characters.",
    genericFailure: "Operation failed, please try again later"
  },
  feedback: {
    undo: "Undo",
    defaultError: "Operation failed, please try again later"
  }
};

// src/core/i18n.ts
var I18n = class {
  currentLanguage;
  translationData;
  listeners = /* @__PURE__ */ new Set();
  logger = null;
  constructor(initialLanguage = "zh") {
    this.currentLanguage = initialLanguage;
    this.translationData = {
      zh: zh_default,
      en: en_default
    };
  }
  /**
   * 设置 Logger 实例（延迟注入，避免循环依赖）
   */
  setLogger(logger) {
    this.logger = logger;
  }
  /**
   * 获取当前语言
   */
  getLanguage() {
    return this.currentLanguage;
  }
  /**
   * 设置语言，并通知所有已注册的监听器
   */
  setLanguage(language) {
    if (this.currentLanguage === language) return;
    this.currentLanguage = language;
    for (const listener of this.listeners) {
      try {
        listener();
      } catch {
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  t(key2) {
    if (key2 === void 0) {
      return this.translationData[this.currentLanguage];
    }
    return this.resolveKey(key2);
  }
  /**
   * 带参数插值的翻译
   *
   * 支持 {param} 占位符，例如：
   *   format("notices.providerAdded", { id: "openai" })
   *   → "Provider openai 已添加"
   */
  format(key2, params) {
    const template = this.resolveKey(key2);
    return formatMessage(template, params);
  }
  /**
   * 注册语言切换监听器
   * @returns 取消注册的函数
   */
  onLanguageChange(listener) {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }
  /**
   * 解析键路径，支持回退到英文
   */
  resolveKey(key2) {
    const value = this.getNestedValue(this.translationData[this.currentLanguage], key2);
    if (typeof value === "string") return value;
    if (this.currentLanguage !== "en") {
      const fallback2 = this.getNestedValue(this.translationData.en, key2);
      if (typeof fallback2 === "string") {
        this.logger?.warn("I18n", `\u7FFB\u8BD1\u952E\u7F3A\u5931\uFF0C\u5DF2\u56DE\u9000\u5230\u82F1\u6587: ${key2}`, { key: key2, lang: this.currentLanguage });
        return fallback2;
      }
    }
    this.logger?.warn("I18n", `\u7FFB\u8BD1\u952E\u4E0D\u5B58\u5728: ${key2}`, { key: key2 });
    return key2;
  }
  /**
   * 从嵌套对象中按点分隔路径取值
   */
  getNestedValue(obj, path) {
    const keys = path.split(".");
    let current = obj;
    for (const k of keys) {
      if (current && typeof current === "object" && k in current) {
        current = current[k];
      } else {
        return void 0;
      }
    }
    return current;
  }
};
function formatMessage(template, params) {
  return template.replace(/\{(\w+)\}/g, (match, key2) => {
    return params[key2]?.toString() ?? match;
  });
}

// node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Alias: () => Alias,
  CST: () => cst_exports,
  Composer: () => Composer,
  Document: () => Document,
  Lexer: () => Lexer,
  LineCounter: () => LineCounter,
  Pair: () => Pair,
  Parser: () => Parser,
  Scalar: () => Scalar,
  Schema: () => Schema,
  YAMLError: () => YAMLError,
  YAMLMap: () => YAMLMap,
  YAMLParseError: () => YAMLParseError,
  YAMLSeq: () => YAMLSeq,
  YAMLWarning: () => YAMLWarning,
  isAlias: () => isAlias,
  isCollection: () => isCollection,
  isDocument: () => isDocument,
  isMap: () => isMap,
  isNode: () => isNode,
  isPair: () => isPair,
  isScalar: () => isScalar,
  isSeq: () => isSeq,
  parse: () => parse,
  parseAllDocuments: () => parseAllDocuments,
  parseDocument: () => parseDocument,
  stringify: () => stringify3,
  visit: () => visit,
  visitAsync: () => visitAsync
});

// node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key2, node, visitor, path) {
  const ctrl = callVisitor(key2, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key2, path, ctrl);
    return visit_(key2, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key2, node, visitor, path) {
  const ctrl = await callVisitor(key2, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key2, path, ctrl);
    return visitAsync_(key2, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key2, node, visitor, path) {
  if (typeof visitor === "function")
    return visitor(key2, node, path);
  if (isMap(node))
    return visitor.Map?.(key2, node, path);
  if (isSeq(node))
    return visitor.Seq?.(key2, node, path);
  if (isPair(node))
    return visitor.Pair?.(key2, node, path);
  if (isScalar(node))
    return visitor.Scalar?.(key2, node, path);
  if (isAlias(node))
    return visitor.Alias?.(key2, node, path);
  return void 0;
}
function replaceNode(key2, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key2] = node;
  } else if (isPair(parent)) {
    if (key2 === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class _Directives {
  constructor(yaml, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, _Directives.defaultTags, tags);
  }
  clone() {
    const copy = new _Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new _Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: _Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, _Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, _Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source2, onError) {
    if (source2 === "!")
      return "!";
    if (source2[0] !== "!") {
      onError(`Not a valid tag: ${source2}`);
      return null;
    }
    if (source2[1] === "<") {
      const verbatim = source2.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source2} is invalid.`);
        return null;
      }
      if (source2[source2.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source2.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source2} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source2;
    onError(`Could not resolve tag: ${source2}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag2) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag2.startsWith(prefix))
        return handle + escapeTagName(tag2.substring(prefix.length));
    }
    return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root5) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root5, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source2) => {
      aliasObjects.push(source2);
      prevAnchors ?? (prevAnchors = anchorNames(doc));
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source2 of aliasObjects) {
        const ref = sourceObjects.get(source2);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source2;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key2, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key2, val);
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source2) {
    super(ALIAS);
    this.source = source2;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc, ctx) {
    let nodes;
    if (ctx?.aliasResolveCache) {
      nodes = ctx.aliasResolveCache;
    } else {
      nodes = [];
      visit(doc, {
        Node: (_key, node) => {
          if (isAlias(node) || hasAnchor(node))
            nodes.push(node);
        }
      });
      if (ctx)
        ctx.aliasResolveCache = nodes;
    }
    let found = void 0;
    for (const node of nodes) {
      if (node === this)
        break;
      if (node.anchor === this.source)
        found = node;
    }
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source2 = this.resolve(doc, ctx);
    if (!source2) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source2);
    if (!data) {
      toJS(source2, null, ctx);
      data = anchors.get(source2);
    }
    if (data?.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source2, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source2 = node.resolve(doc);
    const anchor = anchors && source2 && anchors.get(source2);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      ref.anchor ?? (ref.anchor = onAnchor(value));
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key2, ...rest] = path;
      const node = this.get(key2, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key2, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key2, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key2);
    const node = this.get(key2, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key2, ...rest] = path;
    const node = this.get(key2, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key2, ...rest] = path;
    if (rest.length === 0)
      return this.has(key2);
    const node = this.get(key2, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key2, ...rest] = path;
    if (rest.length === 0) {
      this.set(key2, value);
    } else {
      const node = this.get(key2, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key2, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key2}. Remaining path: ${rest}`);
    }
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
var lineComment = (str, indent, comment2) => str.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str.endsWith(" ") ? "" : " ") + comment2;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text2, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text2, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text2[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text2[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text2, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next2 = text2[i + 1];
        if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text2[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text2;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text2.length;
    if (fold === 0)
      res = `
${indent}${text2.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text2[fold]}\\`;
      res += `
${indent}${text2.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text2[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text2[++i];
    } else {
      do {
        ch = text2[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text2[start];
    }
  }
  return end;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag2) => tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && tag2.test?.test(str);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags.filter((t) => t.identify?.(obj));
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag2 = node.tag ?? (tagObj.default ? null : tagObj.tag);
  if (tag2)
    props.push(doc.directives.tagString(tag2));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key: key2, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key2) && key2.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key2) || !isNode(key2) && typeof key2 === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key2 || keyComment && value == null && !ctx.inFlow || isCollection(key2) || (isScalar(key2) ? key2.type === Scalar.BLOCK_FOLDED || key2.type === Scalar.BLOCK_LITERAL : typeof key2 === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key2, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n" && valueComment)
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function debug(logLevel, ...messages) {
  if (logLevel === "debug")
    console.log(...messages);
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js
var MERGE_KEY = "<<";
var merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
var isMergeKey = (ctx, key2) => (merge.identify(key2) || isScalar(key2) && (!key2.type || key2.type === Scalar.PLAIN) && merge.identify(key2.value)) && ctx?.doc.schema.tags.some((tag2) => tag2.tag === merge.tag && tag2.default);
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source2 = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source2))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source2.toJSON(null, ctx, Map);
  for (const [key2, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key2))
        map2.set(key2, value2);
    } else if (map2 instanceof Set) {
      map2.add(key2);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key2)) {
      Object.defineProperty(map2, key2, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap(ctx, map2, { key: key2, value }) {
  if (isNode(key2) && key2.addToJSMap)
    key2.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key2))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key2, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key2, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key2, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key2) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key2.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key2, value, ctx) {
  const k = createNode(key2, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class _Pair {
  constructor(key2, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key2;
    this.value = value;
  }
  clone(schema4) {
    let { key: key2, value } = this;
    if (isNode(key2))
      key2 = key2.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new _Pair(key2, value);
  }
  toJSON(_, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment3 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str2 += lineComment(str2, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str += ",";
    if (comment2)
      str += lineComment(str, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key2) {
  const k = isScalar(key2) ? key2.value : key2;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key2 || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key2, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key2, value);
      else if (Array.isArray(replacer) && !replacer.includes(key2))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key2, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key2, value] of obj)
        add(key2, value);
    } else if (obj && typeof obj === "object") {
      for (const key2 of Object.keys(obj))
        add(key2, obj[key2]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key2) {
    const it = findPair(this.items, key2);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key2, keepScalar) {
    const it = findPair(this.items, key2);
    const node = it?.value;
    return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
  }
  has(key2) {
    return !!findPair(this.items, key2);
  }
  set(key2, value) {
    this.add(new Pair(key2, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key2) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key2, keepScalar) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key2) {
    const idx = asItemIndex(key2);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key2, value) {
    const idx = asItemIndex(key2);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key2}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key2 = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key2, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key2) {
  let idx = isScalar(key2) ? key2.value : key2;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source: source2 }, ctx) => typeof source2 === "string" && nullTag.test.test(source2) ? source2 : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source: source2, value }, ctx) {
    if (source2 && boolTag.test.test(source2)) {
      const sv = source2[0] === "t" || source2[0] === "T";
      if (value === sv)
        return source2;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag: tag2, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
  if (!format && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment: comment2, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    type ?? (type = Scalar.BLOCK_LITERAL);
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key2, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key2 = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key2 = keys[0];
          value = it[key2];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key2 = it;
      }
      pairs2.items.push(createPair(key2, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class _YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = _YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key2, value;
      if (isPair(pair)) {
        key2 = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key2, ctx);
      } else {
        key2 = toJS(pair, "", ctx);
      }
      if (map2.has(key2))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key2, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key: key2 } of pairs2.items) {
      if (isScalar(key2)) {
        if (seenKeys.includes(key2.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key2.value}`);
        } else {
          seenKeys.push(key2.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source: source2 }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source2 && boolObj.test.test(source2))
    return source2;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class _YAMLSet extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = _YAMLSet.tag;
  }
  add(key2) {
    let pair;
    if (isPair(key2))
      pair = key2;
    else if (key2 && typeof key2 === "object" && "key" in key2 && "value" in key2 && key2.value === null)
      pair = new Pair(key2.key, null);
    else
      pair = new Pair(key2, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key2, keepPair) {
    const pair = findPair(this.items, key2);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key2, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key2);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key2));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set3 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set3.items.push(createPair(value, null, ctx));
      }
    return set3;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags = schemaTags;
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key2) => key2 !== "yaml11").map((key2) => JSON.stringify(key2)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag2 of customTags)
      tags = tags.concat(tag2);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  if (addMergeTag)
    tags = tags.concat(merge);
  return tags.reduce((tags2, tag2) => {
    const tagObj = typeof tag2 === "string" ? tagsByName[tag2] : tag2;
    if (!tagObj) {
      const tagName = JSON.stringify(tag2);
      const keys = Object.keys(tagsByName).map((key2) => JSON.stringify(key2)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags2.includes(tagObj))
      tags2.push(tagObj);
    return tags2;
  }, []);
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class _Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class _Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options?._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(_Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag2, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key2, value, options = {}) {
    const k = this.createNode(key2, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key2) {
    return assertCollection(this.contents) ? this.contents.delete(key2) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key2, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key2, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key2) {
    return isCollection(this.contents) ? this.contents.has(key2) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key2, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key2], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key2, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end?.line === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next: next2, offset, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag2 = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next2?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag2)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag2)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag2 = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag2)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== "")) {
    onError(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next2?.type === "block-map" || next2?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment: comment2,
    hasNewline,
    anchor,
    tag: tag2,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key2) {
  if (!key2)
    return null;
  switch (key2.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key2.source.includes("\n"))
        return true;
      if (key2.end) {
        for (const st of key2.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key2.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag2) {
  const NodeClass = tag2?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key: key2, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key2 ?? sep?.[0],
      offset,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key2) {
        if (key2.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key2 && key2.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key2)) {
        onError(key2 ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key2 ? composeNode2(ctx, key2, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key2, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key2 || key2.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset, commentEnd ?? offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag2) {
  const NodeClass = tag2?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value?.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment2 = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source: source2, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source2.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment2)
            sep += source2;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source2.length;
    }
  }
  return { comment: comment2, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag2) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag2?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key: key2, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key2 ?? sep?.[0],
      offset,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key2))
        onError(
          key2,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key2 ? composeNode2(ctx, key2, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key2))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source?.[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce?.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag2) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag2) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag2) : resolveFlowCollection(CN2, ctx, token, onError, tag2);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag2 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag2) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt?.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag2 = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag2);
  const res = tag2.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag2?.format)
    node.format = tag2.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source: source2 } = props[0];
  const mode = source2[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source2.length; ++i) {
    const ch = source2[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source2}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source2.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment2 = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment: comment2, length };
}
function splitLines(source2) {
  const split = source2.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source: source2, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source2, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source2, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source2, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source2.length, offset + source2.length]
      };
  }
  const valueEnd = offset + source2.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source2, onError) {
  let badChar = "";
  switch (source2[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source2[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source2[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source2);
}
function singleQuotedValue(source2, onError) {
  if (source2[source2.length - 1] !== "'" || source2.length === 1)
    onError(source2.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source2.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source2) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source2);
  if (!match)
    return source2;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source2)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source2);
  return res + sep + (match?.[1] ?? "");
}
function doubleQuotedValue(source2, onError) {
  let res = "";
  for (let i = 1; i < source2.length - 1; ++i) {
    const ch = source2[i];
    if (ch === "\r" && source2[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source2, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next2 = source2[++i];
      const cc = escapeCodes[next2];
      if (cc)
        res += cc;
      else if (next2 === "\n") {
        next2 = source2[i + 1];
        while (next2 === " " || next2 === "	")
          next2 = source2[++i + 1];
      } else if (next2 === "\r" && source2[i + 1] === "\n") {
        next2 = source2[++i + 1];
        while (next2 === " " || next2 === "	")
          next2 = source2[++i + 1];
      } else if (next2 === "x" || next2 === "u" || next2 === "U") {
        const length = { x: 2, u: 4, U: 8 }[next2];
        res += parseCharCode(source2, i + 1, length, onError);
        i += length;
      } else {
        const raw = source2.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next2 = source2[i + 1];
      while (next2 === " " || next2 === "	")
        next2 = source2[++i + 1];
      if (next2 !== "\n" && !(next2 === "\r" && source2[i + 2] === "\n"))
        res += i > wsStart ? source2.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source2[source2.length - 1] !== '"' || source2.length === 1)
    onError(source2.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source2, offset) {
  let fold = "";
  let ch = source2[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source2[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source2[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "\x85",
  // Unicode next line
  _: "\xA0",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source2, offset, length, onError) {
  const cc = source2.substr(offset, length);
  const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok2 ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source2.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment: comment2, range } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag2;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag2 = ctx.schema[SCALAR];
  } else if (tagName)
    tag2 = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag2 = findScalarTagByTest(ctx, value, token, onError);
  else
    tag2 = ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag2.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag2.format)
    scalar.format = tag2.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag2 of schema4.tags) {
    if (!tag2.collection && tag2.tag === tagName) {
      if (tag2.default && tag2.test)
        matchWithTest.push(tag2);
      else
        return tag2;
    }
  }
  for (const tag2 of matchWithTest)
    if (tag2.test?.test(value))
      return tag2;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema: schema4 }, value, token, onError) {
  const tag2 = schema4.tags.find((tag3) => (tag3.default === true || atKey && tag3.default === "key") && tag3.test?.test(value)) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag3) => tag3.default && tag3.test?.test(value)) ?? schema4[SCALAR];
    if (tag2.tag !== compat.tag) {
      const ts = directives.tagString(tag2.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag2;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    pos ?? (pos = before.length);
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment: comment2, anchor, tag: tag2 } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag2)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag2 ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment2;
    else
      node.commentBefore = comment2;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment2, anchor, tag: tag2, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag2, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment2) {
    node.comment = comment2;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset, source: source2, end }, onError) {
  const alias = new Alias(source2.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset + source2.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source2.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source: source2 } = src;
  return [offset, offset + (typeof source2 === "string" ? source2.length : 1)];
}
function parsePrelude(prelude) {
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source2 = prelude[i];
    switch (source2[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source2.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source2, code, message, warning) => {
      const pos = getErrorPos(source2);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment2;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source2 = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source2[0]) {
    case "|":
    case ">": {
      const he = source2.indexOf("\n");
      const head2 = source2.substring(0, he);
      const body = source2.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head2 }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source: source2, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source: source2, end };
    default:
      return { type: "scalar", offset, indent, source: source2, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source2 = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source2[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source2);
      break;
    case '"':
      setFlowScalarValue(token, source2, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source2, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source2, "scalar");
  }
}
function setBlockScalarValue(token, source2) {
  const he = source2.indexOf("\n");
  const head2 = source2.substring(0, he);
  const body = source2.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head2;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head2 }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key2 of Object.keys(token))
      if (key2 !== "type" && key2 !== "offset")
        delete token[key2];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source2, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source2;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source2.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source: source2, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source2.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source: source2, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key2 of Object.keys(token))
        if (key2 !== "type" && key2 !== "offset")
          delete token[key2];
      Object.assign(token, { type, indent, source: source2, end });
    }
  }
}

// node_modules/yaml/browser/dist/parse/cst-stringify.js
var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key: key2, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key2)
    res += stringifyToken(key2);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index2] of path) {
    const tok = item?.[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent?.[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
var isCollection2 = (token) => !!token && "items" in token;
var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source2) {
  switch (source2) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source2[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = new Set("0123456789ABCDEFabcdef");
var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
var flowIndicatorChars = new Set(",[]{}");
var invalidAnchorChars = new Set(" ,[]{}\n\r	");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source2, incomplete = false) {
    if (source2) {
      if (typeof source2 !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source2 : source2;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next2 = this.next ?? "stream";
    while (next2 && (incomplete || this.hasChars(1)))
      next2 = yield* this.parseNext(next2);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next2 = this.buffer[indent + offset + 1];
        if (next2 === "\n" || !next2 && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state2) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state2;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next2) {
    switch (next2) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next2 = this.charAt(1);
        if (this.flowKey || isEmpty(next2) || next2 === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next2 = this.buffer[i2 + 1];
          if (!next2 && !this.atEnd)
            return this.setNext("block-scalar");
          if (next2 === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next2 = this.buffer[i + 1];
        if (isEmpty(next2) || inFlow && flowIndicatorChars.has(next2))
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next2 = this.buffer[i + 1];
        if (ch === "\r") {
          if (next2 === "\n") {
            i += 1;
            ch = "\n";
            next2 = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next2 === "#" || inFlow && flowIndicatorChars.has(next2))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source2, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source2, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source2) {
    this.source = source2;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source2.length;
      return;
    }
    const type = tokenType(source2);
    if (!type) {
      const message = `Not a YAML token: ${source2}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source: source2 });
      this.offset += source2.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source2.length);
          break;
        case "space":
          if (this.atNewLine && source2[0] === " ")
            this.indent += source2.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source2.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source2.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && top?.type !== "doc-end") {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error ?? this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key2 = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key: key2, sep }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last?.type === "comment")
            end?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top?.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source2, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  const docs = Array.from(composer.compose(parser.parse(source2)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source2, lineCounter));
      doc.warnings.forEach(prettifyError(source2, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source2, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source2), true, source2.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source2, lineCounter));
    doc.warnings.forEach(prettifyError(source2, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify3(value, replacer, options) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options === void 0 && replacer) {
    options = replacer;
  }
  if (typeof options === "string")
    options = options.length;
  if (typeof options === "number") {
    const indent = Math.round(options);
    options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = options ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  if (isDocument(value) && !_replacer)
    return value.toString(options);
  return new Document(value, _replacer, options).toString(options);
}

// node_modules/yaml/browser/index.js
var browser_default = dist_exports;

// src/utils/date-utils.ts
function formatCRTimestamp(date = /* @__PURE__ */ new Date()) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

// src/core/frontmatter-utils.ts
var FRONTMATTER_DELIMITER = "---";
var REQUIRED_STRING_FIELDS = [
  "cruid",
  "type",
  "name",
  "status",
  "created",
  "updated"
];
var REQUIRED_ARRAY_FIELDS = [
  "parents"
];
var ARRAY_FIELDS = ["aliases", "tags", "sourceUids", "parents"];
function formatYamlString(value) {
  const escaped = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\r/g, "\\r").replace(/\n/g, "\\n").replace(/\t/g, "\\t");
  return `"${escaped}"`;
}
var WIKILINK_REGEX = /^\[\[(.*?)\]\]$/;
function normalizeParentLink(value) {
  const trimmed = value.trim();
  if (!trimmed) {
    return null;
  }
  const match = trimmed.match(WIKILINK_REGEX);
  const inner = (match ? match[1] : trimmed).trim();
  if (!inner) {
    return null;
  }
  const withoutAlias = inner.split("|", 1)[0] ?? inner;
  const withoutHeading = withoutAlias.split("#", 1)[0] ?? withoutAlias;
  const withoutExt = withoutHeading.endsWith(".md") ? withoutHeading.slice(0, -".md".length) : withoutHeading;
  const title = withoutExt.trim();
  if (!title) {
    return null;
  }
  return `[[${title}]]`;
}
function normalizeParents(parents) {
  const normalized = [];
  const seen = /* @__PURE__ */ new Set();
  for (const item of parents) {
    const link2 = normalizeParentLink(String(item));
    if (!link2) {
      continue;
    }
    if (seen.has(link2)) {
      continue;
    }
    seen.add(link2);
    normalized.push(link2);
  }
  return normalized;
}
function generateFrontmatter(options) {
  const now2 = formatCRTimestamp();
  return {
    cruid: options.cruid,
    type: options.type,
    name: options.name,
    definition: options.definition,
    status: options.status || "Stub",
    created: now2,
    updated: now2,
    parents: normalizeParents(options.parents || []),
    aliases: options.aliases,
    tags: options.tags,
    sourceUids: options.sourceUids,
    version: options.version
  };
}
function formatArrayInline(arr) {
  if (arr.length === 0) return "[]";
  const formatted = arr.map((item) => formatYamlString(item));
  return `[${formatted.join(", ")}]`;
}
function frontmatterToYaml(frontmatter) {
  const lines = [];
  lines.push(`cruid: ${frontmatter.cruid}`);
  lines.push(`type: ${frontmatter.type}`);
  lines.push(`name: ${formatYamlString(frontmatter.name)}`);
  if (frontmatter.definition) {
    lines.push(`definition: ${formatYamlString(frontmatter.definition)}`);
  }
  lines.push(`status: ${frontmatter.status}`);
  lines.push(`created: ${frontmatter.created}`);
  lines.push(`updated: ${frontmatter.updated}`);
  if (frontmatter.aliases && frontmatter.aliases.length > 0) {
    lines.push(`aliases: ${formatArrayInline(frontmatter.aliases)}`);
  }
  const parentsValue = Array.isArray(frontmatter.parents) && frontmatter.parents.length > 0 ? formatArrayInline(frontmatter.parents) : "[]";
  lines.push(`parents: ${parentsValue}`);
  if (frontmatter.tags && frontmatter.tags.length > 0) {
    lines.push(`tags: ${formatArrayInline(frontmatter.tags)}`);
  }
  if (frontmatter.sourceUids && frontmatter.sourceUids.length > 0) {
    lines.push(`sourceUids: ${formatArrayInline(frontmatter.sourceUids)}`);
  }
  if (frontmatter.version) {
    lines.push(`version: ${frontmatter.version}`);
  }
  const KNOWN_FIELDS = /* @__PURE__ */ new Set([
    "cruid",
    "type",
    "name",
    "definition",
    "status",
    "created",
    "updated",
    "aliases",
    "tags",
    "parents",
    "sourceUids",
    "version"
  ]);
  for (const [key2, value] of Object.entries(frontmatter)) {
    if (KNOWN_FIELDS.has(key2)) continue;
    if (value === void 0 || value === null) continue;
    const yamlValue = browser_default.stringify(value).trimEnd();
    lines.push(`${key2}: ${yamlValue}`);
  }
  return `${FRONTMATTER_DELIMITER}
${lines.join("\n")}
${FRONTMATTER_DELIMITER}

`;
}
function parseFrontmatter(yaml) {
  try {
    const trimmed = yaml.trim();
    const cleanYaml = trimmed.startsWith(FRONTMATTER_DELIMITER) ? trimmed.replace(/^---\s*/, "").replace(/\s*---$/, "") : trimmed;
    const document2 = browser_default.parse(cleanYaml, { uniqueKeys: true });
    if (!document2 || typeof document2 !== "object") {
      return null;
    }
    const normalized = {};
    for (const [key2, value] of Object.entries(document2)) {
      if (ARRAY_FIELDS.includes(key2) && Array.isArray(value)) {
        normalized[key2] = value.map((v) => String(v));
        continue;
      }
      normalized[key2] = value;
    }
    for (const field of REQUIRED_STRING_FIELDS) {
      if (typeof normalized[field] !== "string" || normalized[field]?.toString().trim() === "") {
        return null;
      }
    }
    for (const field of REQUIRED_ARRAY_FIELDS) {
      if (!Object.prototype.hasOwnProperty.call(normalized, field)) {
        return null;
      }
      if (!Array.isArray(normalized[field])) {
        return null;
      }
    }
    const aliases = normalizeStringArray(normalized.aliases);
    const tags = normalizeStringArray(normalized.tags);
    const sourceUids = normalizeStringArray(normalized.sourceUids);
    const parents = normalizeParents(normalizeStringArray(normalized.parents) || []);
    const version = normalizeOptionalString(normalized.version);
    const name = typeof normalized.name === "string" ? normalized.name : "";
    const definition = normalizeOptionalString(normalized.definition);
    const rawCruid = typeof normalized.cruid === "string" ? normalized.cruid : typeof normalized.crUid === "string" ? normalized.crUid : void 0;
    if (!rawCruid) {
      return null;
    }
    const KNOWN_FIELDS = /* @__PURE__ */ new Set([
      "cruid",
      "crUid",
      "type",
      "name",
      "definition",
      "status",
      "created",
      "updated",
      "aliases",
      "tags",
      "parents",
      "sourceUids",
      "version"
    ]);
    const extras = {};
    for (const [key2, value] of Object.entries(normalized)) {
      if (!KNOWN_FIELDS.has(key2)) {
        extras[key2] = value;
      }
    }
    return {
      cruid: rawCruid,
      type: normalized.type,
      name,
      definition,
      status: normalized.status,
      created: normalized.created,
      updated: normalized.updated,
      aliases,
      tags,
      parents,
      sourceUids,
      version,
      ...extras
    };
  } catch (error) {
    return null;
  }
}
function extractFrontmatter(content) {
  if (!content.startsWith(`${FRONTMATTER_DELIMITER}
`)) {
    return null;
  }
  const lines = content.split("\n");
  let endIndex = -1;
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].trim() === FRONTMATTER_DELIMITER) {
      endIndex = i;
      break;
    }
  }
  if (endIndex === -1) {
    return null;
  }
  const yamlContent = lines.slice(0, endIndex + 1).join("\n");
  const body = lines.slice(endIndex + 1).join("\n");
  const frontmatter = parseFrontmatter(yamlContent);
  if (!frontmatter) {
    return null;
  }
  return { frontmatter, body };
}
function updateFrontmatter(content, updates) {
  const now2 = formatCRTimestamp();
  const extracted = extractFrontmatter(content);
  if (!extracted) {
    const newFrontmatter = generateFrontmatter({
      cruid: updates.cruid || "",
      type: updates.type || "Entity",
      name: updates.name || "Unnamed Concept",
      definition: updates.definition,
      parents: updates.parents || [],
      status: updates.status,
      aliases: updates.aliases,
      tags: updates.tags,
      sourceUids: updates.sourceUids,
      version: updates.version
    });
    return frontmatterToYaml(newFrontmatter) + content;
  }
  const merged = {
    ...extracted.frontmatter,
    ...updates,
    parents: normalizeParents(updates.parents ?? extracted.frontmatter.parents ?? []),
    updated: now2
    // 总是更新时间戳
  };
  return frontmatterToYaml(merged) + extracted.body;
}
function generateMarkdownContent(frontmatter, body) {
  return frontmatterToYaml(frontmatter) + body;
}
function normalizeStringArray(value) {
  if (!value) {
    return void 0;
  }
  if (Array.isArray(value)) {
    return value.map((item) => String(item));
  }
  return void 0;
}
function normalizeOptionalString(value) {
  if (typeof value === "string") {
    return value;
  }
  return void 0;
}

// src/core/cruid-cache.ts
var import_obsidian3 = require("obsidian");
var MAX_CRUID_CACHE_SIZE = 1e4;
var CruidCache = class {
  app;
  logger;
  cruidToFile = /* @__PURE__ */ new Map();
  pathToCruid = /* @__PURE__ */ new Map();
  eventRefs = [];
  deleteListeners = [];
  started = false;
  registerEventFn;
  constructor(app, logger, registerEventFn) {
    this.app = app;
    this.logger = logger;
    this.registerEventFn = registerEventFn ?? null;
  }
  /**
   * 启动缓存：注册事件监听器并触发一次全量构建
   * 优先使用 registerEventFn（Obsidian 自动清理），否则回退到手动 offref
   */
  start(options = {}) {
    if (this.started) {
      return;
    }
    this.started = true;
    const metaRef = this.app.metadataCache.on("changed", (file) => {
      if (!(file instanceof import_obsidian3.TFile) || file.extension !== "md") {
        return;
      }
      void this.upsertFromFile(file, options);
    });
    this.registerOrTrackEvent("metadata", metaRef);
    const deleteRef = this.app.vault.on("delete", (file) => {
      if (!(file instanceof import_obsidian3.TFile) || file.extension !== "md") {
        return;
      }
      this.removeByFile(file);
    });
    this.registerOrTrackEvent("vault", deleteRef);
    const renameRef = this.app.vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian3.TFile) || file.extension !== "md") {
        return;
      }
      const known = this.pathToCruid.get(oldPath);
      if (known) {
        this.pathToCruid.delete(oldPath);
        this.pathToCruid.set(file.path, known);
        this.cruidToFile.set(known, file);
        return;
      }
      void this.upsertFromFile(file, options);
    });
    this.registerOrTrackEvent("vault", renameRef);
    void this.buildCache(options);
  }
  /**
   * 注册事件：优先通过 Plugin.registerEvent() 注册（自动清理），
   * 否则回退到手动追踪 + dispose() 清理
   */
  registerOrTrackEvent(target, ref) {
    if (this.registerEventFn) {
      this.registerEventFn(ref);
    } else {
      this.eventRefs.push({ target, ref });
    }
  }
  /**
   * 停止缓存：取消事件监听
   * 若事件通过 registerEventFn 注册，则由 Plugin 自动清理，此处仅清理手动追踪的事件
   */
  dispose() {
    for (const item of this.eventRefs) {
      if (item.target === "metadata") {
        this.app.metadataCache.offref(item.ref);
      } else {
        this.app.vault.offref(item.ref);
      }
    }
    this.eventRefs = [];
    this.deleteListeners = [];
    this.started = false;
  }
  /**
   * 启动时扫描所有 Markdown 文件构建缓存
   * 使用分块处理，块之间让出事件循环，避免阻塞 UI
   */
  async buildCache(options = {}) {
    this.cruidToFile.clear();
    this.pathToCruid.clear();
    const files = this.app.vault.getMarkdownFiles();
    const CHUNK_SIZE = 100;
    for (let i = 0; i < files.length; i += CHUNK_SIZE) {
      const chunk = files.slice(i, i + CHUNK_SIZE);
      for (const file of chunk) {
        await this.upsertFromFile(file, options);
      }
      if (i + CHUNK_SIZE < files.length) {
        await new Promise((resolve) => setTimeout(resolve, 0));
      }
    }
    this.logger?.info("CruidCache", "CruidCache \u6784\u5EFA\u5B8C\u6210", {
      totalMarkdownFiles: files.length,
      cachedCruids: this.cruidToFile.size
    });
  }
  /**
   * 通过 cruid 获取文件
   */
  getFile(cruid) {
    return this.cruidToFile.get(cruid) ?? null;
  }
  /**
   * 通过 cruid 获取路径
   */
  getPath(cruid) {
    const file = this.getFile(cruid);
    return file ? file.path : null;
  }
  /**
   * 通过 cruid 获取名称（使用文件名，确保与重命名保持一致）
   */
  getName(cruid) {
    const file = this.getFile(cruid);
    return file ? file.basename : null;
  }
  /**
   * 通过 path 获取 cruid（用于清理/诊断）
   */
  getCruidByPath(path) {
    return this.pathToCruid.get(path) ?? null;
  }
  has(cruid) {
    return this.cruidToFile.has(cruid);
  }
  /**
   * 订阅删除事件（用于清理向量索引/重复对等关联数据）
   */
  onDelete(listener) {
    this.deleteListeners.push(listener);
    return () => {
      const idx = this.deleteListeners.indexOf(listener);
      if (idx >= 0) {
        this.deleteListeners.splice(idx, 1);
      }
    };
  }
  removeByFile(file) {
    const cruid = this.pathToCruid.get(file.path);
    if (!cruid) {
      return;
    }
    for (const listener of this.deleteListeners) {
      try {
        listener({ cruid, path: file.path });
      } catch (error) {
        this.logger?.warn("CruidCache", "\u5220\u9664\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", {
          cruid,
          path: file.path,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    this.pathToCruid.delete(file.path);
    const existing = this.cruidToFile.get(cruid);
    if (existing && existing.path === file.path) {
      this.cruidToFile.delete(cruid);
    }
    this.logger?.info("CruidCache", "\u5DF2\u79FB\u9664\u5DF2\u5220\u9664\u6587\u4EF6\u7684 cruid \u6620\u5C04", {
      cruid,
      path: file.path
    });
  }
  async upsertFromFile(file, options) {
    const cruid = this.getCruidFromMetadata(file) ?? (options.fallbackToRead ? await this.getCruidFromFileContent(file) : null);
    if (!cruid) {
      return;
    }
    const previousCruid = this.pathToCruid.get(file.path);
    if (previousCruid && previousCruid !== cruid) {
      const mapped = this.cruidToFile.get(previousCruid);
      if (mapped && mapped.path === file.path) {
        this.cruidToFile.delete(previousCruid);
      }
    }
    const existingFile = this.cruidToFile.get(cruid);
    if (existingFile && existingFile.path !== file.path) {
      this.logger?.warn("CruidCache", "\u68C0\u6D4B\u5230\u91CD\u590D cruid\uFF0C\u5DF2\u7528\u6700\u65B0\u6587\u4EF6\u8986\u76D6", {
        cruid,
        previousPath: existingFile.path,
        newPath: file.path
      });
    }
    if (!this.cruidToFile.has(cruid) && this.cruidToFile.size >= MAX_CRUID_CACHE_SIZE) {
      this.evictOldest();
    }
    this.cruidToFile.set(cruid, file);
    this.pathToCruid.set(file.path, cruid);
  }
  /**
   * 驱逐最早插入的缓存条目（Map 迭代顺序 = 插入顺序）
   * 当缓存超出 MAX_CRUID_CACHE_SIZE 时调用（需求 24.3）
   */
  evictOldest() {
    const firstKey = this.cruidToFile.keys().next().value;
    if (firstKey === void 0) return;
    const file = this.cruidToFile.get(firstKey);
    this.cruidToFile.delete(firstKey);
    if (file) {
      this.pathToCruid.delete(file.path);
    }
  }
  getCruidFromMetadata(file) {
    const cache = this.app.metadataCache.getFileCache(file);
    const fm = cache?.frontmatter;
    if (!fm) {
      return null;
    }
    const raw = typeof fm.cruid === "string" ? fm.cruid : typeof fm.crUid === "string" ? fm.crUid : null;
    if (!raw) {
      return null;
    }
    return raw.trim() || null;
  }
  async getCruidFromFileContent(file) {
    try {
      const content = await this.app.vault.cachedRead(file);
      const extracted = extractFrontmatter(content);
      const cruid = extracted?.frontmatter?.cruid;
      return cruid ? cruid.trim() : null;
    } catch (error) {
      this.logger?.warn("CruidCache", "\u8BFB\u53D6\u6587\u4EF6\u5185\u5BB9\u89E3\u6790 cruid \u5931\u8D25", {
        path: file.path,
        error: error instanceof Error ? error.message : String(error)
      });
      return null;
    }
  }
};

// src/core/vector-index.ts
var VectorIndex = class {
  fileStorage;
  logger;
  model;
  dimension;
  cruidCache;
  registerIntervalFn;
  // 元数据索引（轻量级，始终在内存中）
  indexMeta = null;
  // 按类型分桶的向量缓存（按需加载）
  buckets = /* @__PURE__ */ new Map();
  // 单条向量缓存（upsert 后立即可用，不依赖桶加载）
  recentVectors = /* @__PURE__ */ new Map();
  /** recentVectors 最大容量（防止内存无限增长，需求 24.3） */
  maxRecentVectors = 500;
  // TTL 配置（默认 5 分钟）
  ttlMs = 5 * 60 * 1e3;
  // 驱逐定时器 ID
  evictionTimer = null;
  /** 构造函数 */
  constructor(fileStorage, model = "text-embedding-3-small", dimension = 1536, logger = null, cruidCache = null, registerIntervalFn = null) {
    this.fileStorage = fileStorage;
    this.logger = logger;
    this.model = model;
    this.dimension = dimension;
    this.cruidCache = cruidCache;
    this.registerIntervalFn = registerIntervalFn;
  }
  /**
   * 加载索引元数据（不加载向量文件）
   *
   * @see 需求 16.1 — 启动时仅加载元数据
   */
  async load() {
    try {
      const ensureDirResult = await this.fileStorage.ensureDir(VECTORS_DIR);
      if (!ensureDirResult.ok) {
        return ensureDirResult;
      }
      const types = ["Domain", "Issue", "Theory", "Entity", "Mechanism"];
      for (const type of types) {
        const typeDirResult = await this.fileStorage.ensureDir(`${VECTORS_DIR}/${type}`);
        if (!typeDirResult.ok) {
          return typeDirResult;
        }
      }
      const metaResult = await this.fileStorage.readVectorIndexMeta();
      if (!metaResult.ok) {
        this.indexMeta = { ...DEFAULT_VECTOR_INDEX_META };
        this.indexMeta.embeddingModel = this.model;
        this.indexMeta.dimensions = this.dimension;
        const saveResult = await this.saveIndexMeta();
        if (!saveResult.ok) {
          return saveResult;
        }
        this.startEvictionTimer();
        return ok(void 0);
      }
      this.indexMeta = metaResult.value;
      const configResult = await this.ensureEmbeddingConfigConsistency();
      if (!configResult.ok) {
        return configResult;
      }
      const migrationResult = await this.migrateMetaSchema();
      if (!migrationResult.ok) {
        this.logger?.warn("VectorIndex", "\u8FC1\u79FB\u65E7\u683C\u5F0F\u6570\u636E\u65F6\u51FA\u73B0\u8B66\u544A", {
          error: migrationResult.error
        });
      }
      this.startEvictionTimer();
      return ok(void 0);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to load vector index",
        error
      );
    }
  }
  /**
   * 按需加载指定类型的向量桶
   *
   * 如果桶已在内存中，更新 lastAccessedAt 并直接返回。
   * 否则从文件系统加载该类型的所有向量文件。
   *
   * @see 需求 16.2 — 按需加载
   * @see 需求 16.4 — 加载失败返回错误并记录日志
   */
  async ensureBucketLoaded(type) {
    const existing = this.buckets.get(type);
    if (existing) {
      existing.lastAccessedAt = Date.now();
      return ok(existing);
    }
    const vectorsResult = await this.loadVectorsByType(type);
    if (!vectorsResult.ok) {
      this.logger?.warn("VectorIndex", `\u6309\u9700\u52A0\u8F7D\u7C7B\u578B ${type} \u7684\u5411\u91CF\u6876\u5931\u8D25`, {
        type,
        error: vectorsResult.error.message
      });
      return vectorsResult;
    }
    const now2 = Date.now();
    const bucket = {
      type,
      vectors: vectorsResult.value,
      loadedAt: now2,
      lastAccessedAt: now2
    };
    this.buckets.set(type, bucket);
    this.logger?.debug("VectorIndex", `\u7C7B\u578B ${type} \u7684\u5411\u91CF\u6876\u5DF2\u6309\u9700\u52A0\u8F7D`, {
      type,
      vectorCount: bucket.vectors.length
    });
    return ok(bucket);
  }
  /**
   * TTL 驱逐：清除超时未访问的向量桶
   *
   * @see 需求 16.3 — 一定时间内未访问时释放内存
   */
  evictStale() {
    const now2 = Date.now();
    for (const [type, bucket] of this.buckets) {
      if (now2 - bucket.lastAccessedAt > this.ttlMs) {
        this.buckets.delete(type);
        this.logger?.debug("VectorIndex", `\u7C7B\u578B ${type} \u7684\u5411\u91CF\u6876\u5DF2\u9A71\u9010\uFF08TTL \u8FC7\u671F\uFF09`, {
          type,
          lastAccessedAt: bucket.lastAccessedAt,
          ttlMs: this.ttlMs
        });
      }
    }
  }
  /**
   * 启动 TTL 驱逐定时器
   * 优先使用 registerInterval（Obsidian 自动清理），否则回退到 window.setInterval
   */
  startEvictionTimer() {
    if (this.evictionTimer !== null) return;
    const callback = () => this.evictStale();
    const intervalMs = 60 * 1e3;
    if (this.registerIntervalFn) {
      this.evictionTimer = this.registerIntervalFn(callback, intervalMs);
    } else {
      this.evictionTimer = window.setInterval(callback, intervalMs);
    }
  }
  /**
   * embedding 模型/维度一致性检查
   *
   * 重构后行为（需求 16.5）：
   * - 模型或维度不匹配时标记 needsRebuild = true，记录警告
   * - 不再静默覆盖当前配置，而是保留当前配置并提示用户重建
   * - 元数据中缺少模型/维度信息时，写入当前配置（首次初始化场景）
   */
  async ensureEmbeddingConfigConsistency() {
    if (!this.indexMeta) {
      return ok(void 0);
    }
    let needsSave = false;
    const metaDimensions = typeof this.indexMeta.dimensions === "number" && Number.isFinite(this.indexMeta.dimensions) && this.indexMeta.dimensions > 0 ? Math.floor(this.indexMeta.dimensions) : void 0;
    const metaModel = typeof this.indexMeta.embeddingModel === "string" && this.indexMeta.embeddingModel.trim().length > 0 ? this.indexMeta.embeddingModel.trim() : void 0;
    if (metaModel && metaModel !== this.model) {
      this.logger?.warn("VectorIndex", "\u68C0\u6D4B\u5230 embedding \u6A21\u578B\u4E0D\u4E00\u81F4\uFF0C\u7D22\u5F15\u9700\u8981\u91CD\u5EFA", {
        configured: this.model,
        indexed: metaModel
      });
      this.indexMeta.needsRebuild = true;
      needsSave = true;
    }
    if (metaDimensions !== void 0 && metaDimensions !== this.dimension) {
      this.logger?.warn("VectorIndex", "\u68C0\u6D4B\u5230 embedding \u7EF4\u5EA6\u4E0D\u4E00\u81F4\uFF0C\u7D22\u5F15\u9700\u8981\u91CD\u5EFA", {
        configured: this.dimension,
        indexed: metaDimensions
      });
      this.indexMeta.needsRebuild = true;
      needsSave = true;
    }
    if (!metaModel) {
      this.indexMeta.embeddingModel = this.model;
      needsSave = true;
    }
    if (metaDimensions === void 0) {
      this.indexMeta.dimensions = this.dimension;
      needsSave = true;
    }
    if (needsSave) {
      return this.saveIndexMeta();
    }
    return ok(void 0);
  }
  /**
   * 迁移索引元数据结构（删除冗余字段，修复旧字段命名）
   *
   * 目标：ConceptMeta 中不再保存 name/notePath；向量文件不再保存 name。
   */
  async migrateMetaSchema() {
    if (!this.indexMeta) {
      return ok(void 0);
    }
    let needsSave = false;
    const migratedConceptIds = [];
    for (const [uid, meta] of Object.entries(this.indexMeta.concepts)) {
      const legacyMeta = meta;
      let migrated = false;
      if (typeof legacyMeta.filePath === "string" && typeof legacyMeta.vectorFilePath !== "string") {
        legacyMeta.vectorFilePath = legacyMeta.filePath;
        delete legacyMeta.filePath;
        migrated = true;
      }
      if ("name" in legacyMeta) {
        delete legacyMeta.name;
        migrated = true;
      }
      if ("notePath" in legacyMeta) {
        delete legacyMeta.notePath;
        migrated = true;
      }
      if (typeof legacyMeta.id !== "string") {
        legacyMeta.id = uid;
        migrated = true;
      }
      if (typeof legacyMeta.vectorFilePath !== "string") {
        const type = typeof legacyMeta.type === "string" ? legacyMeta.type : "Entity";
        legacyMeta.vectorFilePath = `${type}/${uid}.json`;
        migrated = true;
      }
      if (migrated) {
        needsSave = true;
        migratedConceptIds.push(uid);
      }
    }
    if (needsSave) {
      this.indexMeta.version = "3.0";
      this.logger?.info("VectorIndex", `\u5411\u91CF\u7D22\u5F15\u5143\u6570\u636E\u5DF2\u8FC1\u79FB\uFF0C\u5171 ${migratedConceptIds.length} \u4E2A\u6761\u76EE`, {
        migratedCount: migratedConceptIds.length
      });
      const saveResult = await this.saveIndexMeta();
      if (!saveResult.ok) {
        return saveResult;
      }
    }
    return ok(void 0);
  }
  /** 添加或更新向量条目 */
  async upsert(entry) {
    try {
      if (!this.indexMeta) {
        return err("E310_INVALID_STATE", "\u5411\u91CF\u7D22\u5F15\u672A\u52A0\u8F7D");
      }
      if (entry.embedding.length !== this.dimension) {
        return err(
          "E305_VECTOR_MISMATCH",
          `Invalid embedding dimension: expected ${this.dimension}, got ${entry.embedding.length}`,
          { expected: this.dimension, actual: entry.embedding.length }
        );
      }
      const now2 = Date.now();
      const isUpdate = entry.uid in this.indexMeta.concepts;
      const normalizedEmbedding = this.normalize(entry.embedding);
      const conceptVector = {
        id: entry.uid,
        type: entry.type,
        embedding: normalizedEmbedding,
        metadata: {
          createdAt: isUpdate ? this.indexMeta.concepts[entry.uid]?.lastModified || now2 : now2,
          updatedAt: now2,
          embeddingModel: this.model,
          dimensions: this.dimension
        }
      };
      const writeResult = await this.fileStorage.writeVectorFile(
        entry.type,
        entry.uid,
        conceptVector
      );
      if (!writeResult.ok) {
        return writeResult;
      }
      const oldType = this.indexMeta.concepts[entry.uid]?.type;
      if (isUpdate && oldType && oldType !== entry.type) {
        await this.fileStorage.deleteVectorFile(oldType, entry.uid);
        this.indexMeta.stats.byType[oldType]--;
        this.indexMeta.stats.byType[entry.type]++;
        this.buckets.delete(oldType);
      } else if (!isUpdate) {
        this.indexMeta.stats.totalConcepts++;
        this.indexMeta.stats.byType[entry.type]++;
      }
      this.indexMeta.concepts[entry.uid] = {
        id: entry.uid,
        type: entry.type,
        vectorFilePath: `${entry.type}/${entry.uid}.json`,
        lastModified: now2,
        hasEmbedding: true
      };
      this.indexMeta.lastUpdated = now2;
      this.setRecentVector(entry.uid, conceptVector);
      this.buckets.delete(entry.type);
      const saveResult = await this.saveIndexMeta();
      if (!saveResult.ok) {
        return saveResult;
      }
      return ok(void 0);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to upsert vector entry",
        error
      );
    }
  }
  /** 删除向量条目 */
  async delete(uid) {
    try {
      if (!this.indexMeta) {
        return err("E310_INVALID_STATE", "\u5411\u91CF\u7D22\u5F15\u672A\u52A0\u8F7D");
      }
      const meta = this.indexMeta.concepts[uid];
      if (!meta) {
        return err(
          "E311_NOT_FOUND",
          `Vector entry not found: ${uid}`,
          { uid }
        );
      }
      const deleteResult = await this.fileStorage.deleteVectorFile(meta.type, uid);
      if (!deleteResult.ok) {
        return deleteResult;
      }
      const deletedType = meta.type;
      delete this.indexMeta.concepts[uid];
      this.indexMeta.stats.totalConcepts--;
      this.indexMeta.stats.byType[deletedType]--;
      this.indexMeta.lastUpdated = Date.now();
      this.recentVectors.delete(uid);
      this.buckets.delete(deletedType);
      const saveResult = await this.saveIndexMeta();
      if (!saveResult.ok) {
        return saveResult;
      }
      return ok(void 0);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to delete vector entry",
        error
      );
    }
  }
  /**
   * 搜索相似概念（同类型桶内检索）
   * 内部通过 ensureBucketLoaded 按需加载向量
   */
  async search(type, embedding, topK) {
    try {
      if (!this.indexMeta) {
        return err("E310_INVALID_STATE", "\u5411\u91CF\u7D22\u5F15\u672A\u52A0\u8F7D");
      }
      if (embedding.length !== this.dimension) {
        return err(
          "E305_VECTOR_MISMATCH",
          `Invalid embedding dimension: expected ${this.dimension}, got ${embedding.length}`,
          { expected: this.dimension, actual: embedding.length }
        );
      }
      const normalizedQuery = this.normalize(embedding);
      const bucketResult = await this.ensureBucketLoaded(type);
      if (!bucketResult.ok) {
        return bucketResult;
      }
      const vectors = bucketResult.value.vectors;
      const topResults = [];
      for (const vector of vectors) {
        const similarity = this.dotProduct(normalizedQuery, vector.embedding);
        if (topResults.length < topK) {
          topResults.push({ vector, similarity });
          topResults.sort((a, b) => b.similarity - a.similarity);
        } else if (similarity > topResults[topResults.length - 1].similarity) {
          topResults[topResults.length - 1] = { vector, similarity };
          topResults.sort((a, b) => b.similarity - a.similarity);
        }
      }
      const searchResults = topResults.map((r2) => ({
        uid: r2.vector.id,
        similarity: r2.similarity,
        name: this.cruidCache?.getName(r2.vector.id) || r2.vector.id,
        path: this.cruidCache?.getPath(r2.vector.id) || ""
      }));
      return ok(searchResults);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to search vector index",
        error
      );
    }
  }
  /**
   * 搜索相似概念（同类型桶内检索，按阈值全量过滤）
   * 内部通过 ensureBucketLoaded 按需加载向量
   */
  async searchAboveThreshold(type, embedding, threshold) {
    try {
      if (!this.indexMeta) {
        return err("E310_INVALID_STATE", "\u5411\u91CF\u7D22\u5F15\u672A\u52A0\u8F7D");
      }
      if (Number.isNaN(threshold) || threshold < 0 || threshold > 1) {
        return err("E101_INVALID_INPUT", `\u65E0\u6548\u7684\u76F8\u4F3C\u5EA6\u9608\u503C: ${threshold}`, { threshold });
      }
      if (embedding.length !== this.dimension) {
        return err(
          "E305_VECTOR_MISMATCH",
          `Invalid embedding dimension: expected ${this.dimension}, got ${embedding.length}`,
          { expected: this.dimension, actual: embedding.length }
        );
      }
      const normalizedQuery = this.normalize(embedding);
      const bucketResult = await this.ensureBucketLoaded(type);
      if (!bucketResult.ok) {
        return bucketResult;
      }
      const vectors = bucketResult.value.vectors;
      const matched = [];
      for (const vector of vectors) {
        const similarity = this.dotProduct(normalizedQuery, vector.embedding);
        if (similarity > threshold) {
          matched.push({ vector, similarity });
        }
      }
      matched.sort((a, b) => b.similarity - a.similarity);
      const searchResults = matched.map((r2) => ({
        uid: r2.vector.id,
        similarity: r2.similarity,
        name: this.cruidCache?.getName(r2.vector.id) || r2.vector.id,
        path: this.cruidCache?.getPath(r2.vector.id) || ""
      }));
      return ok(searchResults);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        "Failed to search vector index",
        error
      );
    }
  }
  /** 获取索引统计信息 */
  getStats() {
    if (!this.indexMeta) {
      return {
        totalEntries: 0,
        byType: {
          Domain: 0,
          Issue: 0,
          Theory: 0,
          Entity: 0,
          Mechanism: 0
        },
        lastUpdated: formatCRTimestamp()
      };
    }
    return {
      totalEntries: this.indexMeta.stats.totalConcepts,
      byType: { ...this.indexMeta.stats.byType },
      lastUpdated: formatCRTimestamp(new Date(this.indexMeta.lastUpdated))
    };
  }
  /** 当前索引使用的 embedding 模型（Runtime SSOT） */
  getEmbeddingModel() {
    return this.model;
  }
  /** 当前索引使用的 embedding 维度（Runtime SSOT） */
  getEmbeddingDimension() {
    return this.dimension;
  }
  /** 索引是否需要重建（模型/维度不匹配时为 true） */
  getNeedsRebuild() {
    return this.indexMeta?.needsRebuild === true;
  }
  /** 根据 UID 获取条目（用于复用已有向量） */
  getEntry(uid) {
    if (!this.indexMeta) {
      return void 0;
    }
    const meta = this.indexMeta.concepts[uid];
    if (!meta) {
      return void 0;
    }
    const cached = this.recentVectors.get(uid);
    if (cached) {
      return {
        uid: cached.id,
        type: cached.type,
        embedding: cached.embedding,
        updated: formatCRTimestamp(new Date(cached.metadata.updatedAt))
      };
    }
    return void 0;
  }
  /**
   * 获取指定类型的所有向量（按需加载桶）
   * 用于 DuplicateManager 分页检测
   */
  async getVectorsByType(type) {
    try {
      const bucketResult = await this.ensureBucketLoaded(type);
      if (!bucketResult.ok) {
        return bucketResult;
      }
      return ok([...bucketResult.value.vectors]);
    } catch (error) {
      return err("E500_INTERNAL_ERROR", `\u83B7\u53D6\u7C7B\u578B ${type} \u7684\u5411\u91CF\u5931\u8D25`, error);
    }
  }
  /** 延迟加载：按类型加载向量（内部方法，被 ensureBucketLoaded 调用） */
  async loadVectorsByType(type) {
    try {
      if (!this.indexMeta) {
        return err("E310_INVALID_STATE", "\u5411\u91CF\u7D22\u5F15\u672A\u52A0\u8F7D");
      }
      const vectors = [];
      const conceptMetas = Object.values(this.indexMeta.concepts).filter(
        (meta) => meta.type === type
      );
      for (const meta of conceptMetas) {
        let vector = this.recentVectors.get(meta.id);
        if (!vector) {
          const readResult = await this.fileStorage.readVectorFile(type, meta.id);
          if (readResult.ok) {
            vector = readResult.value;
            this.setRecentVector(meta.id, vector);
          } else {
            const error = readResult;
            this.logger?.warn("VectorIndex", `\u52A0\u8F7D\u5411\u91CF\u6587\u4EF6\u5931\u8D25: ${meta.id}`, {
              conceptId: meta.id,
              error: error.error.message
            });
            continue;
          }
        }
        vectors.push(vector);
      }
      return ok(vectors);
    } catch (error) {
      return err(
        "E500_INTERNAL_ERROR",
        `Failed to load vectors for type: ${type}`,
        error
      );
    }
  }
  /** 保存元数据索引 */
  async saveIndexMeta() {
    if (!this.indexMeta) {
      return err("E310_INVALID_STATE", "Index meta not initialized");
    }
    const writeResult = await this.fileStorage.writeVectorIndexMeta(this.indexMeta);
    if (!writeResult.ok) {
      return writeResult;
    }
    return ok(void 0);
  }
  /**
   * 归一化向量
   * @param vector 原始向量
   * @returns 归一化后的向量（模长为 1）
   */
  normalize(vector) {
    let norm = 0;
    for (let i = 0; i < vector.length; i++) {
      norm += vector[i] * vector[i];
    }
    norm = Math.sqrt(norm);
    if (norm === 0) {
      return vector;
    }
    const normalized = new Array(vector.length);
    for (let i = 0; i < vector.length; i++) {
      normalized[i] = vector[i] / norm;
    }
    return normalized;
  }
  /**
   * 计算点积（用于归一化向量的相似度计算）
   * 对于归一化向量，点积等于余弦相似度
   */
  dotProduct(a, b) {
    if (a.length !== b.length) {
      throw new Error("Vectors must have the same dimension");
    }
    let product = 0;
    for (let i = 0; i < a.length; i++) {
      product += a[i] * b[i];
    }
    return product;
  }
  /** 释放资源：清除定时器和缓存 */
  dispose() {
    if (this.evictionTimer !== null) {
      clearInterval(this.evictionTimer);
      this.evictionTimer = null;
    }
    this.buckets.clear();
    this.recentVectors.clear();
  }
  /**
   * 向 recentVectors 缓存写入条目，超出容量时驱逐最早插入的条目
   * Map 迭代顺序 = 插入顺序（需求 24.3）
   */
  setRecentVector(uid, vector) {
    if (this.recentVectors.has(uid)) {
      this.recentVectors.delete(uid);
    } else if (this.recentVectors.size >= this.maxRecentVectors) {
      const firstKey = this.recentVectors.keys().next().value;
      if (firstKey !== void 0) {
        this.recentVectors.delete(firstKey);
      }
    }
    this.recentVectors.set(uid, vector);
  }
};

// src/core/lock-manager.ts
var SimpleLockManager = class {
  processingCruids = /* @__PURE__ */ new Set();
  tryAcquire(cruid) {
    if (this.processingCruids.has(cruid)) {
      return false;
    }
    this.processingCruids.add(cruid);
    return true;
  }
  release(cruid) {
    this.processingCruids.delete(cruid);
  }
  isLocked(cruid) {
    return this.processingCruids.has(cruid);
  }
  clear() {
    this.processingCruids.clear();
  }
};

// src/core/undo-manager.ts
var import_crypto = require("crypto");
var UndoManager = class {
  fileStorage;
  logger;
  snapshotsDir;
  indexPath;
  maxSnapshots;
  maxAgeDays;
  index;
  MAX_SNAPSHOT_SIZE = 10 * 1024 * 1024;
  // 10MB 防止 OOM
  constructor(fileStorage, logger, snapshotsDir = "data/snapshots", maxSnapshots = 100, maxAgeDays = 30) {
    this.fileStorage = fileStorage;
    this.logger = logger;
    this.snapshotsDir = snapshotsDir;
    this.indexPath = `${snapshotsDir}/index.json`;
    this.maxSnapshots = maxSnapshots;
    this.maxAgeDays = maxAgeDays;
    this.index = null;
    this.logger.debug("UndoManager", "UndoManager \u521D\u59CB\u5316\u5B8C\u6210", {
      snapshotsDir,
      maxSnapshots,
      maxAgeDays
    });
  }
  /** 更新保留策略配置 */
  updateRetentionPolicy(maxSnapshots, maxAgeDays) {
    if (maxSnapshots !== void 0) {
      this.maxSnapshots = maxSnapshots;
    }
    if (maxAgeDays !== void 0) {
      this.maxAgeDays = maxAgeDays;
    }
    if (this.index) {
      this.index.retentionPolicy = {
        maxCount: this.maxSnapshots,
        maxAgeDays: this.maxAgeDays
      };
      this.saveIndex().catch((err2) => {
        this.logger.error("UndoManager", "\u4FDD\u5B58\u4FDD\u7559\u7B56\u7565\u5931\u8D25", err2);
      });
    }
    this.logger.info("UndoManager", "\u4FDD\u7559\u7B56\u7565\u5DF2\u66F4\u65B0", {
      maxSnapshots: this.maxSnapshots,
      maxAgeDays: this.maxAgeDays
    });
  }
  /** 初始化撤销管理器 */
  async initialize() {
    try {
      const dirResult = await this.fileStorage.ensureDir(this.snapshotsDir);
      if (!dirResult.ok) {
        return dirResult;
      }
      const indexExists = await this.fileStorage.exists(this.indexPath);
      if (indexExists) {
        const readResult = await this.fileStorage.read(this.indexPath);
        if (!readResult.ok) {
          this.logger.warn("UndoManager", "\u8BFB\u53D6\u5FEB\u7167\u7D22\u5F15\u5931\u8D25\uFF0C\u521B\u5EFA\u65B0\u7D22\u5F15", {
            error: readResult.error
          });
          this.index = this.createEmptyIndex();
          const writeResult = await this.saveIndex();
          if (!writeResult.ok) {
            return writeResult;
          }
          return ok(void 0);
        }
        try {
          this.index = JSON.parse(readResult.value);
          this.logger.info("UndoManager", "\u5FEB\u7167\u7D22\u5F15\u52A0\u8F7D\u6210\u529F", {
            snapshotCount: this.index.snapshots.length
          });
        } catch (parseError) {
          this.logger.warn("UndoManager", "\u89E3\u6790\u5FEB\u7167\u7D22\u5F15\u5931\u8D25\uFF0C\u521B\u5EFA\u65B0\u7D22\u5F15", {
            error: parseError
          });
          this.index = this.createEmptyIndex();
          const writeResult = await this.saveIndex();
          if (!writeResult.ok) {
            return writeResult;
          }
        }
      } else {
        this.index = this.createEmptyIndex();
        const writeResult = await this.saveIndex();
        if (!writeResult.ok) {
          return writeResult;
        }
        this.logger.info("UndoManager", "\u521B\u5EFA\u65B0\u7684\u5FEB\u7167\u7D22\u5F15");
      }
      return ok(void 0);
    } catch (error) {
      this.logger.error("UndoManager", "\u521D\u59CB\u5316\u5931\u8D25", error);
      return err("E304_SNAPSHOT_FAILED", "\u521D\u59CB\u5316\u64A4\u9500\u7BA1\u7406\u5668\u5931\u8D25", error);
    }
  }
  /** 创建快照 */
  async createSnapshot(filePath, content, taskId, nodeId) {
    try {
      if (!this.index) {
        return err("E310_INVALID_STATE", "\u64A4\u9500\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      if (!filePath || typeof filePath !== "string") {
        return err("E102_MISSING_FIELD", "\u6587\u4EF6\u8DEF\u5F84\u4E0D\u80FD\u4E3A\u7A7A");
      }
      if (content === void 0 || content === null) {
        return err("E102_MISSING_FIELD", "\u6587\u4EF6\u5185\u5BB9\u4E0D\u80FD\u4E3A\u7A7A");
      }
      if (!taskId || typeof taskId !== "string") {
        return err("E102_MISSING_FIELD", "\u4EFB\u52A1 ID \u4E0D\u80FD\u4E3A\u7A7A");
      }
      this.validateFilePath(filePath);
      const fileSize = Buffer.byteLength(content, "utf8");
      if (fileSize > this.MAX_SNAPSHOT_SIZE) {
        return err("E101_INVALID_INPUT", `\u5FEB\u7167\u5185\u5BB9\u8FC7\u5927: ${fileSize} bytes (\u6700\u5927 ${this.MAX_SNAPSHOT_SIZE} bytes)`);
      }
      const snapshotId = this.generateSnapshotId();
      const checksum = this.calculateChecksum(content);
      const resolvedNodeId = nodeId || this.extractNodeIdFromPath(filePath);
      const snapshot2 = {
        id: snapshotId,
        nodeId: resolvedNodeId,
        taskId,
        path: filePath,
        content,
        created: formatCRTimestamp(),
        fileSize,
        checksum
      };
      this.validateSnapshotRecord(snapshot2);
      const snapshotPath = `${this.snapshotsDir}/${snapshotId}.json`;
      const writeResult = await this.fileStorage.write(
        snapshotPath,
        JSON.stringify(snapshot2, null, 2)
      );
      if (!writeResult.ok) {
        this.logger.error("UndoManager", "\u4FDD\u5B58\u5FEB\u7167\u6587\u4EF6\u5931\u8D25", void 0, {
          snapshotId,
          error: writeResult.error
        });
        return writeResult;
      }
      this.index.snapshots.push(snapshot2);
      if (this.index.snapshots.length > this.maxSnapshots) {
        await this.cleanupOldestSnapshots(this.index.snapshots.length - this.maxSnapshots);
      }
      const saveIndexResult = await this.saveIndex();
      if (!saveIndexResult.ok) {
        return saveIndexResult;
      }
      this.logger.info("UndoManager", `\u5FEB\u7167\u5DF2\u521B\u5EFA: ${snapshotId}`, {
        snapshotId,
        filePath,
        fileSize: snapshot2.fileSize,
        taskId
      });
      return ok(snapshotId);
    } catch (error) {
      this.logger.error("UndoManager", "\u521B\u5EFA\u5FEB\u7167\u5931\u8D25", error, {
        filePath,
        taskId
      });
      return toErr(error, "E304_SNAPSHOT_FAILED", "\u521B\u5EFA\u5FEB\u7167\u5931\u8D25");
    }
  }
  /** 恢复快照（仅读取，不写入文件） */
  async restoreSnapshot(snapshotId) {
    try {
      if (!this.index) {
        return err("E310_INVALID_STATE", "\u64A4\u9500\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const snapshotRecord = this.index.snapshots.find((s) => s.id === snapshotId);
      if (!snapshotRecord) {
        this.logger.warn("UndoManager", `\u5FEB\u7167\u4E0D\u5B58\u5728: ${snapshotId}`);
        return err("E311_NOT_FOUND", `\u5FEB\u7167\u4E0D\u5B58\u5728: ${snapshotId}`);
      }
      const snapshotPath = `${this.snapshotsDir}/${snapshotId}.json`;
      const readResult = await this.fileStorage.read(snapshotPath);
      if (!readResult.ok) {
        this.logger.error("UndoManager", "\u8BFB\u53D6\u5FEB\u7167\u6587\u4EF6\u5931\u8D25", void 0, {
          snapshotId,
          error: readResult.error
        });
        return readResult;
      }
      try {
        const snapshot2 = JSON.parse(readResult.value);
        const calculatedChecksum = this.calculateChecksum(snapshot2.content);
        if (calculatedChecksum !== snapshot2.checksum) {
          this.logger.error("UndoManager", "\u5FEB\u7167\u6821\u9A8C\u548C\u4E0D\u5339\u914D", void 0, {
            snapshotId,
            expected: snapshot2.checksum,
            actual: calculatedChecksum
          });
          return err("E500_INTERNAL_ERROR", "\u5FEB\u7167\u6587\u4EF6\u5DF2\u635F\u574F\uFF08\u6821\u9A8C\u548C\u4E0D\u5339\u914D\uFF09");
        }
        this.logger.info("UndoManager", `\u5FEB\u7167\u5DF2\u8BFB\u53D6: ${snapshotId}`, {
          snapshotId,
          path: snapshot2.path
        });
        return ok(snapshot2);
      } catch (parseError) {
        this.logger.error("UndoManager", "\u89E3\u6790\u5FEB\u7167\u6587\u4EF6\u5931\u8D25", parseError, {
          snapshotId
        });
        return err("E500_INTERNAL_ERROR", "\u89E3\u6790\u5FEB\u7167\u6587\u4EF6\u5931\u8D25", parseError);
      }
    } catch (error) {
      this.logger.error("UndoManager", "\u6062\u590D\u5FEB\u7167\u5931\u8D25", error, {
        snapshotId
      });
      return err("E304_SNAPSHOT_FAILED", "\u6062\u590D\u5FEB\u7167\u5931\u8D25", error);
    }
  }
  /** 恢复快照到文件（使用原子写入） */
  async restoreSnapshotToFile(snapshotId) {
    try {
      const snapshotResult = await this.restoreSnapshot(snapshotId);
      if (!snapshotResult.ok) {
        return snapshotResult;
      }
      const snapshot2 = snapshotResult.value;
      const atomicWriteResult = await this.fileStorage.atomicWrite(
        snapshot2.path,
        snapshot2.content
      );
      if (!atomicWriteResult.ok) {
        this.logger.error("UndoManager", "\u539F\u5B50\u5199\u5165\u6062\u590D\u5931\u8D25", void 0, {
          snapshotId,
          path: snapshot2.path,
          error: atomicWriteResult.error
        });
        return err("E304_SNAPSHOT_FAILED", `\u5FEB\u7167\u6062\u590D\u5931\u8D25: ${atomicWriteResult.error.message}`, atomicWriteResult.error);
      }
      this.logger.info("UndoManager", `\u5FEB\u7167\u5DF2\u6062\u590D\u5230\u6587\u4EF6: ${snapshotId}`, {
        snapshotId,
        path: snapshot2.path,
        fileSize: snapshot2.fileSize
      });
      return ok(snapshot2);
    } catch (error) {
      this.logger.error("UndoManager", "\u6062\u590D\u5FEB\u7167\u5230\u6587\u4EF6\u5931\u8D25", error, {
        snapshotId
      });
      return err("E304_SNAPSHOT_FAILED", "\u6062\u590D\u5FEB\u7167\u5230\u6587\u4EF6\u5931\u8D25", error);
    }
  }
  /** 删除快照 */
  async deleteSnapshot(snapshotId) {
    try {
      if (!this.index) {
        return err("E310_INVALID_STATE", "\u64A4\u9500\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const snapshotIndex = this.index.snapshots.findIndex((s) => s.id === snapshotId);
      if (snapshotIndex === -1) {
        this.logger.warn("UndoManager", `\u5FEB\u7167\u4E0D\u5B58\u5728: ${snapshotId}`);
        return err("E311_NOT_FOUND", `\u5FEB\u7167\u4E0D\u5B58\u5728: ${snapshotId}`);
      }
      const snapshotPath = `${this.snapshotsDir}/${snapshotId}.json`;
      const deleteResult = await this.fileStorage.delete(snapshotPath);
      if (!deleteResult.ok) {
        this.logger.error("UndoManager", "\u5220\u9664\u5FEB\u7167\u6587\u4EF6\u5931\u8D25", void 0, {
          snapshotId,
          error: deleteResult.error
        });
        return deleteResult;
      }
      this.index.snapshots.splice(snapshotIndex, 1);
      const saveIndexResult = await this.saveIndex();
      if (!saveIndexResult.ok) {
        return saveIndexResult;
      }
      this.logger.info("UndoManager", `\u5FEB\u7167\u5DF2\u5220\u9664: ${snapshotId}`);
      return ok(void 0);
    } catch (error) {
      this.logger.error("UndoManager", "\u5220\u9664\u5FEB\u7167\u5931\u8D25", error, {
        snapshotId
      });
      return err("E304_SNAPSHOT_FAILED", "\u5220\u9664\u5FEB\u7167\u5931\u8D25", error);
    }
  }
  /** 列出所有快照 */
  async listSnapshots() {
    try {
      if (!this.index) {
        return err("E310_INVALID_STATE", "\u64A4\u9500\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const metadata = this.index.snapshots.map((s) => ({
        id: s.id,
        nodeId: s.nodeId,
        taskId: s.taskId,
        path: s.path,
        created: s.created,
        fileSize: s.fileSize
      }));
      return ok(metadata);
    } catch (error) {
      this.logger.error("UndoManager", "\u5217\u51FA\u5FEB\u7167\u5931\u8D25", error);
      return err("E304_SNAPSHOT_FAILED", "\u5217\u51FA\u5FEB\u7167\u5931\u8D25", error);
    }
  }
  /** 清理过期快照 */
  async cleanupExpiredSnapshots(maxAgeMs) {
    try {
      if (!this.index) {
        return err("E310_INVALID_STATE", "\u64A4\u9500\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const now2 = Date.now();
      const expiredSnapshots = [];
      for (const snapshot2 of this.index.snapshots) {
        const createdTime = new Date(snapshot2.created.replace(" ", "T")).getTime();
        if (Number.isNaN(createdTime)) {
          continue;
        }
        if (now2 - createdTime > maxAgeMs) {
          expiredSnapshots.push(snapshot2.id);
        }
      }
      for (const snapshotId of expiredSnapshots) {
        await this.deleteSnapshot(snapshotId);
      }
      this.logger.info("UndoManager", `\u6E05\u7406\u8FC7\u671F\u5FEB\u7167\u5B8C\u6210\uFF0C\u5171 ${expiredSnapshots.length} \u4E2A`, {
        count: expiredSnapshots.length,
        maxAgeMs
      });
      return ok(expiredSnapshots.length);
    } catch (error) {
      this.logger.error("UndoManager", "\u6E05\u7406\u8FC7\u671F\u5FEB\u7167\u5931\u8D25", error);
      return err("E304_SNAPSHOT_FAILED", "\u6E05\u7406\u8FC7\u671F\u5FEB\u7167\u5931\u8D25", error);
    }
  }
  // 私有方法
  /** 创建空索引 */
  createEmptyIndex() {
    return {
      version: "1.0.0",
      snapshots: [],
      retentionPolicy: {
        maxCount: this.maxSnapshots,
        maxAgeDays: this.maxAgeDays
      }
    };
  }
  /**
   * 保存索引
   */
  async saveIndex() {
    if (!this.index) {
      return err("E310_INVALID_STATE", "\u7D22\u5F15\u672A\u521D\u59CB\u5316");
    }
    const writeResult = await this.fileStorage.write(
      this.indexPath,
      JSON.stringify(this.index, null, 2)
    );
    if (!writeResult.ok) {
      this.logger.error("UndoManager", "\u4FDD\u5B58\u5FEB\u7167\u7D22\u5F15\u5931\u8D25", void 0, {
        error: writeResult.error
      });
    }
    return writeResult;
  }
  /**
   * 生成快照 ID
   */
  generateSnapshotId() {
    return `snapshot-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * 计算内容校验和
   */
  calculateChecksum(content) {
    return (0, import_crypto.createHash)("sha256").update(content, "utf8").digest("hex");
  }
  /**
   * 验证文件路径，防止路径遍历 / 绝对路径 / 非 md 文件
   */
  validateFilePath(filePath) {
    if (filePath.includes("..")) {
      throw new CognitiveRazorError("E101_INVALID_INPUT", "\u6587\u4EF6\u8DEF\u5F84\u4E0D\u80FD\u5305\u542B '..'");
    }
    if (/^([A-Za-z]:|\\\\|\/)/.test(filePath)) {
      throw new CognitiveRazorError("E101_INVALID_INPUT", "\u6587\u4EF6\u8DEF\u5F84\u5FC5\u987B\u662F\u76F8\u5BF9\u8DEF\u5F84");
    }
    if (!filePath.endsWith(".md")) {
      throw new CognitiveRazorError("E101_INVALID_INPUT", "\u4EC5\u652F\u6301 Markdown \u6587\u4EF6\u5FEB\u7167 (.md)");
    }
  }
  /**
   * 从文件路径提取节点 ID
   * 这是一个简化实现，实际应该从文件的 frontmatter 中读取
   */
  extractNodeIdFromPath(filePath) {
    const fileName = filePath.split("/").pop() || "";
    return fileName.replace(/\.md$/, "");
  }
  /**
   * 验证快照记录完整性
   * Property 11: Snapshot Record Completeness
   * 快照记录必须包含所有必需字段: id, nodeId, taskId, path, content, created, fileSize, checksum
   */
  validateSnapshotRecord(snapshot2) {
    const requiredFields = [
      "id",
      "nodeId",
      "taskId",
      "path",
      "content",
      "created",
      "fileSize",
      "checksum"
    ];
    for (const field of requiredFields) {
      if (snapshot2[field] === void 0 || snapshot2[field] === null) {
        throw new CognitiveRazorError("E500_INTERNAL_ERROR", `\u5FEB\u7167\u8BB0\u5F55\u7F3A\u5C11\u5FC5\u9700\u5B57\u6BB5: ${field}`);
      }
    }
    if (typeof snapshot2.id !== "string" || snapshot2.id.length === 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u5FEB\u7167 ID \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
    }
    if (typeof snapshot2.nodeId !== "string" || snapshot2.nodeId.length === 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u8282\u70B9 ID \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
    }
    if (typeof snapshot2.taskId !== "string" || snapshot2.taskId.length === 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u4EFB\u52A1 ID \u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
    }
    if (typeof snapshot2.path !== "string" || snapshot2.path.length === 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6587\u4EF6\u8DEF\u5F84\u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
    }
    if (typeof snapshot2.content !== "string") {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6587\u4EF6\u5185\u5BB9\u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
    }
    if (typeof snapshot2.created !== "string" || snapshot2.created.length === 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u521B\u5EFA\u65F6\u95F4\u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
    }
    if (typeof snapshot2.fileSize !== "number" || snapshot2.fileSize < 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6587\u4EF6\u5927\u5C0F\u5FC5\u987B\u662F\u975E\u8D1F\u6570");
    }
    if (typeof snapshot2.checksum !== "string" || snapshot2.checksum.length === 0) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6821\u9A8C\u548C\u5FC5\u987B\u662F\u975E\u7A7A\u5B57\u7B26\u4E32");
    }
    const dateRegex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/;
    if (!dateRegex.test(snapshot2.created)) {
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u521B\u5EFA\u65F6\u95F4\u5FC5\u987B\u662F yyyy-MM-DD HH:mm:ss \u683C\u5F0F");
    }
  }
  /**
   * 清理最旧的快照
   */
  async cleanupOldestSnapshots(count) {
    if (!this.index || count <= 0) {
      return;
    }
    const sortedSnapshots = [...this.index.snapshots].sort((a, b) => {
      return new Date(a.created).getTime() - new Date(b.created).getTime();
    });
    const toDelete = sortedSnapshots.slice(0, count);
    for (const snapshot2 of toDelete) {
      await this.deleteSnapshot(snapshot2.id);
    }
    this.logger.info("UndoManager", `\u6E05\u7406\u6700\u65E7\u7684 ${count} \u4E2A\u5FEB\u7167`);
  }
  /** 清理所有快照 */
  async clearAllSnapshots() {
    try {
      if (!this.index) {
        return err("E310_INVALID_STATE", "\u64A4\u9500\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const count = this.index.snapshots.length;
      const snapshotIds = this.index.snapshots.map((s) => s.id);
      for (const snapshotId of snapshotIds) {
        await this.deleteSnapshot(snapshotId);
      }
      this.logger.info("UndoManager", `\u6E05\u7406\u4E86\u6240\u6709 ${count} \u4E2A\u5FEB\u7167`);
      return ok(count);
    } catch (error) {
      this.logger.error("UndoManager", "\u6E05\u7406\u6240\u6709\u5FEB\u7167\u5931\u8D25", error);
      return err("E304_SNAPSHOT_FAILED", "\u6E05\u7406\u6240\u6709\u5FEB\u7167\u5931\u8D25", error);
    }
  }
};

// src/core/retry-handler.ts
var MODEL_OUTPUT_ERROR_CONFIG = {
  maxAttempts: 3,
  strategy: "immediate"
};
var PROVIDER_ERROR_CONFIG = {
  maxAttempts: 5,
  strategy: "immediate"
};
var RetryHandler = class {
  logger;
  constructor(logger) {
    this.logger = logger;
  }
  /** 分类错误并决定重试策略 */
  classifyError(errorCode) {
    const category = getErrorCategory(errorCode);
    const retryable = isRetryableErrorCode(errorCode);
    if (category === "INPUT_VALIDATION") {
      return {
        category: "INPUT_ERROR",
        strategy: "no_retry",
        retryable: false,
        maxAttempts: 1
      };
    }
    if (category === "PROVIDER_AI") {
      const isModelOutputError = errorCode.startsWith("E210_") || errorCode.startsWith("E211_") || errorCode.startsWith("E212_");
      return {
        category: "PROVIDER_ERROR",
        strategy: "immediate",
        retryable,
        maxAttempts: isModelOutputError ? 3 : 5
      };
    }
    if (category === "SYSTEM_IO") {
      return {
        category: "SYSTEM_ERROR",
        strategy: "no_retry",
        retryable,
        maxAttempts: retryable ? 3 : 1
      };
    }
    if (category === "CONFIG") {
      return {
        category: "CONFIG_ERROR",
        strategy: "no_retry",
        retryable: false,
        maxAttempts: 1
      };
    }
    if (category === "INTERNAL") {
      return {
        category: "INTERNAL_ERROR",
        strategy: "no_retry",
        retryable: false,
        maxAttempts: 1
      };
    }
    return {
      category: "UNKNOWN",
      strategy: "no_retry",
      retryable: false,
      maxAttempts: 1
    };
  }
  /** 判断是否应该重试 */
  shouldRetry(error, currentAttempt) {
    const classification = this.classifyError(error.error.code);
    if (!classification.retryable) {
      return false;
    }
    if (currentAttempt >= classification.maxAttempts) {
      return false;
    }
    return true;
  }
  /** 计算重试等待时间 */
  calculateWaitTime(error, attempt, baseDelayMs = 1e3) {
    const classification = this.classifyError(error.error.code);
    if (classification.strategy === "immediate") {
      return 0;
    }
    if (classification.strategy === "exponential") {
      return this.calculateExponentialBackoff(attempt, baseDelayMs);
    }
    return 0;
  }
  /** 计算指数退避延迟 */
  calculateExponentialBackoff(attempt, baseDelayMs) {
    return baseDelayMs * Math.pow(2, attempt - 1);
  }
  /** 带重试的异步操作执行 */
  async executeWithRetry(operation, config) {
    const errorHistory = config.errorHistory ? [...config.errorHistory] : [];
    let attempt = 0;
    const maxAttempts = config.maxAttempts;
    const baseDelayMs = config.baseDelayMs ?? 1e3;
    while (attempt < maxAttempts) {
      attempt++;
      this.logger?.debug("RetryHandler", `\u6267\u884C\u64CD\u4F5C\uFF0C\u5C1D\u8BD5 ${attempt}/${maxAttempts}`, {
        event: "RETRY_ATTEMPT",
        attempt,
        maxAttempts,
        strategy: config.strategy
      });
      const result = await operation();
      if (result.ok) {
        this.logger?.debug("RetryHandler", `\u64CD\u4F5C\u6210\u529F\uFF0C\u5C1D\u8BD5 ${attempt}`, {
          event: "RETRY_SUCCESS",
          attempt
        });
        return result;
      }
      const taskError = this.createTaskError(result, attempt);
      errorHistory.push(taskError);
      this.logger?.warn("RetryHandler", `\u64CD\u4F5C\u5931\u8D25\uFF0C\u5C1D\u8BD5 ${attempt}/${maxAttempts}`, {
        event: "RETRY_FAILURE",
        attempt,
        maxAttempts,
        errorCode: result.error.code,
        errorMessage: result.error.message
      });
      if (config.onRetry) {
        config.onRetry(attempt, taskError);
      }
      if (!this.shouldRetry(result, attempt)) {
        this.logger?.info("RetryHandler", `\u9519\u8BEF\u4E0D\u53EF\u91CD\u8BD5\u6216\u5DF2\u8FBE\u6700\u5927\u6B21\u6570`, {
          event: "RETRY_TERMINATED",
          attempt,
          errorCode: result.error.code,
          retryable: this.classifyError(result.error.code).retryable
        });
        return {
          ok: false,
          error: {
            code: result.error.code,
            message: result.error.message,
            details: {
              ...result.error.details || {},
              errorHistory,
              finalAttempt: attempt
            }
          }
        };
      }
      const waitTime = this.calculateWaitTime(result, attempt, baseDelayMs);
      if (waitTime > 0) {
        this.logger?.debug("RetryHandler", `\u7B49\u5F85 ${waitTime}ms \u540E\u91CD\u8BD5`, {
          event: "RETRY_WAIT",
          waitTime,
          attempt
        });
        await delay(waitTime);
      }
    }
    const lastError = errorHistory[errorHistory.length - 1];
    this.logger?.error("RetryHandler", `\u91CD\u8BD5\u8017\u5C3D\uFF0C\u64CD\u4F5C\u5931\u8D25`, void 0, {
      event: "RETRY_EXHAUSTED",
      maxAttempts,
      lastErrorCode: lastError?.code,
      lastErrorMessage: lastError?.message
    });
    return {
      ok: false,
      error: {
        code: lastError?.code || "UNKNOWN",
        message: `\u64CD\u4F5C\u5931\u8D25\uFF0C\u5DF2\u91CD\u8BD5 ${maxAttempts} \u6B21: ${lastError?.message || "\u672A\u77E5\u9519\u8BEF"}`,
        details: {
          errorHistory,
          finalAttempt: maxAttempts,
          exhausted: true
        }
      }
    };
  }
  /** 创建任务错误记录 */
  createTaskError(error, attempt) {
    return {
      code: error.error.code,
      message: error.error.message,
      timestamp: formatCRTimestamp(),
      attempt
    };
  }
  /** 构建结构化重试的错误历史提示 */
  buildErrorHistoryPrompt(errors) {
    if (errors.length === 0) {
      return "";
    }
    const lines = [
      "\n\n## \u9519\u8BEF\u5386\u53F2",
      "\u4EE5\u4E0B\u662F\u4E4B\u524D\u5C1D\u8BD5\u4E2D\u9047\u5230\u7684\u9519\u8BEF\uFF0C\u8BF7\u907F\u514D\u91CD\u590D\u8FD9\u4E9B\u9519\u8BEF\uFF1A\n"
    ];
    for (const error of errors) {
      lines.push(`### \u5C1D\u8BD5 ${error.attempt}`);
      lines.push(`- \u9519\u8BEF\u7801\uFF1A${error.code}`);
      lines.push(`- \u9519\u8BEF\u4FE1\u606F\uFF1A${error.message}`);
      lines.push(`- \u65F6\u95F4\uFF1A${error.timestamp}
`);
    }
    return lines.join("\n");
  }
  /** 获取错误的用户友好提示 */
  getUserFriendlyMessage(error) {
    const code = error.error.code;
    const classification = this.classifyError(code);
    switch (classification.category) {
      case "INPUT_ERROR":
      case "CONFIG_ERROR":
      case "SYSTEM_ERROR":
      case "INTERNAL_ERROR":
        return error.error.message;
      case "PROVIDER_ERROR":
        if (code === "E202_RATE_LIMITED") {
          return "\u89E6\u53D1\u901F\u7387\u9650\u5236\uFF0C\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\u3002";
        }
        if (code === "E201_PROVIDER_TIMEOUT") {
          return "\u8BF7\u6C42\u8D85\u65F6\uFF0C\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\u3002";
        }
        if (code === "E203_INVALID_API_KEY") {
          return "\u8BA4\u8BC1\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5 API Key \u662F\u5426\u6B63\u786E\u914D\u7F6E\u3002";
        }
        if (code.startsWith("E210_") || code.startsWith("E211_") || code.startsWith("E212_")) {
          return "\u6A21\u578B\u8F93\u51FA\u4E0D\u7B26\u5408\u8981\u6C42\uFF0C\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\u3002";
        }
        return "Provider \u8C03\u7528\u5931\u8D25\uFF0C\u7CFB\u7EDF\u5C06\u81EA\u52A8\u91CD\u8BD5\u3002";
      default:
        return error.error.message;
    }
  }
  /** 获取错误的修复建议 */
  getFixSuggestion(error) {
    return getFixSuggestion(error.error.code);
  }
  /** 获取错误的重试配置 */
  getRetryConfigForError(error) {
    const classification = this.classifyError(error.error.code);
    if (classification.category === "PROVIDER_ERROR") {
      const isModelOutputError = error.error.code.startsWith("E210_") || error.error.code.startsWith("E211_") || error.error.code.startsWith("E212_");
      return isModelOutputError ? { ...MODEL_OUTPUT_ERROR_CONFIG } : { ...PROVIDER_ERROR_CONFIG };
    }
    return {
      maxAttempts: 1,
      strategy: "no_retry"
    };
  }
  /** 判断是否为模型输出错误（E210_/E211_/E212_） */
  isModelOutputError(code) {
    return code.startsWith("E210_") || code.startsWith("E211_") || code.startsWith("E212_");
  }
  /** 判断是否为终止错误（不可重试） */
  isTerminalError(code) {
    return !isRetryableErrorCode(code);
  }
  /** 检查结果是否为重试耗尽 */
  isRetryExhausted(result) {
    if (result.ok) {
      return false;
    }
    const details = result.error.details;
    return details?.exhausted === true;
  }
  /** 从失败结果中提取错误历史 */
  getErrorHistory(result) {
    if (result.ok) {
      return [];
    }
    const details = result.error.details;
    return details?.errorHistory ?? [];
  }
  /** 从失败结果中获取最后一个错误 */
  getLastError(result) {
    const errorHistory = this.getErrorHistory(result);
    return errorHistory.length > 0 ? errorHistory[errorHistory.length - 1] : void 0;
  }
  /** 创建任务失败结果 */
  createTaskFailureInfo(taskId, result) {
    const errorHistory = this.getErrorHistory(result);
    const lastError = this.getLastError(result);
    const details = !result.ok ? result.error.details : void 0;
    return {
      taskId,
      state: "Failed",
      lastError,
      errorHistory,
      finalAttempt: details?.finalAttempt ?? errorHistory.length
    };
  }
};
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function withRetry(operation, retryHandler, config) {
  const errorHistory = [];
  const wrappedOperation = async () => {
    const attempt = errorHistory.length + 1;
    return operation(attempt, errorHistory);
  };
  const fullConfig = {
    maxAttempts: config?.maxAttempts ?? 3,
    strategy: config?.strategy ?? "immediate",
    baseDelayMs: config?.baseDelayMs ?? 1e3,
    errorHistory,
    onRetry: (attempt, error) => {
      errorHistory.push(error);
      config?.onRetry?.(attempt, error);
    }
  };
  return retryHandler.executeWithRetry(wrappedOperation, fullConfig);
}

// src/core/provider-manager.ts
var import_obsidian4 = require("obsidian");
var SecurityUtils = class {
  static maskApiKey(apiKey) {
    if (!apiKey) return "***";
    if (apiKey.length <= 8) return "***";
    return `${apiKey.slice(0, 4)}...${apiKey.slice(-4)}`;
  }
  static sanitizeUrl(raw) {
    try {
      const url = new URL(raw);
      url.searchParams.delete("api_key");
      url.searchParams.delete("token");
      return url.toString();
    } catch {
      return "[invalid-url]";
    }
  }
};
var ProviderManager = class _ProviderManager {
  settingsStore;
  logger;
  retryHandler;
  networkListeners;
  isOffline = false;
  // 可用性缓存（遵循 G-08 本地优先，A-NF-01 性能界限）
  availabilityCache;
  static CACHE_TTL_MS = 5 * 60 * 1e3;
  // 5 分钟缓存
  constructor(settingsStore, logger, retryHandler) {
    this.settingsStore = settingsStore;
    this.logger = logger;
    this.retryHandler = retryHandler || new RetryHandler(logger);
    this.networkListeners = [];
    this.availabilityCache = /* @__PURE__ */ new Map();
    this.logger.debug("ProviderManager", "ProviderManager \u521D\u59CB\u5316\u5B8C\u6210");
  }
  /** 清除可用性缓存（用于设置页面"测试连接"时强制刷新） */
  clearAvailabilityCache(providerId) {
    if (providerId) {
      this.availabilityCache.delete(providerId);
      this.logger.debug("ProviderManager", `\u5DF2\u6E05\u9664 Provider ${providerId} \u7684\u53EF\u7528\u6027\u7F13\u5B58`);
    } else {
      this.availabilityCache.clear();
      this.logger.debug("ProviderManager", "\u5DF2\u6E05\u9664\u6240\u6709 Provider \u53EF\u7528\u6027\u7F13\u5B58");
    }
  }
  /** 调用聊天 API */
  async chat(request, signal) {
    const startTime = Date.now();
    const configResult = this.getProviderConfig(request.providerId);
    if (!configResult.ok) {
      return configResult;
    }
    const providerConfig = configResult.value;
    const baseUrl = providerConfig.baseUrl || DEFAULT_ENDPOINTS["openai"];
    const url = `${baseUrl}/chat/completions`;
    const safeUrl = SecurityUtils.sanitizeUrl(url);
    const requestBody = {
      model: request.model,
      messages: request.messages,
      temperature: request.temperature ?? 0.7,
      top_p: request.topP ?? 1
    };
    if (request.maxTokens !== void 0) {
      requestBody.max_tokens = request.maxTokens;
    }
    if (request.reasoning_effort) {
      requestBody.reasoning_effort = request.reasoning_effort;
    }
    this.logger.debug("ProviderManager", "\u53D1\u9001\u804A\u5929\u8BF7\u6C42", {
      event: "API_REQUEST",
      providerId: request.providerId,
      model: request.model,
      url: safeUrl,
      apiKeyMasked: SecurityUtils.maskApiKey(providerConfig.apiKey),
      messageCount: request.messages.length
    });
    const result = await this.retryHandler.executeWithRetry(
      async () => this.executeChatRequest(url, requestBody, providerConfig.apiKey, signal),
      {
        ...PROVIDER_ERROR_CONFIG,
        onRetry: (attempt, error) => {
          this.logger.warn("ProviderManager", `\u804A\u5929\u8BF7\u6C42\u91CD\u8BD5 ${attempt}`, {
            event: "API_RETRY",
            providerId: request.providerId,
            errorCode: error.code,
            errorMessage: error.message
          });
        }
      }
    );
    const elapsedTime = Date.now() - startTime;
    if (result.ok) {
      this.notifyNetworkStatus(true);
      this.logger.info("ProviderManager", "\u804A\u5929\u8BF7\u6C42\u6210\u529F", {
        event: "API_RESPONSE",
        providerId: request.providerId,
        model: request.model,
        tokensUsed: result.value.tokensUsed,
        elapsedTime
      });
    } else {
      const offline = result.error.code === "E204_PROVIDER_ERROR" && typeof result.error.details === "object" && result.error.details?.kind === "network";
      this.notifyNetworkStatus(!offline, offline ? result : void 0);
      this.logger.error("ProviderManager", "\u804A\u5929\u8BF7\u6C42\u5931\u8D25", void 0, {
        event: "API_ERROR",
        providerId: request.providerId,
        model: request.model,
        errorCode: result.error.code,
        errorMessage: result.error.message,
        elapsedTime
      });
    }
    return result;
  }
  /** 调用嵌入 API */
  async embed(request, signal) {
    const startTime = Date.now();
    const configResult = this.getProviderConfig(request.providerId);
    if (!configResult.ok) {
      return configResult;
    }
    const providerConfig = configResult.value;
    const baseUrl = providerConfig.baseUrl || DEFAULT_ENDPOINTS["openai"];
    const url = `${baseUrl}/embeddings`;
    const safeUrl = SecurityUtils.sanitizeUrl(url);
    const requestBody = {
      model: request.model,
      input: request.input
    };
    if (request.dimensions && request.dimensions > 0) {
      requestBody.dimensions = request.dimensions;
    }
    this.logger.debug("ProviderManager", "\u53D1\u9001\u5D4C\u5165\u8BF7\u6C42", {
      event: "API_REQUEST",
      providerId: request.providerId,
      model: request.model,
      url: safeUrl,
      apiKeyMasked: SecurityUtils.maskApiKey(providerConfig.apiKey),
      inputLength: request.input.length
    });
    const result = await this.retryHandler.executeWithRetry(
      async () => this.executeEmbedRequest(url, requestBody, providerConfig.apiKey, signal),
      {
        ...PROVIDER_ERROR_CONFIG,
        onRetry: (attempt, error) => {
          this.logger.warn("ProviderManager", `\u5D4C\u5165\u8BF7\u6C42\u91CD\u8BD5 ${attempt}`, {
            event: "API_RETRY",
            providerId: request.providerId,
            errorCode: error.code,
            errorMessage: error.message
          });
        }
      }
    );
    const elapsedTime = Date.now() - startTime;
    if (result.ok) {
      this.notifyNetworkStatus(true);
      this.logger.info("ProviderManager", "\u5D4C\u5165\u8BF7\u6C42\u6210\u529F", {
        event: "API_RESPONSE",
        providerId: request.providerId,
        model: request.model,
        tokensUsed: result.value.tokensUsed,
        dimension: result.value.embedding.length,
        elapsedTime
      });
    } else {
      const offline = result.error.code === "E204_PROVIDER_ERROR" && typeof result.error.details === "object" && result.error.details?.kind === "network";
      this.notifyNetworkStatus(!offline, offline ? result : void 0);
      this.logger.error("ProviderManager", "\u5D4C\u5165\u8BF7\u6C42\u5931\u8D25", void 0, {
        event: "API_ERROR",
        providerId: request.providerId,
        model: request.model,
        errorCode: result.error.code,
        errorMessage: result.error.message,
        elapsedTime
      });
    }
    return result;
  }
  /** 调用图片生成（OpenAI-Compatible Images API） */
  async generateImage(request, signal) {
    const startTime = Date.now();
    const configResult = this.getProviderConfig(request.providerId);
    if (!configResult.ok) {
      return configResult;
    }
    const providerConfig = configResult.value;
    const baseUrl = providerConfig.baseUrl || DEFAULT_ENDPOINTS["openai"];
    const url = `${baseUrl}/images/generations`;
    const safeUrl = SecurityUtils.sanitizeUrl(url);
    const body = {
      model: request.model,
      prompt: request.prompt,
      n: 1,
      response_format: "b64_json"
    };
    if (request.size) {
      body.size = request.size;
    }
    if (request.quality) {
      body.quality = request.quality;
    }
    if (request.style) {
      body.style = request.style;
    }
    this.logger.debug("ProviderManager", "\u53D1\u9001\u56FE\u7247\u751F\u6210\u8BF7\u6C42", {
      event: "API_REQUEST",
      providerId: request.providerId,
      model: request.model,
      url: safeUrl,
      apiKeyMasked: SecurityUtils.maskApiKey(providerConfig.apiKey)
    });
    const result = await this.retryHandler.executeWithRetry(
      async () => this.executeImageRequest(url, body, providerConfig.apiKey, signal),
      {
        ...PROVIDER_ERROR_CONFIG,
        onRetry: (attempt, error) => {
          this.logger.warn("ProviderManager", `\u56FE\u7247\u751F\u6210\u8BF7\u6C42\u91CD\u8BD5 ${attempt}`, {
            event: "API_RETRY",
            providerId: request.providerId,
            errorCode: error.code,
            errorMessage: error.message
          });
        }
      }
    );
    if (result.ok && /^https?:\/\//i.test(result.value.imageUrl)) {
      const normalized = await this.fetchImageUrlAsDataUrl(result.value.imageUrl, signal);
      if (!normalized.ok) {
        return err(normalized.error.code, normalized.error.message, normalized.error.details);
      }
      result.value.imageUrl = normalized.value;
    }
    const elapsedTime = Date.now() - startTime;
    if (result.ok) {
      this.notifyNetworkStatus(true);
      this.logger.info("ProviderManager", "\u56FE\u7247\u751F\u6210\u8BF7\u6C42\u6210\u529F", {
        event: "API_RESPONSE",
        providerId: request.providerId,
        model: request.model,
        elapsedTime
      });
    } else {
      const offline = result.error.code === "E204_PROVIDER_ERROR" && typeof result.error.details === "object" && result.error.details?.kind === "network";
      this.notifyNetworkStatus(!offline, offline ? result : void 0);
      this.logger.error("ProviderManager", "\u56FE\u7247\u751F\u6210\u8BF7\u6C42\u5931\u8D25", void 0, {
        event: "API_ERROR",
        providerId: request.providerId,
        model: request.model,
        errorCode: result.error.code,
        errorMessage: result.error.message,
        elapsedTime
      });
    }
    return result;
  }
  /** 检查 Provider 可用性 */
  async checkAvailability(providerId, forceRefresh = false, configOverride) {
    if (!forceRefresh && !configOverride) {
      const cached = this.availabilityCache.get(providerId);
      if (cached && Date.now() - cached.timestamp < _ProviderManager.CACHE_TTL_MS) {
        this.logger.debug("ProviderManager", "\u4F7F\u7528\u7F13\u5B58\u7684\u53EF\u7528\u6027\u4FE1\u606F", {
          event: "AVAILABILITY_CACHE_HIT",
          providerId,
          cacheAge: Date.now() - cached.timestamp
        });
        return ok(cached.capabilities);
      }
    }
    let providerConfig;
    if (configOverride) {
      providerConfig = configOverride;
    } else {
      const configResult = this.getProviderConfig(providerId);
      if (!configResult.ok) {
        return configResult;
      }
      providerConfig = configResult.value;
    }
    const baseUrl = providerConfig.baseUrl || DEFAULT_ENDPOINTS["openai"];
    const url = `${baseUrl}/models`;
    this.logger.debug("ProviderManager", "\u68C0\u67E5 Provider \u53EF\u7528\u6027", {
      event: "AVAILABILITY_CHECK",
      providerId,
      url,
      forceRefresh
    });
    try {
      const response = await (0, import_obsidian4.requestUrl)({
        url,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${providerConfig.apiKey}`
        },
        throw: false
      });
      if (response.status < 200 || response.status >= 300) {
        const errorResult = this.mapHttpError(response.status, typeof response.text === "string" ? response.text : "");
        const errorCode = !errorResult.ok ? errorResult.error.code : "UNKNOWN";
        this.logger.error("ProviderManager", "Provider \u4E0D\u53EF\u7528", void 0, {
          event: "AVAILABILITY_ERROR",
          providerId,
          status: response.status,
          errorCode
        });
        this.availabilityCache.delete(providerId);
        return errorResult;
      }
      const data = response.json;
      const models = data.data?.map((m) => m.id) ?? [];
      const image = models.length === 0 || models.some((modelId) => /image|dall-e/i.test(modelId));
      const capabilities = {
        chat: true,
        embedding: true,
        image,
        maxContextLength: 128e3,
        // 默认值
        models
      };
      this.availabilityCache.set(providerId, {
        capabilities,
        timestamp: Date.now()
      });
      this.notifyNetworkStatus(true);
      this.logger.info("ProviderManager", "Provider \u53EF\u7528", {
        event: "AVAILABILITY_SUCCESS",
        providerId,
        modelCount: capabilities.models.length
      });
      return ok(capabilities);
    } catch (error) {
      this.logger.error("ProviderManager", "\u68C0\u67E5 Provider \u53EF\u7528\u6027\u5931\u8D25", error, {
        event: "AVAILABILITY_ERROR",
        providerId
      });
      const cached = this.availabilityCache.get(providerId);
      if (cached) {
        this.logger.warn("ProviderManager", "\u7F51\u7EDC\u9519\u8BEF\uFF0C\u4F7F\u7528\u8FC7\u671F\u7F13\u5B58", {
          event: "AVAILABILITY_CACHE_FALLBACK",
          providerId,
          cacheAge: Date.now() - cached.timestamp
        });
        this.notifyNetworkStatus(false, err("E204_PROVIDER_ERROR", "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25", { kind: "network", error }));
        return ok(cached.capabilities);
      }
      this.notifyNetworkStatus(false, err("E204_PROVIDER_ERROR", "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25", { kind: "network", error }));
      return err("E204_PROVIDER_ERROR", "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25", { kind: "network", error });
    }
  }
  /** 获取已配置的 Provider 列表 */
  getConfiguredProviders() {
    const settings = this.settingsStore.getSettings();
    const providers = [];
    for (const [id, config] of Object.entries(settings.providers)) {
      providers.push({
        id,
        type: "openai",
        name: id,
        configured: !!config.apiKey
      });
    }
    return providers;
  }
  /** 订阅网络状态变化（用于离线/恢复提示） */
  subscribeNetworkStatus(listener) {
    this.networkListeners.push(listener);
    return () => {
      this.networkListeners = this.networkListeners.filter((l) => l !== listener);
    };
  }
  /** 设置 Provider 配置 */
  setProvider(id, config) {
    this.settingsStore.updateSettings({ providers: { [id]: config } });
    this.logger.info("ProviderManager", `Provider \u914D\u7F6E\u5DF2\u66F4\u65B0: ${id}`, {
      event: "PROVIDER_UPDATED",
      type: "openai",
      enabled: config.enabled,
      hasCustomBaseUrl: !!config.baseUrl
    });
  }
  /** 移除 Provider */
  async removeProvider(id) {
    const result = await this.settingsStore.removeProvider(id);
    if (!result.ok) {
      this.logger.error("ProviderManager", `Provider \u79FB\u9664\u5931\u8D25: ${id}`, void 0, {
        event: "PROVIDER_REMOVE_FAILED",
        errorCode: result.error.code
      });
      return result;
    }
    this.logger.info("ProviderManager", `Provider \u5DF2\u79FB\u9664: ${id}`, {
      event: "PROVIDER_REMOVED"
    });
    return result;
  }
  /** 通知网络状态（仅在状态变更时触发） */
  notifyNetworkStatus(online, error) {
    const nextOffline = !online;
    if (this.isOffline === nextOffline) {
      return;
    }
    this.isOffline = nextOffline;
    for (const listener of this.networkListeners) {
      try {
        listener(online, error);
      } catch (e) {
        this.logger.error("ProviderManager", "\u7F51\u7EDC\u72B6\u6001\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", e);
      }
    }
  }
  /** 获取并验证 Provider 配置 */
  getProviderConfig(providerId) {
    const settings = this.settingsStore.getSettings();
    const providerConfig = settings.providers[providerId];
    if (!providerConfig) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider \u672A\u914D\u7F6E: ${providerId}`);
    }
    if (!providerConfig.enabled) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider \u5DF2\u7981\u7528: ${providerId}`);
    }
    if (!providerConfig.apiKey) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider API Key \u672A\u914D\u7F6E: ${providerId}`);
    }
    return ok(providerConfig);
  }
  // 需求 22.7：使用 requestUrl() 而非 fetch()，绕过 CORS 限制
  async executeJsonRequest(url, body, apiKey, signal, parse2) {
    if (signal?.aborted) {
      return err("E310_INVALID_STATE", "\u8BF7\u6C42\u5DF2\u53D6\u6D88", signal.reason);
    }
    try {
      const params = {
        url,
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify(body),
        throw: false
      };
      const response = await (0, import_obsidian4.requestUrl)(params);
      if (response.status < 200 || response.status >= 300) {
        return this.mapHttpError(response.status, typeof response.text === "string" ? response.text : "");
      }
      const data = response.json;
      return parse2(data);
    } catch (error) {
      if (signal?.aborted) {
        return err("E310_INVALID_STATE", "\u8BF7\u6C42\u5DF2\u53D6\u6D88", signal.reason);
      }
      return err("E204_PROVIDER_ERROR", "\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5", { kind: "network", rawError: error.message });
    }
  }
  /** 执行聊天请求（单次，不含重试逻辑） */
  async executeChatRequest(url, body, apiKey, signal) {
    return this.executeJsonRequest(url, body, apiKey, signal, (raw) => {
      const data = raw;
      if (!data.choices || data.choices.length === 0) {
        return err("E204_PROVIDER_ERROR", "API \u8FD4\u56DE\u7A7A\u54CD\u5E94");
      }
      const firstChoice = data.choices[0];
      const content = firstChoice?.message?.content;
      if (typeof content !== "string") {
        return err("E204_PROVIDER_ERROR", "API \u8FD4\u56DE\u683C\u5F0F\u5F02\u5E38\uFF1A\u7F3A\u5C11 message.content");
      }
      return ok({
        content,
        tokensUsed: data.usage?.total_tokens,
        finishReason: firstChoice?.finish_reason
      });
    });
  }
  /** 执行嵌入请求（单次，不含重试逻辑） */
  async executeEmbedRequest(url, body, apiKey, signal) {
    return this.executeJsonRequest(url, body, apiKey, signal, (raw) => {
      const data = raw;
      if (!data.data || data.data.length === 0) {
        return err("E204_PROVIDER_ERROR", "API \u8FD4\u56DE\u7A7A\u54CD\u5E94");
      }
      const first = data.data[0];
      if (!first || !Array.isArray(first.embedding)) {
        return err("E204_PROVIDER_ERROR", "API \u8FD4\u56DE\u683C\u5F0F\u5F02\u5E38\uFF1A\u7F3A\u5C11 embedding");
      }
      return ok({
        embedding: first.embedding,
        tokensUsed: data.usage?.total_tokens
      });
    });
  }
  /** 执行图片请求（单次，不含重试） */
  async executeImageRequest(url, body, apiKey, signal) {
    return this.executeJsonRequest(url, body, apiKey, signal, (raw) => {
      const data = raw;
      const first = data.data?.[0];
      if (!first) {
        return err("E210_MODEL_OUTPUT_PARSE_FAILED", "\u56FE\u7247 API \u8FD4\u56DE\u7A7A\u7ED3\u679C");
      }
      const revisedPrompt = typeof first.revised_prompt === "string" ? first.revised_prompt : void 0;
      if (typeof first.b64_json === "string" && first.b64_json.trim().length > 0) {
        return ok({
          imageUrl: `data:image/png;base64,${first.b64_json}`,
          revisedPrompt
        });
      }
      if (typeof first.url === "string" && first.url.trim().length > 0) {
        return ok({
          imageUrl: first.url,
          revisedPrompt
        });
      }
      return err("E210_MODEL_OUTPUT_PARSE_FAILED", "\u56FE\u7247 API \u8FD4\u56DE\u683C\u5F0F\u5F02\u5E38\uFF1A\u7F3A\u5C11 b64_json/url");
    });
  }
  // 需求 22.7：使用 requestUrl() 而非 fetch()，绕过 CORS 限制
  async fetchImageUrlAsDataUrl(url, signal) {
    if (signal?.aborted) {
      return err("E310_INVALID_STATE", "\u8BF7\u6C42\u5DF2\u53D6\u6D88", signal.reason);
    }
    try {
      const response = await (0, import_obsidian4.requestUrl)({
        url,
        method: "GET",
        throw: false
      });
      if (response.status < 200 || response.status >= 300) {
        return err("E204_PROVIDER_ERROR", `\u56FE\u7247\u4E0B\u8F7D\u5931\u8D25 (${response.status})`);
      }
      const contentType = response.headers["content-type"] || "image/png";
      const buffer = Buffer.from(response.arrayBuffer);
      const base64 = buffer.toString("base64");
      return ok(`data:${contentType};base64,${base64}`);
    } catch (error) {
      if (signal?.aborted) {
        return err("E310_INVALID_STATE", "\u8BF7\u6C42\u5DF2\u53D6\u6D88", signal.reason);
      }
      return err("E204_PROVIDER_ERROR", "\u56FE\u7247\u4E0B\u8F7D\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5", { kind: "network", rawError: error.message });
    }
  }
  /**
   * 将 HTTP 状态码映射为错误结果
   * 需求 23.4：用户可见消息仅包含错误码 + 安全描述，原始 API 响应放入 details
   */
  mapHttpError(status, responseText) {
    let rawDetail = responseText;
    try {
      const errorData = JSON.parse(responseText);
      if (errorData.error?.message) {
        rawDetail = errorData.error.message;
      }
    } catch {
    }
    if (status === 401 || status === 403) {
      return err("E203_INVALID_API_KEY", "\u8BA4\u8BC1\u5931\u8D25\uFF0C\u8BF7\u68C0\u67E5 API Key \u662F\u5426\u6B63\u786E", { status, rawResponse: rawDetail });
    }
    if (status === 429) {
      return err("E202_RATE_LIMITED", "\u8BF7\u6C42\u9891\u7387\u8D85\u9650\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5", { status, rawResponse: rawDetail });
    }
    if (status >= 500) {
      return err("E204_PROVIDER_ERROR", `\u670D\u52A1\u5668\u9519\u8BEF (${status})\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5`, { status, rawResponse: rawDetail });
    }
    return err("E204_PROVIDER_ERROR", `API \u8BF7\u6C42\u5931\u8D25 (${status})`, { status, rawResponse: rawDetail });
  }
};

// src/core/prompt-manager.ts
var REQUIRED_BLOCKS = [
  "<system_instructions>",
  "<context_slots>",
  "<output_schema>"
];
var TASK_BLOCKS = [
  "<task_instruction>",
  "<task>"
];
var TASK_SLOT_MAPPING = {
  "index": {
    required: ["CTX_INPUT"],
    optional: ["CTX_LANGUAGE"]
  },
  "define": {
    required: ["CTX_INPUT"],
    optional: ["CTX_LANGUAGE"]
  },
  "tag": {
    required: ["CTX_META"],
    optional: ["CTX_LANGUAGE"]
  },
  "write": {
    required: ["CTX_META"],
    optional: ["CTX_SOURCES", "CTX_LANGUAGE"]
  },
  "amend": {
    required: ["CTX_CURRENT", "USER_INSTRUCTION"],
    optional: ["CTX_LANGUAGE", "CONCEPT_TYPE"]
  },
  "merge": {
    required: ["SOURCE_A_NAME", "CTX_SOURCE_A", "SOURCE_B_NAME", "CTX_SOURCE_B"],
    optional: ["USER_INSTRUCTION", "CTX_LANGUAGE", "CONCEPT_TYPE"]
  },
  "verify": {
    required: ["CTX_META", "CTX_CURRENT"],
    optional: ["CTX_SOURCES", "CTX_LANGUAGE"]
  },
  "image-generate": {
    required: ["USER_PROMPT", "CONTEXT_BEFORE", "CONTEXT_AFTER"],
    optional: ["CONCEPT_TYPE", "CONCEPT_NAME", "CTX_LANGUAGE"]
  }
};
var OPERATION_SLOT_MAPPING = {
  "merge": {
    required: ["SOURCE_A_NAME", "CTX_SOURCE_A", "SOURCE_B_NAME", "CTX_SOURCE_B"],
    optional: ["USER_INSTRUCTION", "CTX_LANGUAGE", "CONCEPT_TYPE"]
  },
  "amend": {
    required: ["CTX_CURRENT", "USER_INSTRUCTION"],
    optional: ["CTX_LANGUAGE", "CONCEPT_TYPE"]
  }
};
function validateBlockOrder(content) {
  const missingBlocks = [];
  for (const block2 of REQUIRED_BLOCKS) {
    if (!content.includes(block2)) {
      missingBlocks.push(block2);
    }
  }
  if (missingBlocks.length > 0) {
    return {
      valid: false,
      error: `\u6A21\u677F\u7F3A\u5C11\u5FC5\u9700\u533A\u5757: ${missingBlocks.join(", ")}`,
      missingBlocks
    };
  }
  const hasTaskBlock = TASK_BLOCKS.some((block2) => content.includes(block2));
  if (!hasTaskBlock) {
    return {
      valid: false,
      error: `\u6A21\u677F\u7F3A\u5C11\u4EFB\u52A1\u533A\u5757\uFF0C\u9700\u8981 ${TASK_BLOCKS.join(" \u6216 ")} \u4E2D\u7684\u81F3\u5C11\u4E00\u4E2A`,
      missingBlocks: [...TASK_BLOCKS]
    };
  }
  const systemPos = content.indexOf("<system_instructions>");
  const contextPos = content.indexOf("<context_slots>");
  const schemaPos = content.indexOf("<output_schema>");
  if (systemPos === -1 || contextPos === -1 || schemaPos === -1) {
    return {
      valid: false,
      error: "\u65E0\u6CD5\u627E\u5230\u5FC5\u9700\u533A\u5757\u7684\u4F4D\u7F6E"
    };
  }
  if (systemPos > contextPos) {
    return {
      valid: false,
      error: "<system_instructions> \u5E94\u8BE5\u5728 <context_slots> \u4E4B\u524D"
    };
  }
  return { valid: true };
}
function findUnreplacedVariables(content) {
  const regex = /\{\{([^}]+)\}\}/g;
  const unreplaced = [];
  let match;
  while ((match = regex.exec(content)) !== null) {
    unreplaced.push(match[0]);
  }
  return unreplaced;
}
function extractPlaceholderNames(content) {
  const regex = /\{\{([^}]+)\}\}/g;
  const slots = /* @__PURE__ */ new Set();
  let match;
  while ((match = regex.exec(content)) !== null) {
    const name = match[1].trim();
    if (!name) continue;
    slots.add(name);
  }
  return Array.from(slots);
}
function validateSlots(taskType, providedSlots) {
  const mapping = TASK_SLOT_MAPPING[taskType];
  if (!mapping) {
    return { valid: false, extraSlots: providedSlots };
  }
  const allowedSlots = /* @__PURE__ */ new Set([...mapping.required, ...mapping.optional]);
  const missingRequired = [];
  const extraSlots = [];
  for (const required of mapping.required) {
    if (!providedSlots.includes(required)) {
      missingRequired.push(required);
    }
  }
  for (const slot2 of providedSlots) {
    if (!allowedSlots.has(slot2)) {
      extraSlots.push(slot2);
    }
  }
  const valid = missingRequired.length === 0 && extraSlots.length === 0;
  return {
    valid,
    missingRequired: missingRequired.length > 0 ? missingRequired : void 0,
    extraSlots: extraSlots.length > 0 ? extraSlots : void 0
  };
}
function replaceVariable(template, varName, value) {
  const placeholder = "{{" + varName + "}}";
  return template.split(placeholder).join(value);
}
var PromptManager = class {
  fileStorage;
  logger;
  promptsDir;
  templateCache;
  baseComponentsCache;
  constructor(fileStorage, logger, promptsDir = "prompts") {
    this.fileStorage = fileStorage;
    this.logger = logger;
    this.promptsDir = promptsDir;
    this.templateCache = /* @__PURE__ */ new Map();
    this.baseComponentsCache = /* @__PURE__ */ new Map();
    this.logger.debug("PromptManager", "PromptManager \u521D\u59CB\u5316\u5B8C\u6210", {
      promptsDir
    });
  }
  /** 构建 prompt */
  build(taskType, slots, conceptType) {
    try {
      const templateId = this.resolveTemplateId(taskType, conceptType);
      const template = this.loadTemplate(templateId);
      const providedSlotKeys = Object.keys(slots);
      const slotValidation = validateSlots(taskType, providedSlotKeys);
      if (!slotValidation.valid) {
        if (slotValidation.missingRequired && slotValidation.missingRequired.length > 0) {
          this.logger.error("PromptManager", "\u7F3A\u5C11\u5FC5\u9700\u69FD\u4F4D", void 0, {
            taskType,
            missingRequired: slotValidation.missingRequired
          });
          throw new CognitiveRazorError("E102_MISSING_FIELD", `\u7F3A\u5C11\u5FC5\u9700\u69FD\u4F4D: ${slotValidation.missingRequired.join(", ")}`, {
            taskType,
            missingRequired: slotValidation.missingRequired
          });
        }
        if (slotValidation.extraSlots && slotValidation.extraSlots.length > 0) {
          this.logger.error("PromptManager", "\u5B58\u5728\u4E0D\u5141\u8BB8\u7684\u69FD\u4F4D", void 0, {
            taskType,
            extraSlots: slotValidation.extraSlots
          });
          throw new CognitiveRazorError("E101_INVALID_INPUT", `\u4EFB\u52A1 ${taskType} \u4E0D\u5141\u8BB8\u4F7F\u7528\u69FD\u4F4D: ${slotValidation.extraSlots.join(", ")}`, {
            taskType,
            extraSlots: slotValidation.extraSlots
          });
        }
      }
      let prompt = template.content;
      for (const [key2, value] of Object.entries(slots)) {
        prompt = replaceVariable(prompt, key2, value);
      }
      const slotMapping = TASK_SLOT_MAPPING[taskType];
      if (slotMapping) {
        for (const optionalKey of slotMapping.optional) {
          if (!(optionalKey in slots)) {
            prompt = replaceVariable(prompt, optionalKey, "");
          }
        }
      }
      const unreplacedVars = findUnreplacedVariables(prompt);
      if (unreplacedVars.length > 0) {
        this.logger.error("PromptManager", "\u5B58\u5728\u672A\u66FF\u6362\u7684\u53D8\u91CF", void 0, {
          taskType,
          unreplacedVars
        });
        throw new CognitiveRazorError("E405_TEMPLATE_INVALID", `\u5B58\u5728\u672A\u66FF\u6362\u7684\u53D8\u91CF: ${unreplacedVars.join(", ")}`, {
          taskType,
          unreplacedVars
        });
      }
      this.logger.debug("PromptManager", "Prompt \u6784\u5EFA\u6210\u529F", {
        taskType,
        templateId,
        promptLength: prompt.length
      });
      return prompt;
    } catch (error) {
      if (error instanceof CognitiveRazorError) {
        throw error;
      }
      this.logger.error("PromptManager", "\u6784\u5EFA prompt \u5931\u8D25", error, { taskType });
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6784\u5EFA prompt \u5931\u8D25", error);
    }
  }
  /** 验证模板 */
  validateTemplate(templateId) {
    try {
      const template = this.loadTemplate(templateId);
      const blockValidation = validateBlockOrder(template.content);
      if (!blockValidation.valid) {
        this.logger.error("PromptManager", "\u6A21\u677F\u533A\u5757\u9A8C\u8BC1\u5931\u8D25", void 0, {
          templateId,
          error: blockValidation.error,
          missingBlocks: blockValidation.missingBlocks
        });
        throw new CognitiveRazorError("E405_TEMPLATE_INVALID", blockValidation.error || "\u6A21\u677F\u533A\u5757\u9A8C\u8BC1\u5931\u8D25", {
          templateId,
          missingBlocks: blockValidation.missingBlocks
        });
      }
      this.logger.debug("PromptManager", "\u6A21\u677F\u9A8C\u8BC1\u901A\u8FC7", {
        templateId
      });
      return true;
    } catch (error) {
      if (error instanceof CognitiveRazorError) {
        throw error;
      }
      this.logger.error("PromptManager", "\u9A8C\u8BC1\u6A21\u677F\u5931\u8D25", error, { templateId });
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u9A8C\u8BC1\u6A21\u677F\u5931\u8D25", error);
    }
  }
  /** 获取必需槽位 */
  getRequiredSlots(taskType) {
    const mapping = TASK_SLOT_MAPPING[taskType];
    return mapping ? mapping.required : [];
  }
  /** 获取可选槽位 */
  getOptionalSlots(taskType) {
    const mapping = TASK_SLOT_MAPPING[taskType];
    return mapping ? mapping.optional : [];
  }
  /** 获取模板 ID（对于 write 任务，根据知识类型选择模板） */
  resolveTemplateId(taskType, conceptType) {
    const mapping = {
      "define": "_base/operations/define",
      "tag": "_base/operations/tag",
      "index": "index",
      "write": "_type/entity-core",
      // 默认值，会被 conceptType 覆盖
      "amend": "_base/operations/amend",
      "merge": "_base/operations/merge",
      "verify": "_base/operations/verify",
      "image-generate": "visualize"
    };
    if (taskType === "write" && conceptType) {
      const typeMapping = {
        "Domain": "_type/domain-core",
        "Issue": "_type/issue-core",
        "Theory": "_type/theory-core",
        "Entity": "_type/entity-core",
        "Mechanism": "_type/mechanism-core"
      };
      return typeMapping[conceptType] || mapping[taskType];
    }
    return mapping[taskType] || taskType;
  }
  /** 判断模板是否已缓存（用于入队前硬校验） */
  hasTemplate(templateId) {
    return this.templateCache.has(templateId);
  }
  /**
   * 构建操作 prompt（用于 Merge/Amend 等操作）
   * 
   * 遵循设计文档 7.4：使用操作模块槽位映射
   * 
   * @param operation 操作类型：merge | amend
   * @param slots 槽位值
   * @returns 构建的 prompt
   */
  buildOperation(operation, slots) {
    try {
      const slotMapping = OPERATION_SLOT_MAPPING[operation];
      if (!slotMapping) {
        throw new CognitiveRazorError("E101_INVALID_INPUT", `\u4E0D\u652F\u6301\u7684\u64CD\u4F5C\u7C7B\u578B: ${operation}`);
      }
      const templateId = `_base/operations/${operation}`;
      const template = this.loadTemplate(templateId);
      const allowedSlots = /* @__PURE__ */ new Set([...slotMapping.required, ...slotMapping.optional]);
      const missingRequired = slotMapping.required.filter((slot2) => !(slot2 in slots));
      if (missingRequired.length > 0) {
        throw new CognitiveRazorError("E102_MISSING_FIELD", `\u7F3A\u5C11\u5FC5\u9700\u69FD\u4F4D: ${missingRequired.join(", ")}`);
      }
      const extraProvided = Object.keys(slots).filter((slot2) => !allowedSlots.has(slot2));
      if (extraProvided.length > 0) {
        throw new CognitiveRazorError("E101_INVALID_INPUT", `\u64CD\u4F5C ${operation} \u4E0D\u652F\u6301\u69FD\u4F4D: ${extraProvided.join(", ")}`);
      }
      const templateSlots = extractPlaceholderNames(template.content);
      const unknownTemplateSlots = templateSlots.filter((slot2) => !allowedSlots.has(slot2));
      if (unknownTemplateSlots.length > 0) {
        throw new CognitiveRazorError("E405_TEMPLATE_INVALID", `\u6A21\u677F\u5B58\u5728\u672A\u58F0\u660E\u7684\u69FD\u4F4D: ${unknownTemplateSlots.join(", ")}`);
      }
      let prompt = template.content;
      for (const [key2, value] of Object.entries(slots)) {
        prompt = replaceVariable(prompt, key2, value);
      }
      for (const optionalKey of slotMapping.optional) {
        if (!(optionalKey in slots)) {
          prompt = replaceVariable(prompt, optionalKey, "");
        }
      }
      const unreplacedVars = findUnreplacedVariables(prompt);
      if (unreplacedVars.length > 0) {
        this.logger.error("PromptManager", "\u64CD\u4F5C\u5B58\u5728\u672A\u66FF\u6362\u7684\u53D8\u91CF", void 0, {
          operation,
          unreplacedVars
        });
        throw new CognitiveRazorError("E405_TEMPLATE_INVALID", `\u5B58\u5728\u672A\u66FF\u6362\u7684\u5360\u4F4D\u7B26: ${unreplacedVars[0]}`, {
          operation,
          unreplacedVars
        });
      }
      this.logger.debug("PromptManager", "\u64CD\u4F5C Prompt \u6784\u5EFA\u6210\u529F", {
        operation,
        promptLength: prompt.length
      });
      return prompt;
    } catch (error) {
      if (error instanceof CognitiveRazorError) {
        throw error;
      }
      this.logger.error("PromptManager", "\u6784\u5EFA\u64CD\u4F5C prompt \u5931\u8D25", error, { operation });
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6784\u5EFA\u64CD\u4F5C prompt \u5931\u8D25", error);
    }
  }
  /** 加载模板 */
  loadTemplate(templateId) {
    if (this.templateCache.has(templateId)) {
      return this.templateCache.get(templateId);
    }
    this.logger.error("PromptManager", "\u6A21\u677F\u672A\u52A0\u8F7D\uFF0C\u8BF7\u5148\u8C03\u7528 preloadTemplate", void 0, {
      templateId
    });
    throw new CognitiveRazorError(
      "E404_TEMPLATE_NOT_FOUND",
      `\u6A21\u677F\u672A\u52A0\u8F7D: ${templateId}\uFF0C\u8BF7\u5148\u8C03\u7528 preloadTemplate \u6216 preloadAllTemplates`,
      { templateId }
    );
  }
  /** 预加载基础组件 */
  async preloadBaseComponent(componentName) {
    if (this.baseComponentsCache.has(componentName)) {
      return ok(this.baseComponentsCache.get(componentName));
    }
    try {
      const componentPath = `${this.promptsDir}/_base/${componentName}.md`;
      const readResult = await this.fileStorage.read(componentPath);
      if (!readResult.ok) {
        this.logger.warn("PromptManager", `\u57FA\u7840\u7EC4\u4EF6\u4E0D\u5B58\u5728: ${componentName}`, {
          componentPath
        });
        return readResult;
      }
      const content = readResult.value;
      this.baseComponentsCache.set(componentName, content);
      this.logger.debug("PromptManager", `\u57FA\u7840\u7EC4\u4EF6\u5DF2\u52A0\u8F7D: ${componentName}`);
      return ok(content);
    } catch (error) {
      this.logger.error("PromptManager", "\u52A0\u8F7D\u57FA\u7840\u7EC4\u4EF6\u5931\u8D25", error, {
        componentName
      });
      return err("E500_INTERNAL_ERROR", "\u52A0\u8F7D\u57FA\u7840\u7EC4\u4EF6\u5931\u8D25", error);
    }
  }
  /** 替换模板中的基础组件引用 */
  async injectBaseComponents(content) {
    let processedContent = content;
    const componentMapping = {
      "{{BASE_WRITING_STYLE}}": "writing-style",
      "{{BASE_ANTI_PATTERNS}}": "anti-patterns",
      "{{BASE_TERMINOLOGY}}": "terminology",
      "{{BASE_OUTPUT_FORMAT}}": "output-format"
    };
    for (const [placeholder, componentName] of Object.entries(componentMapping)) {
      if (processedContent.includes(placeholder)) {
        const componentResult = await this.preloadBaseComponent(componentName);
        if (componentResult.ok) {
          processedContent = processedContent.split(placeholder).join(componentResult.value);
          this.logger.debug("PromptManager", `\u5DF2\u6CE8\u5165\u57FA\u7840\u7EC4\u4EF6: ${componentName}`);
        } else {
          this.logger.error("PromptManager", `\u57FA\u7840\u7EC4\u4EF6\u7F3A\u5931: ${componentName}`, void 0, {
            placeholder,
            error: componentResult.error
          });
          return err("E404_TEMPLATE_NOT_FOUND", `\u57FA\u7840\u7EC4\u4EF6\u6587\u4EF6\u7F3A\u5931: ${componentName}\uFF0C\u6A21\u677F\u65E0\u6CD5\u5B8C\u6574\u6784\u5EFA`);
        }
      }
    }
    return ok(processedContent);
  }
  /** 注入操作区块（用于 _type/*-core.md 的 {{OPERATION_BLOCK}}） */
  async injectOperationBlockIfPresent(templateId, content) {
    if (!content.includes("{{OPERATION_BLOCK}}")) {
      return ok(content);
    }
    if (!templateId.startsWith("_type/")) {
      return err("E405_TEMPLATE_INVALID", `\u6A21\u677F ${templateId} \u5305\u542B OPERATION_BLOCK\uFF0C\u4F46\u672A\u5B9A\u4E49\u6CE8\u5165\u89C4\u5219`);
    }
    const operationBlockId = "_base/operations/write";
    const operationBlockPath = `${this.promptsDir}/${operationBlockId}.md`;
    const readResult = await this.fileStorage.read(operationBlockPath);
    if (!readResult.ok) {
      return readResult;
    }
    const injected = await this.injectBaseComponents(readResult.value);
    if (!injected.ok) {
      return injected;
    }
    const next2 = content.split("{{OPERATION_BLOCK}}").join(injected.value);
    return ok(next2);
  }
  /** 预加载模板（应在初始化时调用） */
  async preloadTemplate(templateId) {
    try {
      const templatePath = `${this.promptsDir}/${templateId}.md`;
      const readResult = await this.fileStorage.read(templatePath);
      if (!readResult.ok) {
        this.logger.error("PromptManager", "\u8BFB\u53D6\u6A21\u677F\u6587\u4EF6\u5931\u8D25", void 0, {
          templateId,
          templatePath,
          error: readResult.error
        });
        return readResult;
      }
      let content = readResult.value;
      const injectionResult = await this.injectBaseComponents(content);
      if (!injectionResult.ok) {
        return injectionResult;
      }
      content = injectionResult.value;
      const operationInjection = await this.injectOperationBlockIfPresent(templateId, content);
      if (!operationInjection.ok) {
        return operationInjection;
      }
      content = operationInjection.value;
      const blockValidation = validateBlockOrder(content);
      if (!blockValidation.valid) {
        this.logger.error("PromptManager", "\u6A21\u677F\u7ED3\u6784\u9A8C\u8BC1\u5931\u8D25", void 0, {
          templateId,
          error: blockValidation.error
        });
        return err("E405_TEMPLATE_INVALID", blockValidation.error || "\u6A21\u677F\u7ED3\u6784\u9A8C\u8BC1\u5931\u8D25");
      }
      const slots = this.extractSlots(content);
      const template = {
        id: templateId,
        content,
        requiredSlots: slots.required,
        optionalSlots: slots.optional
      };
      this.templateCache.set(templateId, template);
      this.logger.info("PromptManager", `\u6A21\u677F\u5DF2\u52A0\u8F7D: ${templateId}`, {
        requiredSlots: slots.required.length,
        optionalSlots: slots.optional.length
      });
      return ok(void 0);
    } catch (error) {
      this.logger.error("PromptManager", "\u9884\u52A0\u8F7D\u6A21\u677F\u5931\u8D25", error, {
        templateId
      });
      return err("E500_INTERNAL_ERROR", "\u9884\u52A0\u8F7D\u6A21\u677F\u5931\u8D25", error);
    }
  }
  /** 预加载所有模板 */
  async preloadAllTemplates() {
    const templateIds = [
      "_base/operations/define",
      "_base/operations/tag",
      "_base/operations/verify",
      "_base/operations/write-phased",
      "_type/domain-core",
      "_type/issue-core",
      "_type/theory-core",
      "_type/entity-core",
      "_type/mechanism-core",
      "_base/operations/merge",
      "_base/operations/amend",
      "visualize"
    ];
    const errors = [];
    for (const templateId of templateIds) {
      const result = await this.preloadTemplate(templateId);
      if (!result.ok) {
        this.logger.error("PromptManager", `\u52A0\u8F7D\u6A21\u677F\u5931\u8D25: ${templateId}`, void 0, {
          error: result.error,
          promptsDir: this.promptsDir
        });
        errors.push(`${templateId}: ${result.error.message}`);
      }
    }
    this.logger.info("PromptManager", "\u6A21\u677F\u9884\u52A0\u8F7D\u5B8C\u6210", {
      loadedCount: this.templateCache.size,
      totalCount: templateIds.length,
      failedCount: errors.length
    });
    if (errors.length > 0) {
      return err("E405_TEMPLATE_INVALID", `${errors.length} \u4E2A\u6A21\u677F\u52A0\u8F7D\u5931\u8D25: ${errors.join("; ")}`);
    }
    return ok(void 0);
  }
  /** 提取槽位 */
  extractSlots(content) {
    const allSlots = /* @__PURE__ */ new Set();
    const regex = /\{\{([^}]+)\}\}/g;
    let match;
    while ((match = regex.exec(content)) !== null) {
      const slotName = match[1].trim();
      if (slotName.startsWith("CTX_") || slotName === "SHARED_CONSTRAINTS") {
        allSlots.add(slotName);
      }
    }
    return {
      required: Array.from(allSlots).filter((s) => s.startsWith("CTX_")),
      optional: []
    };
  }
  /** 预加载所有基础组件 */
  async preloadAllBaseComponents() {
    const componentNames = ["writing-style", "anti-patterns", "terminology", "output-format"];
    const errors = [];
    for (const componentName of componentNames) {
      const result = await this.preloadBaseComponent(componentName);
      if (!result.ok) {
        errors.push(`${componentName}: ${result.error.message}`);
      }
    }
    if (errors.length > 0) {
      this.logger.warn("PromptManager", "\u90E8\u5206\u57FA\u7840\u7EC4\u4EF6\u52A0\u8F7D\u5931\u8D25", {
        failedCount: errors.length,
        errors
      });
    }
    this.logger.info("PromptManager", "\u57FA\u7840\u7EC4\u4EF6\u9884\u52A0\u8F7D\u5B8C\u6210", {
      loadedCount: this.baseComponentsCache.size,
      totalCount: componentNames.length
    });
    return ok(void 0);
  }
  /**
   * 构建分阶段 Write prompt
   * 
   * 用于 Chain-of-Fields 分阶段写入，每次只生成部分字段。
   * 绕过 TASK_SLOT_MAPPING 约束，直接使用 write-phased 模板。
   * 
   * @param slots 槽位值（CTX_META, CTX_PREVIOUS, CTX_SOURCES, CTX_LANGUAGE, CONCEPT_TYPE, PHASE_SCHEMA, PHASE_FOCUS）
   * @returns 构建的 prompt
   */
  buildPhasedWrite(slots) {
    try {
      const templateId = "_base/operations/write-phased";
      const template = this.loadTemplate(templateId);
      let prompt = template.content;
      for (const [key2, value] of Object.entries(slots)) {
        prompt = replaceVariable(prompt, key2, value);
      }
      const optionalSlots = ["CTX_PREVIOUS", "CTX_SOURCES"];
      for (const optionalKey of optionalSlots) {
        if (!(optionalKey in slots)) {
          prompt = replaceVariable(prompt, optionalKey, "");
        }
      }
      const unreplacedVars = findUnreplacedVariables(prompt);
      if (unreplacedVars.length > 0) {
        this.logger.error("PromptManager", "\u5206\u9636\u6BB5 prompt \u5B58\u5728\u672A\u66FF\u6362\u7684\u53D8\u91CF", void 0, {
          unreplacedVars
        });
        throw new CognitiveRazorError("E405_TEMPLATE_INVALID", `\u5B58\u5728\u672A\u66FF\u6362\u7684\u53D8\u91CF: ${unreplacedVars.join(", ")}`, {
          unreplacedVars
        });
      }
      this.logger.debug("PromptManager", "\u5206\u9636\u6BB5 Write Prompt \u6784\u5EFA\u6210\u529F", {
        promptLength: prompt.length
      });
      return prompt;
    } catch (error) {
      if (error instanceof CognitiveRazorError) {
        throw error;
      }
      this.logger.error("PromptManager", "\u6784\u5EFA\u5206\u9636\u6BB5 prompt \u5931\u8D25", error);
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u6784\u5EFA\u5206\u9636\u6BB5 prompt \u5931\u8D25", error);
    }
  }
  /** 清除模板缓存（用于测试） */
  clearCache() {
    this.templateCache.clear();
    this.baseComponentsCache.clear();
  }
  /** 直接设置模板（用于测试） */
  setTemplate(templateId, template) {
    this.templateCache.set(templateId, template);
  }
};

// src/core/duplicate-manager.ts
var DuplicateManager = class {
  vectorIndex;
  fileStorage;
  logger;
  settingsStore;
  lockManager;
  storePath;
  store;
  listeners;
  /** 分页检测每页比较的概念数量 */
  pageSize = 50;
  constructor(vectorIndex, fileStorage, logger, settingsStore, lockManager, storePath = "data/duplicate-pairs.json") {
    this.vectorIndex = vectorIndex;
    this.fileStorage = fileStorage;
    this.logger = logger;
    this.settingsStore = settingsStore;
    this.lockManager = lockManager;
    this.storePath = storePath;
    this.store = null;
    this.listeners = [];
    this.logger.debug("DuplicateManager", "DuplicateManager \u521D\u59CB\u5316\u5B8C\u6210", {
      storePath
    });
  }
  /** 初始化（加载存储） */
  async initialize() {
    try {
      const exists = await this.fileStorage.exists(this.storePath);
      if (exists) {
        const readResult = await this.fileStorage.read(this.storePath);
        if (!readResult.ok) {
          this.logger.warn("DuplicateManager", "\u8BFB\u53D6\u91CD\u590D\u5BF9\u5B58\u50A8\u5931\u8D25\uFF0C\u521B\u5EFA\u65B0\u5B58\u50A8", {
            error: readResult.error
          });
          this.store = this.createEmptyStore();
          const writeResult = await this.saveStore();
          if (!writeResult.ok) {
            return writeResult;
          }
          return ok(void 0);
        }
        try {
          this.store = JSON.parse(readResult.value);
          const migrated = this.migrateStoreSchema();
          if (migrated) {
            const saveResult = await this.saveStore();
            if (!saveResult.ok) {
              return saveResult;
            }
          }
          this.logger.info("DuplicateManager", "\u91CD\u590D\u5BF9\u5B58\u50A8\u52A0\u8F7D\u6210\u529F", {
            pairCount: this.store.pairs.length,
            dismissedCount: this.store.dismissedPairs.length
          });
        } catch (parseError) {
          this.logger.warn("DuplicateManager", "\u89E3\u6790\u91CD\u590D\u5BF9\u5B58\u50A8\u5931\u8D25\uFF0C\u521B\u5EFA\u65B0\u5B58\u50A8", {
            error: parseError
          });
          this.store = this.createEmptyStore();
          const writeResult = await this.saveStore();
          if (!writeResult.ok) {
            return writeResult;
          }
        }
      } else {
        this.store = this.createEmptyStore();
        const writeResult = await this.saveStore();
        if (!writeResult.ok) {
          return writeResult;
        }
        this.logger.info("DuplicateManager", "\u521B\u5EFA\u65B0\u7684\u91CD\u590D\u5BF9\u5B58\u50A8");
      }
      return ok(void 0);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u521D\u59CB\u5316\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u521D\u59CB\u5316\u91CD\u590D\u7BA1\u7406\u5668\u5931\u8D25", error);
    }
  }
  /** 检测重复概念（分页计算 + 让出事件循环） */
  async detect(nodeId, type, embedding) {
    const typeLockKey = `type:${type}`;
    const acquired = this.lockManager.tryAcquire(typeLockKey);
    if (!acquired) {
      this.logger.warn("DuplicateManager", "\u7C7B\u578B\u9501\u51B2\u7A81\uFF0C\u8DF3\u8FC7\u53BB\u91CD\u68C0\u6D4B", {
        nodeId,
        type,
        lockKey: typeLockKey
      });
      return ok([]);
    }
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const settings = this.settingsStore.getSettings();
      const threshold = settings.similarityThreshold;
      const dismissedSet = new Set(this.store.dismissedPairs);
      const existingPairIds = new Set(this.store.pairs.map((p) => p.id));
      this.logger.debug("DuplicateManager", "\u5F00\u59CB\u68C0\u6D4B\u91CD\u590D", {
        nodeId,
        type,
        threshold
      });
      const vectorsResult = await this.vectorIndex.getVectorsByType(type);
      if (!vectorsResult.ok) {
        this.logger.error("DuplicateManager", "\u83B7\u53D6\u540C\u7C7B\u578B\u5411\u91CF\u5931\u8D25", void 0, {
          error: vectorsResult.error
        });
        return vectorsResult;
      }
      const candidates = vectorsResult.value.filter((v) => v.id !== nodeId);
      if (candidates.length === 0) {
        this.logger.debug("DuplicateManager", "\u65E0\u540C\u7C7B\u578B\u5019\u9009\u6982\u5FF5", {
          nodeId,
          type
        });
        return ok([]);
      }
      const normalizedNew = this.normalizeVector(embedding);
      const newPairs = [];
      for (let i = 0; i < candidates.length; i += this.pageSize) {
        const page = candidates.slice(i, i + this.pageSize);
        for (const candidate of page) {
          const normalizedCandidate = this.normalizeVector(candidate.embedding);
          const similarity = this.dotProduct(normalizedNew, normalizedCandidate);
          if (similarity >= threshold) {
            const pairId = this.generatePairId(nodeId, candidate.id);
            if (dismissedSet.has(pairId) || existingPairIds.has(pairId)) {
              continue;
            }
            const pair = {
              id: pairId,
              nodeIdA: nodeId,
              nodeIdB: candidate.id,
              type,
              similarity,
              detectedAt: formatCRTimestamp(),
              status: "pending"
            };
            newPairs.push(pair);
            this.store.pairs.push(pair);
            existingPairIds.add(pairId);
          }
        }
        if (i + this.pageSize < candidates.length) {
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
      }
      if (newPairs.length > 0) {
        await this.saveStore();
        this.notifyListeners();
        this.logger.info("DuplicateManager", `\u68C0\u6D4B\u5230 ${newPairs.length} \u4E2A\u91CD\u590D\u5BF9`, {
          nodeId,
          type,
          newPairs: newPairs.map((p) => p.id)
        });
      }
      return ok(newPairs);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u68C0\u6D4B\u91CD\u590D\u5931\u8D25", error, {
        nodeId,
        type
      });
      return err("E500_INTERNAL_ERROR", "\u68C0\u6D4B\u91CD\u590D\u5931\u8D25", error);
    } finally {
      this.lockManager.release(typeLockKey);
    }
  }
  /** 获取待处理的重复对 */
  getPendingPairs() {
    if (!this.store) {
      this.logger.warn("DuplicateManager", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      return [];
    }
    return this.store.pairs.filter((p) => p.status === "pending");
  }
  /** 标记为非重复 */
  async markAsNonDuplicate(pairId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const pairIndex = this.store.pairs.findIndex((p) => p.id === pairId);
      if (pairIndex === -1) {
        this.logger.warn("DuplicateManager", "\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728", { pairId });
        return err("E311_NOT_FOUND", `\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728: ${pairId}`);
      }
      this.store.pairs[pairIndex].status = "dismissed";
      if (!this.store.dismissedPairs.includes(pairId)) {
        this.store.dismissedPairs.push(pairId);
      }
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", `\u91CD\u590D\u5BF9\u5DF2\u6807\u8BB0\u4E3A\u975E\u91CD\u590D: ${pairId}`);
      return ok(void 0);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u6807\u8BB0\u4E3A\u975E\u91CD\u590D\u5931\u8D25", error, {
        pairId
      });
      return err("E500_INTERNAL_ERROR", "\u6807\u8BB0\u4E3A\u975E\u91CD\u590D\u5931\u8D25", error);
    }
  }
  /** 开始合并 */
  async startMerge(pairId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const pairIndex = this.store.pairs.findIndex((p) => p.id === pairId);
      if (pairIndex === -1) {
        this.logger.warn("DuplicateManager", "\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728", { pairId });
        return err("E311_NOT_FOUND", `\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728: ${pairId}`);
      }
      this.store.pairs[pairIndex].status = "merging";
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      const mergeTaskId = `merge-${pairId}-${Date.now()}`;
      this.logger.info("DuplicateManager", `\u5F00\u59CB\u5408\u5E76\u91CD\u590D\u5BF9: ${pairId}`, {
        mergeTaskId
      });
      return ok(mergeTaskId);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u5F00\u59CB\u5408\u5E76\u5931\u8D25", error, {
        pairId
      });
      return err("E500_INTERNAL_ERROR", "\u5F00\u59CB\u5408\u5E76\u5931\u8D25", error);
    }
  }
  /** 完成合并 */
  async completeMerge(pairId, keepNodeId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const pairIndex = this.store.pairs.findIndex((p) => p.id === pairId);
      if (pairIndex === -1) {
        this.logger.warn("DuplicateManager", "\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728", { pairId });
        return err("E311_NOT_FOUND", `\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728: ${pairId}`);
      }
      const pair = this.store.pairs[pairIndex];
      const deleteNodeId = keepNodeId === pair.nodeIdA ? pair.nodeIdB : pair.nodeIdA;
      this.store.pairs[pairIndex].status = "merged";
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", `\u5408\u5E76\u5B8C\u6210: ${pairId}`, {
        keepNodeId,
        deleteNodeId
      });
      return ok(void 0);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u5B8C\u6210\u5408\u5E76\u5931\u8D25", error, {
        pairId,
        keepNodeId
      });
      return err("E500_INTERNAL_ERROR", "\u5B8C\u6210\u5408\u5E76\u5931\u8D25", error);
    }
  }
  /**
   * 中止合并（将 merging 状态回退为 pending）
   *
   * 用于 Merge 管线在确认写入阶段失败时的恢复，避免重复对长期卡在 merging。
   */
  async abortMerge(pairId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const pairIndex = this.store.pairs.findIndex((p) => p.id === pairId);
      if (pairIndex === -1) {
        this.logger.warn("DuplicateManager", "\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728", { pairId });
        return err("E311_NOT_FOUND", `\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728: ${pairId}`);
      }
      const current = this.store.pairs[pairIndex];
      if (current.status !== "merging") {
        return ok(void 0);
      }
      this.store.pairs[pairIndex].status = "pending";
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", `\u5408\u5E76\u5DF2\u4E2D\u6B62\u5E76\u56DE\u9000\u4E3A pending: ${pairId}`);
      return ok(void 0);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u4E2D\u6B62\u5408\u5E76\u5931\u8D25", error, {
        pairId
      });
      return err("E500_INTERNAL_ERROR", "\u4E2D\u6B62\u5408\u5E76\u5931\u8D25", error);
    }
  }
  /** 订阅重复对变更 */
  subscribe(listener) {
    this.listeners.push(listener);
    if (this.store) {
      listener(this.store.pairs);
    }
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /** 更新重复对状态 */
  async updateStatus(pairId, status) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const pairIndex = this.store.pairs.findIndex((p) => p.id === pairId);
      if (pairIndex === -1) {
        this.logger.warn("DuplicateManager", "\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728", { pairId });
        return err("E311_NOT_FOUND", `\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728: ${pairId}`);
      }
      this.store.pairs[pairIndex].status = status;
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", `\u91CD\u590D\u5BF9\u72B6\u6001\u5DF2\u66F4\u65B0: ${pairId} -> ${status}`);
      return ok(void 0);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u66F4\u65B0\u72B6\u6001\u5931\u8D25", error, {
        pairId,
        status
      });
      return err("E500_INTERNAL_ERROR", "\u66F4\u65B0\u72B6\u6001\u5931\u8D25", error);
    }
  }
  /** 移除重复对 */
  async removePair(pairId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const pairIndex = this.store.pairs.findIndex((p) => p.id === pairId);
      if (pairIndex === -1) {
        this.logger.warn("DuplicateManager", "\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728", { pairId });
        return err("E311_NOT_FOUND", `\u91CD\u590D\u5BF9\u4E0D\u5B58\u5728: ${pairId}`);
      }
      this.store.pairs.splice(pairIndex, 1);
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", `\u91CD\u590D\u5BF9\u5DF2\u79FB\u9664: ${pairId}`);
      return ok(void 0);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u79FB\u9664\u91CD\u590D\u5BF9\u5931\u8D25", error, {
        pairId
      });
      return err("E500_INTERNAL_ERROR", "\u79FB\u9664\u91CD\u590D\u5BF9\u5931\u8D25", error);
    }
  }
  /** 获取已合并的重复对 */
  getMergedPairs() {
    if (!this.store) {
      this.logger.warn("DuplicateManager", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      return [];
    }
    return this.store.pairs.filter((p) => p.status === "merged");
  }
  /** 获取已忽略的重复对 */
  getDismissedPairs() {
    if (!this.store) {
      this.logger.warn("DuplicateManager", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      return [];
    }
    return this.store.pairs.filter((p) => p.status === "dismissed");
  }
  /**
   * 清理包含指定 nodeId 的重复对（用于笔记删除后的关联数据清理）
   * 仅保留 merging 状态，避免与合并管线产生竞态
   */
  async removePairsByNodeId(nodeId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const before = this.store.pairs.length;
      this.store.pairs = this.store.pairs.filter((p) => {
        if (p.status === "merging") {
          return true;
        }
        return p.nodeIdA !== nodeId && p.nodeIdB !== nodeId;
      });
      const removed = before - this.store.pairs.length;
      if (removed === 0) {
        return ok(0);
      }
      const existingIds = new Set(this.store.pairs.map((p) => p.id));
      this.store.dismissedPairs = this.store.dismissedPairs.filter((id) => existingIds.has(id));
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", "\u5DF2\u6E05\u7406\u5220\u9664\u7B14\u8BB0\u5173\u8054\u7684\u91CD\u590D\u5BF9", {
        nodeId,
        removed
      });
      return ok(removed);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u6E05\u7406\u91CD\u590D\u5BF9\u5931\u8D25", error, {
        nodeId
      });
      return err("E500_INTERNAL_ERROR", "\u6E05\u7406\u91CD\u590D\u5BF9\u5931\u8D25", error);
    }
  }
  /**
   * 清理包含指定 nodeId 的 Pending 重复对（用于内容发生语义变更后的重检）
   *
   * 约束：
   * - 仅清理 pending，保留 dismissed/merged/merging 的历史与状态
   * - 不触碰 dismissedPairs 历史列表，避免 UX 反复弹出
   */
  async clearPendingPairsByNodeId(nodeId) {
    try {
      if (!this.store) {
        return err("E310_INVALID_STATE", "\u91CD\u590D\u7BA1\u7406\u5668\u672A\u521D\u59CB\u5316");
      }
      const before = this.store.pairs.length;
      this.store.pairs = this.store.pairs.filter((p) => {
        if (p.status !== "pending") {
          return true;
        }
        return p.nodeIdA !== nodeId && p.nodeIdB !== nodeId;
      });
      const removed = before - this.store.pairs.length;
      if (removed === 0) {
        return ok(0);
      }
      const saveResult = await this.saveStore();
      if (!saveResult.ok) {
        return saveResult;
      }
      this.notifyListeners();
      this.logger.info("DuplicateManager", "\u5DF2\u6E05\u7406\u8BED\u4E49\u53D8\u66F4\u540E\u7684 Pending \u91CD\u590D\u5BF9", {
        nodeId,
        removed
      });
      return ok(removed);
    } catch (error) {
      this.logger.error("DuplicateManager", "\u6E05\u7406 Pending \u91CD\u590D\u5BF9\u5931\u8D25", error, {
        nodeId
      });
      return err("E500_INTERNAL_ERROR", "\u6E05\u7406 Pending \u91CD\u590D\u5BF9\u5931\u8D25", error);
    }
  }
  /** 归一化向量（用于余弦相似度计算） */
  normalizeVector(vector) {
    let norm = 0;
    for (let i = 0; i < vector.length; i++) {
      norm += vector[i] * vector[i];
    }
    norm = Math.sqrt(norm);
    if (norm === 0) {
      return vector;
    }
    const normalized = new Array(vector.length);
    for (let i = 0; i < vector.length; i++) {
      normalized[i] = vector[i] / norm;
    }
    return normalized;
  }
  /** 向量点积（归一化后等价于余弦相似度） */
  dotProduct(a, b) {
    let product = 0;
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i++) {
      product += a[i] * b[i];
    }
    return product;
  }
  /** 创建空存储 */
  createEmptyStore() {
    return {
      version: "1.0.0",
      pairs: [],
      dismissedPairs: []
    };
  }
  /**
   * 迁移存储结构：
   * - 旧格式：pairs[].noteA/noteB（包含 name/path）
   * - 新格式：pairs[].nodeIdA/nodeIdB（仅保存 cruid）
   */
  migrateStoreSchema() {
    if (!this.store) {
      return false;
    }
    let changed = false;
    const migratedPairs = [];
    for (const raw of this.store.pairs) {
      if (!raw || typeof raw !== "object") {
        changed = true;
        continue;
      }
      if (typeof raw.nodeIdA === "string" && typeof raw.nodeIdB === "string") {
        migratedPairs.push(raw);
        continue;
      }
      const noteA = raw.noteA;
      const noteB = raw.noteB;
      const nodeIdA = typeof noteA?.nodeId === "string" ? noteA.nodeId : null;
      const nodeIdB = typeof noteB?.nodeId === "string" ? noteB.nodeId : null;
      if (!nodeIdA || !nodeIdB) {
        changed = true;
        continue;
      }
      migratedPairs.push({
        id: String(raw.id || `${nodeIdA}--${nodeIdB}`),
        nodeIdA,
        nodeIdB,
        type: raw.type,
        similarity: typeof raw.similarity === "number" ? raw.similarity : 0,
        detectedAt: typeof raw.detectedAt === "string" ? raw.detectedAt : formatCRTimestamp(),
        status: raw.status === "pending" || raw.status === "merging" || raw.status === "merged" || raw.status === "dismissed" ? raw.status : "pending"
      });
      changed = true;
    }
    if (changed) {
      this.store.pairs = migratedPairs;
    }
    return changed;
  }
  /** 保存存储 */
  async saveStore() {
    if (!this.store) {
      return err("E310_INVALID_STATE", "\u5B58\u50A8\u672A\u521D\u59CB\u5316");
    }
    const writeResult = await this.fileStorage.write(
      this.storePath,
      JSON.stringify(this.store, null, 2)
    );
    if (!writeResult.ok) {
      this.logger.error("DuplicateManager", "\u4FDD\u5B58\u91CD\u590D\u5BF9\u5B58\u50A8\u5931\u8D25", void 0, {
        error: writeResult.error
      });
    }
    return writeResult;
  }
  /** 生成重复对 ID（确保唯一性和一致性） */
  generatePairId(nodeIdA, nodeIdB) {
    const [first, second] = [nodeIdA, nodeIdB].sort();
    return `${first}--${second}`;
  }
  /** 通知所有监听器 */
  notifyListeners() {
    if (!this.store) {
      return;
    }
    for (const listener of this.listeners) {
      try {
        listener(this.store.pairs);
      } catch (error) {
        this.logger.error("DuplicateManager", "\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error);
      }
    }
  }
};

// src/core/task-queue-store.ts
var TaskQueueStore = class {
  fileStorage;
  logger;
  queuePath;
  lastPersistedContent = null;
  saveChain = Promise.resolve();
  constructor(fileStorage, logger, queuePath) {
    this.fileStorage = fileStorage;
    this.logger = logger;
    this.queuePath = queuePath;
  }
  async load() {
    try {
      const exists = await this.fileStorage.exists(this.queuePath);
      if (!exists) {
        return ok(null);
      }
      const readResult = await this.fileStorage.read(this.queuePath);
      if (!readResult.ok) {
        this.logger.warn("TaskQueueStore", "\u8BFB\u53D6\u961F\u5217\u72B6\u6001\u5931\u8D25\uFF0C\u4F7F\u7528\u7A7A\u961F\u5217", {
          error: readResult.error,
          path: this.queuePath
        });
        return ok(null);
      }
      let parsed;
      try {
        parsed = JSON.parse(readResult.value);
      } catch (parseError) {
        this.logger.warn("TaskQueueStore", "\u89E3\u6790\u961F\u5217\u72B6\u6001\u5931\u8D25\uFF0C\u4F7F\u7528\u7A7A\u961F\u5217", {
          error: parseError,
          path: this.queuePath
        });
        return ok(null);
      }
      const normalized = this.normalizeQueueState(parsed);
      return ok(normalized);
    } catch (error) {
      this.logger.error("TaskQueueStore", "\u52A0\u8F7D\u961F\u5217\u72B6\u6001\u5931\u8D25", error, {
        path: this.queuePath
      });
      return err("E500_INTERNAL_ERROR", "\u52A0\u8F7D\u961F\u5217\u72B6\u6001\u5931\u8D25", error);
    }
  }
  save(state2) {
    const content = JSON.stringify(state2, null, 2);
    this.lastPersistedContent = content;
    this.saveChain = this.saveChain.then(async () => {
      const writeResult = await this.fileStorage.atomicWrite(this.queuePath, content);
      if (!writeResult.ok) {
        this.logger.error("TaskQueueStore", "\u4FDD\u5B58\u961F\u5217\u72B6\u6001\u5931\u8D25", void 0, {
          path: this.queuePath,
          error: writeResult.error
        });
      } else {
        this.logger.debug("TaskQueueStore", "\u961F\u5217\u72B6\u6001\u5DF2\u6301\u4E45\u5316", {
          path: this.queuePath,
          pendingTasks: state2.pendingTasks.length
        });
      }
    }).catch((error) => {
      this.logger.error("TaskQueueStore", "\u4FDD\u5B58\u961F\u5217\u72B6\u6001\u5F02\u5E38", error, {
        path: this.queuePath
      });
    });
    return this.saveChain;
  }
  getLastPersistedContent() {
    return this.lastPersistedContent;
  }
  getQueuePath() {
    return this.queuePath;
  }
  normalizeQueueState(raw) {
    if (!raw || typeof raw !== "object") {
      return null;
    }
    const obj = raw;
    const paused = typeof obj.paused === "boolean" ? obj.paused : false;
    const version = obj.version === "2.0.0" || obj.version === "1.0.0" ? obj.version : "1.0.0";
    if (Array.isArray(obj.pendingTasks)) {
      const pendingTasks = obj.pendingTasks.filter((t) => t && typeof t === "object").map((t) => t).filter((t) => typeof t.id === "string" && typeof t.nodeId === "string" && typeof t.taskType === "string").map((t) => ({
        id: String(t.id),
        nodeId: String(t.nodeId),
        taskType: t.taskType,
        attempt: typeof t.attempt === "number" ? t.attempt : 0,
        maxAttempts: typeof t.maxAttempts === "number" ? t.maxAttempts : 1,
        providerRef: typeof t.providerRef === "string" ? t.providerRef : void 0,
        promptRef: typeof t.promptRef === "string" ? t.promptRef : void 0,
        payload: t.payload && typeof t.payload === "object" && !Array.isArray(t.payload) ? t.payload : void 0,
        created: typeof t.created === "string" ? t.created : void 0,
        updated: typeof t.updated === "string" ? t.updated : void 0,
        errors: Array.isArray(t.errors) ? t.errors : void 0
      }));
      return {
        state: { version, pendingTasks, paused },
        migrated: false
      };
    }
    if (Array.isArray(obj.tasks)) {
      const pendingTasks = obj.tasks.filter((t) => t && typeof t === "object").map((t) => t).filter((t) => t.state === "Pending" || t.state === "Running").filter((t) => typeof t.id === "string" && typeof t.nodeId === "string" && typeof t.taskType === "string").map((t) => ({
        id: String(t.id),
        nodeId: String(t.nodeId),
        taskType: t.taskType,
        attempt: typeof t.attempt === "number" ? t.attempt : 0,
        maxAttempts: typeof t.maxAttempts === "number" ? t.maxAttempts : 1,
        providerRef: typeof t.providerRef === "string" ? t.providerRef : void 0,
        promptRef: typeof t.promptRef === "string" ? t.promptRef : void 0,
        payload: t.payload && typeof t.payload === "object" && !Array.isArray(t.payload) ? t.payload : {},
        created: typeof t.created === "string" ? t.created : void 0,
        updated: typeof t.updated === "string" ? t.updated : void 0,
        errors: Array.isArray(t.errors) ? t.errors : void 0
      }));
      return {
        state: { version: "2.0.0", pendingTasks, paused },
        migrated: true
      };
    }
    return {
      state: { version: "2.0.0", pendingTasks: [], paused },
      migrated: true
    };
  }
};

// src/core/task-queue.ts
var VALID_TASK_TYPES = /* @__PURE__ */ new Set([
  "define",
  "tag",
  "write",
  "amend",
  "merge",
  "index",
  "verify",
  "image-generate"
]);
var PAYLOAD_REQUIRED_FIELDS = {
  "define": [{ field: "userInput", type: "string" }],
  "tag": [{ field: "userInput", type: "string" }, { field: "conceptType", type: "string" }],
  "write": [{ field: "conceptType", type: "string" }],
  "amend": [{ field: "currentContent", type: "string" }, { field: "instruction", type: "string" }, { field: "conceptType", type: "string" }],
  "merge": [{ field: "keepName", type: "string" }, { field: "deleteName", type: "string" }, { field: "keepContent", type: "string" }, { field: "deleteContent", type: "string" }, { field: "conceptType", type: "string" }],
  "index": [],
  // 所有字段均为可选
  "verify": [{ field: "currentContent", type: "string" }],
  "image-generate": [{ field: "userPrompt", type: "string" }, { field: "filePath", type: "string" }]
};
function validateTaskRecordPayload(taskType, payload) {
  if (!VALID_TASK_TYPES.has(taskType)) {
    return `\u672A\u77E5\u7684 taskType: "${taskType}"`;
  }
  if (!payload || typeof payload !== "object" || Array.isArray(payload)) {
    return `payload \u4E0D\u662F\u6709\u6548\u5BF9\u8C61\uFF08taskType="${taskType}"\uFF09`;
  }
  const requiredFields = PAYLOAD_REQUIRED_FIELDS[taskType];
  const payloadObj = payload;
  for (const { field, type } of requiredFields) {
    const value = payloadObj[field];
    if (value === void 0 || value === null) {
      return `payload \u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5 "${field}"\uFF08taskType="${taskType}"\uFF09`;
    }
    if (typeof value !== type) {
      return `payload \u5B57\u6BB5 "${field}" \u7C7B\u578B\u9519\u8BEF\uFF1A\u671F\u671B ${type}\uFF0C\u5B9E\u9645 ${typeof value}\uFF08taskType="${taskType}"\uFF09`;
    }
  }
  return null;
}
var TaskQueue = class _TaskQueue {
  lockManager;
  logger;
  settingsStore;
  queueStore;
  taskRunner;
  // 可选，稍后通过 setTaskRunner 注入
  retryHandler;
  // 重试处理器
  tasks;
  paused;
  listeners;
  processingTasks;
  isScheduling;
  static DEFAULT_TASK_TIMEOUT_MS = 3 * 60 * 1e3;
  static DEFAULT_TASK_HISTORY_LIMIT = 300;
  // 防抖批量写入（需求 17.1 ~ 17.4）
  pendingWrite = false;
  writeTimer = null;
  writeIntervalMs = 2e3;
  // 2 秒防抖窗口
  constructor(lockManager, fileStorage, logger, settingsStore, queuePath = "data/queue-state.json") {
    this.lockManager = lockManager;
    this.logger = logger;
    this.settingsStore = settingsStore;
    this.queueStore = new TaskQueueStore(fileStorage, logger, queuePath);
    this.retryHandler = new RetryHandler(logger);
    this.tasks = /* @__PURE__ */ new Map();
    this.paused = false;
    this.listeners = [];
    this.processingTasks = /* @__PURE__ */ new Set();
    this.isScheduling = false;
    this.logger.debug("TaskQueue", "TaskQueue \u521D\u59CB\u5316\u5B8C\u6210", {
      queuePath: this.queueStore.getQueuePath()
    });
  }
  /** 设置 TaskRunner（依赖注入，避免循环依赖） */
  setTaskRunner(taskRunner) {
    this.taskRunner = taskRunner;
    this.logger.debug("TaskQueue", "TaskRunner \u5DF2\u6CE8\u5165");
    this.tryScheduleAll();
  }
  /** 初始化 - 加载队列状态 */
  async initialize() {
    try {
      const loadResult = await this.queueStore.load();
      if (!loadResult.ok) {
        return loadResult;
      }
      const loaded = loadResult.value;
      if (!loaded) {
        this.logger.info("TaskQueue", "\u521B\u5EFA\u65B0\u7684\u961F\u5217\u72B6\u6001");
        return ok(void 0);
      }
      await this.restoreQueueState(loaded.state, loaded.migrated);
      return ok(void 0);
    } catch (error) {
      this.logger.error("TaskQueue", "\u521D\u59CB\u5316\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u521D\u59CB\u5316\u4EFB\u52A1\u961F\u5217\u5931\u8D25", error);
    }
  }
  /** 入队任务 - 检查锁冲突和重复入队 */
  enqueue(task) {
    try {
      const taskId = this.generateTaskId();
      for (const existingTask of this.tasks.values()) {
        if (existingTask.nodeId === task.nodeId && (existingTask.state === "Pending" || existingTask.state === "Running")) {
          this.logger.warn("TaskQueue", "\u540C\u4E00\u8282\u70B9\u5DF2\u6709\u4EFB\u52A1\u5728\u961F\u5217\u4E2D\uFF0C\u65E0\u6CD5\u5165\u961F", {
            taskId,
            nodeId: task.nodeId,
            existingTaskId: existingTask.id,
            existingTaskState: existingTask.state,
            existingTaskType: existingTask.taskType
          });
          throw new CognitiveRazorError(
            "E320_TASK_CONFLICT",
            `\u8282\u70B9 ${task.nodeId} \u5DF2\u6709\u4EFB\u52A1\u5728\u961F\u5217\u4E2D\uFF08${existingTask.taskType}\uFF0C\u72B6\u6001\uFF1A${existingTask.state}\uFF09\uFF0C\u65E0\u6CD5\u91CD\u590D\u5165\u961F`,
            {
              nodeId: task.nodeId,
              existingTaskId: existingTask.id,
              existingTaskType: existingTask.taskType,
              existingTaskState: existingTask.state
            }
          );
        }
      }
      const now2 = formatCRTimestamp();
      const explicitTypeLockKey = typeof task.typeLockKey === "string" ? task.typeLockKey : void 0;
      const fullTask = {
        ...task,
        id: taskId,
        created: now2,
        updated: now2,
        state: "Pending",
        lockKey: task.lockKey ?? task.nodeId,
        typeLockKey: explicitTypeLockKey
      };
      this.tasks.set(taskId, fullTask);
      this.scheduleSave();
      this.publishEvent({
        type: "task-added",
        taskId,
        timestamp: now2
      });
      this.logger.info("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${taskId}`, {
        event: "TASK_STATE_CHANGE",
        taskId,
        previousState: null,
        newState: "Pending",
        taskType: task.taskType,
        nodeId: task.nodeId
      });
      this.tryScheduleAll();
      return taskId;
    } catch (error) {
      this.logger.error("TaskQueue", "\u4EFB\u52A1\u5165\u961F\u5931\u8D25", error instanceof Error ? error : new Error(String(error)), {
        nodeId: task.nodeId,
        taskType: task.taskType
      });
      if (error instanceof CognitiveRazorError) {
        throw error;
      }
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u4EFB\u52A1\u5165\u961F\u5931\u8D25", error);
    }
  }
  /** 取消任务 - 支持 Pending/Running/Failed 状态 */
  cancel(taskId) {
    try {
      const task = this.tasks.get(taskId);
      if (!task) {
        this.logger.warn("TaskQueue", "\u4EFB\u52A1\u4E0D\u5B58\u5728", { taskId });
        throw new CognitiveRazorError("E311_NOT_FOUND", `\u4EFB\u52A1\u4E0D\u5B58\u5728: ${taskId}`);
      }
      if (task.state !== "Pending" && task.state !== "Running" && task.state !== "Failed") {
        this.logger.warn("TaskQueue", "\u4EFB\u52A1\u72B6\u6001\u4E0D\u5141\u8BB8\u53D6\u6D88", {
          taskId,
          state: task.state
        });
        throw new CognitiveRazorError("E310_INVALID_STATE", `\u4EFB\u52A1\u72B6\u6001\u4E0D\u5141\u8BB8\u53D6\u6D88: ${task.state}`);
      }
      const previousState = task.state;
      if (task.state === "Running") {
        try {
          this.taskRunner?.abort(taskId);
        } catch (error) {
          this.logger.warn("TaskQueue", "\u4E2D\u65AD\u8FD0\u884C\u4E2D\u4EFB\u52A1\u5931\u8D25\uFF08\u5FFD\u7565\uFF09", {
            taskId,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
      task.state = "Cancelled";
      task.updated = formatCRTimestamp();
      this.releaseTaskLocks(task);
      this.processingTasks.delete(taskId);
      this.scheduleSave();
      this.publishEvent({
        type: "task-cancelled",
        taskId,
        timestamp: task.updated
      });
      this.logger.info("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${taskId}`, {
        event: "TASK_STATE_CHANGE",
        taskId,
        previousState,
        newState: "Cancelled"
      });
      return true;
    } catch (error) {
      this.logger.error("TaskQueue", "\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25", error, {
        taskId
      });
      if (error instanceof CognitiveRazorError) {
        throw error;
      }
      throw new CognitiveRazorError("E500_INTERNAL_ERROR", "\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25", error);
    }
  }
  /** 暂停队列 */
  async pause() {
    this.paused = true;
    this.scheduleSave();
    this.publishEvent({
      type: "queue-paused",
      timestamp: formatCRTimestamp()
    });
    this.logger.info("TaskQueue", "\u961F\u5217\u5DF2\u6682\u505C");
  }
  /** 恢复队列 */
  async resume() {
    this.paused = false;
    this.scheduleSave();
    this.publishEvent({
      type: "queue-resumed",
      timestamp: formatCRTimestamp()
    });
    this.logger.info("TaskQueue", "\u961F\u5217\u5DF2\u6062\u590D");
    this.tryScheduleAll();
  }
  /** 获取队列状态 */
  getStatus() {
    let pending3 = 0;
    let running = 0;
    let completed = 0;
    let failed = 0;
    for (const task of this.tasks.values()) {
      switch (task.state) {
        case "Pending":
          pending3++;
          break;
        case "Running":
          running++;
          break;
        case "Completed":
          completed++;
          break;
        case "Failed":
          failed++;
          break;
      }
    }
    return {
      paused: this.paused,
      pending: pending3,
      running,
      completed,
      failed
    };
  }
  /** 订阅队列事件 */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /** 获取任务 */
  getTask(taskId) {
    return this.tasks.get(taskId);
  }
  /** 更新任务状态 */
  updateTask(taskId, updates) {
    const task = this.tasks.get(taskId);
    if (!task) {
      return err("E311_NOT_FOUND", `\u4EFB\u52A1\u4E0D\u5B58\u5728: ${taskId}`);
    }
    Object.assign(task, updates);
    task.updated = formatCRTimestamp();
    this.scheduleSave();
    return ok(void 0);
  }
  /** 停止调度器（事件驱动模式，保留接口兼容性） */
  stop() {
    this.logger.debug("TaskQueue", "\u8C03\u5EA6\u5668\u505C\u6B62\uFF08\u4E8B\u4EF6\u9A71\u52A8\u6A21\u5F0F\uFF09");
  }
  /**
   * Plugin 卸载时强制刷新缓冲区（需求 17.3）
   *
   * 清除待执行的定时器，立即将缓冲区数据写入磁盘。
   */
  async dispose() {
    if (this.writeTimer !== null) {
      clearTimeout(this.writeTimer);
      this.writeTimer = null;
    }
    if (this.pendingWrite) {
      await this.flushSave();
    }
  }
  /** 获取所有任务 */
  getAllTasks() {
    return Array.from(this.tasks.values());
  }
  /** 清理已完成的任务 */
  async cleanupCompletedTasks(beforeDate) {
    try {
      const tasksToRemove = [];
      const beforeTime = beforeDate.getTime();
      for (const [taskId, task] of this.tasks.entries()) {
        if (task.state === "Completed" && task.completedAt) {
          const completedTime = new Date(task.completedAt).getTime();
          if (completedTime < beforeTime) {
            tasksToRemove.push(taskId);
          }
        }
      }
      for (const taskId of tasksToRemove) {
        this.tasks.delete(taskId);
      }
      if (tasksToRemove.length > 0) {
        this.scheduleSave();
      }
      this.logger.info("TaskQueue", `\u6E05\u7406\u4E86 ${tasksToRemove.length} \u4E2A\u5DF2\u5B8C\u6210\u4EFB\u52A1`);
      return ok(tasksToRemove.length);
    } catch (error) {
      this.logger.error("TaskQueue", "\u6E05\u7406\u4EFB\u52A1\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u6E05\u7406\u4EFB\u52A1\u5931\u8D25", error);
    }
  }
  /** 清理所有已完成的任务 */
  async clearCompleted() {
    return this.cleanupCompletedTasks(/* @__PURE__ */ new Date());
  }
  /** 重试所有失败的任务 */
  async retryFailed() {
    try {
      let retriedCount = 0;
      for (const task of this.tasks.values()) {
        if (task.state === "Failed") {
          task.state = "Pending";
          task.attempt = 0;
          task.errors = [];
          task.updated = formatCRTimestamp();
          retriedCount++;
        }
      }
      if (retriedCount > 0) {
        this.scheduleSave();
        this.tryScheduleAll();
      }
      this.logger.info("TaskQueue", `\u91CD\u8BD5\u4E86 ${retriedCount} \u4E2A\u5931\u8D25\u4EFB\u52A1`);
      return ok(retriedCount);
    } catch (error) {
      this.logger.error("TaskQueue", "\u91CD\u8BD5\u4EFB\u52A1\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u91CD\u8BD5\u4EFB\u52A1\u5931\u8D25", error);
    }
  }
  // 私有方法
  /** 事件驱动调度 - 填满并发槽 */
  tryScheduleAll() {
    if (this.isScheduling) {
      return;
    }
    this.isScheduling = true;
    try {
      const settings = this.settingsStore.getSettings();
      const concurrency = settings.concurrency;
      let scheduledCount = 0;
      while (this.processingTasks.size < concurrency) {
        const scheduled = this.scheduleOneTask();
        if (!scheduled) break;
        scheduledCount++;
      }
      if (scheduledCount > 0) {
        this.logger.debug("TaskQueue", "\u6279\u91CF\u8C03\u5EA6\u5B8C\u6210", {
          scheduledCount,
          processingCount: this.processingTasks.size,
          concurrency
        });
      }
    } finally {
      this.isScheduling = false;
    }
  }
  /** 调度单个任务 */
  scheduleOneTask() {
    if (this.paused) {
      return false;
    }
    if (!this.taskRunner) {
      this.logger.warn("TaskQueue", "TaskRunner \u672A\u6CE8\u5165\uFF0C\u65E0\u6CD5\u6267\u884C\u4EFB\u52A1");
      return false;
    }
    for (const task of this.tasks.values()) {
      if (task.state === "Pending") {
        const nodeLockKey = task.lockKey || task.nodeId;
        const acquiredNode = this.lockManager.tryAcquire(nodeLockKey);
        if (!acquiredNode) {
          continue;
        }
        const typeLockKey = task.typeLockKey;
        if (typeLockKey) {
          const acquiredType = this.lockManager.tryAcquire(typeLockKey);
          if (!acquiredType) {
            this.lockManager.release(nodeLockKey);
            continue;
          }
        }
        this.processingTasks.add(task.id);
        task.lockKey = nodeLockKey;
        const previousState = task.state;
        task.state = "Running";
        task.startedAt = formatCRTimestamp();
        task.updated = task.startedAt;
        this.scheduleSave();
        this.publishEvent({
          type: "task-started",
          taskId: task.id,
          timestamp: task.startedAt
        });
        this.logger.info("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${task.id}`, {
          event: "TASK_STATE_CHANGE",
          taskId: task.id,
          previousState,
          newState: "Running",
          taskType: task.taskType,
          nodeId: task.nodeId
        });
        this.executeTask(task).catch((error) => {
          this.logger.error("TaskQueue", `\u4EFB\u52A1\u6267\u884C\u5F02\u5E38: ${task.id}`, error);
        });
        return true;
      }
    }
    return false;
  }
  /** 执行任务 - 调用 TaskRunner 并处理结果 */
  async executeTask(task) {
    if (!this.taskRunner) {
      this.logger.error("TaskQueue", "TaskRunner \u672A\u6CE8\u5165", void 0, {
        taskId: task.id
      });
      this.handleTaskExecutionFailure(task, {
        code: "E310_INVALID_STATE",
        message: "TaskRunner \u672A\u6CE8\u5165"
      });
      return;
    }
    let timeoutHandle = null;
    try {
      this.logger.debug("TaskQueue", `\u5F00\u59CB\u6267\u884C\u4EFB\u52A1: ${task.id}`, {
        taskType: task.taskType,
        attempt: task.attempt + 1,
        nodeId: task.nodeId
      });
      const timeoutMs = this.settingsStore.getSettings().taskTimeoutMs || _TaskQueue.DEFAULT_TASK_TIMEOUT_MS;
      let timedOut = false;
      timeoutHandle = setTimeout(() => {
        timedOut = true;
        this.logger.warn("TaskQueue", `\u4EFB\u52A1\u8D85\u65F6\uFF0C\u89E6\u53D1\u81EA\u52A8\u53D6\u6D88: ${task.id}`, {
          taskId: task.id,
          timeoutMs
        });
        this.taskRunner?.abort(task.id);
      }, Math.max(1e3, timeoutMs));
      const result = await this.taskRunner.run(task);
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
      if (timedOut && result.ok) {
        await this.handleTaskFailure(task, { code: "E201_PROVIDER_TIMEOUT", message: "\u4EFB\u52A1\u6267\u884C\u8D85\u65F6" });
        return;
      }
      if (result.ok) {
        await this.handleTaskSuccess(task, result.value);
      } else {
        await this.handleTaskFailure(task, result.error);
      }
    } catch (error) {
      this.logger.error("TaskQueue", `\u4EFB\u52A1\u6267\u884C\u5F02\u5E38: ${task.id}`, error, {
        taskType: task.taskType,
        nodeId: task.nodeId
      });
      await this.handleTaskExecutionFailure(task, {
        code: "E500_INTERNAL_ERROR",
        message: error instanceof Error ? error.message : String(error)
      });
    } finally {
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
      }
    }
  }
  /** 处理任务成功 */
  async handleTaskSuccess(task, taskResult) {
    const previousState = task.state;
    task.state = "Completed";
    task.completedAt = formatCRTimestamp();
    task.updated = task.completedAt;
    task.result = taskResult.data;
    if (taskResult.data !== void 0) {
      task.payload = {
        ...task.payload,
        result: taskResult.data
      };
    }
    this.logger.info("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${task.id}`, {
      event: "TASK_STATE_CHANGE",
      taskId: task.id,
      previousState,
      newState: "Completed",
      taskType: task.taskType,
      nodeId: task.nodeId
    });
    this.releaseTaskLocks(task);
    this.publishEvent({
      type: "task-completed",
      taskId: task.id,
      timestamp: task.completedAt
    });
    this.processingTasks.delete(task.id);
    this.trimHistory();
    this.scheduleSave();
    this.tryScheduleAll();
  }
  /** 处理任务失败 - 根据错误类型决定是否重试 */
  async handleTaskFailure(task, error) {
    const previousState = task.state;
    task.attempt++;
    if (!task.errors) {
      task.errors = [];
    }
    task.errors.push({
      code: error.code,
      message: error.message,
      timestamp: formatCRTimestamp(),
      attempt: task.attempt
    });
    const errorClassification = this.retryHandler.classifyError(error.code);
    if (task.maxAttempts < errorClassification.maxAttempts) {
      task.maxAttempts = errorClassification.maxAttempts;
      this.logger.debug("TaskQueue", `\u66F4\u65B0\u4EFB\u52A1\u6700\u5927\u91CD\u8BD5\u6B21\u6570: ${task.id}`, {
        taskId: task.id,
        errorCode: error.code,
        errorCategory: errorClassification.category,
        newMaxAttempts: task.maxAttempts
      });
    }
    const settings = this.settingsStore.getSettings();
    const shouldRetry = settings.autoRetry && errorClassification.retryable && task.attempt < task.maxAttempts;
    if (shouldRetry) {
      task.state = "Pending";
      task.updated = formatCRTimestamp();
      this.logger.warn("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${task.id}`, {
        event: "TASK_STATE_CHANGE",
        taskId: task.id,
        previousState,
        newState: "Pending",
        reason: "retry",
        attempt: task.attempt,
        maxAttempts: task.maxAttempts,
        errorCode: error.code,
        errorMessage: error.message,
        errorCategory: errorClassification.category,
        retryStrategy: errorClassification.strategy
      });
      this.releaseTaskLocks(task);
      this.processingTasks.delete(task.id);
    } else {
      task.state = "Failed";
      task.updated = formatCRTimestamp();
      const failureReason = !settings.autoRetry ? "autoRetry disabled" : !errorClassification.retryable ? "non-retryable error" : "max attempts reached";
      this.logger.error("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${task.id}`, void 0, {
        event: "TASK_STATE_CHANGE",
        taskId: task.id,
        previousState,
        newState: "Failed",
        attempt: task.attempt,
        maxAttempts: task.maxAttempts,
        errorCode: error.code,
        errorMessage: error.message,
        errorCategory: errorClassification.category,
        failureReason
      });
      this.publishEvent({
        type: "task-failed",
        taskId: task.id,
        timestamp: task.updated
      });
      this.releaseTaskLocks(task);
      this.processingTasks.delete(task.id);
    }
    this.trimHistory();
    this.scheduleSave();
    this.tryScheduleAll();
  }
  /**
   * 处理任务执行异常（未预期的错误）
   */
  async handleTaskExecutionFailure(task, error) {
    const previousState = task.state;
    task.state = "Failed";
    task.updated = formatCRTimestamp();
    if (!task.errors) {
      task.errors = [];
    }
    task.errors.push({
      code: error.code,
      message: error.message,
      timestamp: formatCRTimestamp(),
      attempt: task.attempt
    });
    this.logger.error("TaskQueue", `\u4EFB\u52A1\u72B6\u6001\u53D8\u66F4: ${task.id}`, void 0, {
      event: "TASK_STATE_CHANGE",
      taskId: task.id,
      previousState,
      newState: "Failed",
      reason: "exception",
      errorCode: error.code,
      errorMessage: error.message
    });
    this.releaseTaskLocks(task);
    this.processingTasks.delete(task.id);
    this.trimHistory();
    this.scheduleSave();
    this.publishEvent({
      type: "task-failed",
      taskId: task.id,
      timestamp: task.updated
    });
  }
  /**
   * 释放任务持有的所有锁
   */
  releaseTaskLocks(task) {
    if (task.lockKey) {
      this.lockManager.release(task.lockKey);
    }
    if (task.typeLockKey) {
      this.lockManager.release(task.typeLockKey);
    }
  }
  /**
   * 防抖调度保存（需求 17.1, 17.2）
   *
   * 将写入请求合并到缓冲区，在 2 秒防抖窗口后批量写入一次。
   * 若已有定时器在等待，则仅标记 pendingWrite，不重复创建定时器。
   */
  scheduleSave() {
    this.pendingWrite = true;
    if (this.writeTimer !== null) return;
    this.writeTimer = setTimeout(async () => {
      this.writeTimer = null;
      if (this.pendingWrite) {
        await this.flushSave();
      }
    }, this.writeIntervalMs);
  }
  /**
   * 立即刷新缓冲区到磁盘（需求 17.3, 17.4）
   *
   * I/O 错误时保留 pendingWrite 标记，下次触发时重试。
   */
  async flushSave() {
    this.pendingWrite = false;
    try {
      await this.buildAndSave();
    } catch {
      this.pendingWrite = true;
      this.logger.error("TaskQueue", "\u6279\u91CF\u5199\u5165\u5931\u8D25\uFF0C\u5C06\u5728\u4E0B\u6B21\u89E6\u53D1\u65F6\u91CD\u8BD5");
    }
  }
  /**
   * 构建队列状态并写入磁盘
   *
   * Phase 2.2：仅持久化最小队列状态（pendingTasks + paused）
   */
  buildAndSave() {
    const pendingTasks = Array.from(this.tasks.values()).filter((task) => task.state === "Pending" || task.state === "Running").map((task) => ({
      id: task.id,
      nodeId: task.nodeId,
      taskType: task.taskType,
      attempt: task.attempt,
      maxAttempts: task.maxAttempts,
      providerRef: task.providerRef,
      promptRef: task.promptRef,
      payload: task.payload,
      created: task.created,
      updated: task.updated,
      errors: task.errors
    }));
    const queueState = {
      version: "2.0.0",
      pendingTasks,
      paused: this.paused
    };
    return this.queueStore.save(queueState);
  }
  /**
   * 获取最后持久化的内容（用于测试）
   * 
   * 注意：此方法仅用于测试目的，验证 Requirements 2.2
   */
  getLastPersistedContent() {
    return this.queueStore.getLastPersistedContent();
  }
  /**
   * 获取队列文件路径
   */
  getQueuePath() {
    return this.queueStore.getQueuePath();
  }
  /**
   * 从持久化文件恢复队列状态
   */
  async restoreQueueState(queueState, migrated) {
    this.tasks.clear();
    this.processingTasks.clear();
    this.paused = queueState.paused || queueState.pendingTasks.length > 0;
    const now2 = formatCRTimestamp();
    let invalidCount = 0;
    for (const persisted of queueState.pendingTasks) {
      const validationError = validateTaskRecordPayload(
        persisted.taskType,
        persisted.payload
      );
      if (validationError) {
        invalidCount++;
        this.logger.warn("TaskQueue", "\u53CD\u5E8F\u5217\u5316\u6821\u9A8C\u5931\u8D25\uFF0C\u4EFB\u52A1\u6807\u8BB0\u4E3A Failed", {
          taskId: persisted.id,
          nodeId: persisted.nodeId,
          taskType: persisted.taskType,
          reason: validationError
        });
        const failedTask = {
          id: persisted.id,
          nodeId: persisted.nodeId,
          taskType: persisted.taskType,
          state: "Failed",
          attempt: persisted.attempt,
          maxAttempts: persisted.maxAttempts,
          providerRef: persisted.providerRef,
          promptRef: persisted.promptRef,
          payload: persisted.payload ?? {},
          created: persisted.created ?? now2,
          updated: now2,
          errors: [
            ...persisted.errors ?? [],
            {
              code: "E100_INVALID_INPUT",
              message: validationError,
              timestamp: now2,
              attempt: persisted.attempt
            }
          ]
        };
        this.tasks.set(failedTask.id, failedTask);
        continue;
      }
      const restoredTask = {
        id: persisted.id,
        nodeId: persisted.nodeId,
        taskType: persisted.taskType,
        state: "Pending",
        attempt: persisted.attempt,
        maxAttempts: persisted.maxAttempts,
        providerRef: persisted.providerRef,
        promptRef: persisted.promptRef,
        payload: persisted.payload ?? {},
        created: persisted.created ?? now2,
        updated: persisted.updated ?? now2,
        errors: persisted.errors
      };
      this.tasks.set(restoredTask.id, restoredTask);
    }
    this.lockManager.clear();
    this.logger.info("TaskQueue", "\u961F\u5217\u72B6\u6001\u6062\u590D\u6210\u529F", {
      taskCount: this.tasks.size,
      paused: this.paused,
      migrated,
      invalidTasks: invalidCount
    });
    if (migrated || invalidCount > 0) {
      await this.flushSave();
    }
  }
  /**
   * 限制历史任务数量，避免 queue-state.json 无限增长
   */
  trimHistory() {
    const limit = this.settingsStore.getSettings().maxTaskHistory || _TaskQueue.DEFAULT_TASK_HISTORY_LIMIT;
    const removableStates = /* @__PURE__ */ new Set(["Completed", "Failed", "Cancelled"]);
    const candidates = Array.from(this.tasks.values()).filter((task) => removableStates.has(task.state));
    if (candidates.length <= limit) {
      return;
    }
    candidates.sort((a, b) => {
      const aTime = a.updated || a.created;
      const bTime = b.updated || b.created;
      return aTime.localeCompare(bTime);
    });
    const removeCount = candidates.length - limit;
    const toRemove = candidates.slice(0, removeCount);
    for (const task of toRemove) {
      this.tasks.delete(task.id);
    }
    if (removeCount > 0) {
      this.logger.info("TaskQueue", "\u88C1\u526A\u4EFB\u52A1\u5386\u53F2", {
        removed: removeCount,
        limit
      });
    }
  }
  /**
   * 生成任务 ID
   */
  generateTaskId() {
    return `task-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * 发布事件
   */
  publishEvent(event2) {
    for (const listener of this.listeners) {
      try {
        listener(event2);
      } catch (error) {
        this.logger.error("TaskQueue", "\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error, {
          eventType: event2.type
        });
      }
    }
  }
  /**
   * 检查锁冲突
   * 
   * 遵循 Requirements 2.1：入队前检查 LockManager 是否存在冲突锁
   * 
   * @param nodeId 节点 ID
   * @param crType 知识类型（可选）
   * @returns 如果存在冲突，返回错误信息；否则返回 null
   */
  checkLockConflict(nodeId, _crType) {
    if (this.lockManager.isLocked(nodeId)) {
      return { lockKey: nodeId, lockType: "node" };
    }
    if (_crType) {
      const typeLockKey = `type:${_crType}`;
      if (this.lockManager.isLocked(typeLockKey)) {
        return { lockKey: typeLockKey, lockType: "type" };
      }
    }
    return null;
  }
};

// src/core/schema-registry.ts
var DOMAIN_SCHEMA = {
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: [
    "definition",
    "teleology",
    "methodology",
    "boundaries",
    "historical_genesis",
    "holistic_understanding",
    "sub_domains",
    "issues"
  ],
  properties: {
    definition: {
      type: "string",
      description: "\u5B9A\u4E49",
      minLength: 50
    },
    teleology: {
      type: "string",
      description: "\u76EE\u7684\u8BBA",
      minLength: 50
    },
    methodology: {
      type: "string",
      description: "\u65B9\u6CD5\u8BBA",
      minLength: 50
    },
    boundaries: {
      type: "array",
      description: "\u8FB9\u754C",
      items: { type: "string", minLength: 10 }
    },
    historical_genesis: {
      type: "string",
      description: "\u5386\u53F2\u8D77\u6E90",
      minLength: 100
    },
    holistic_understanding: {
      type: "string",
      description: "\u6574\u4F53\u7406\u89E3",
      minLength: 100
    },
    sub_domains: {
      type: "array",
      description: "\u5B50\u9886\u57DF",
      items: {
        type: "object",
        required: ["name", "description"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          description: { type: "string", description: "\u63CF\u8FF0" }
        }
      }
    },
    issues: {
      type: "array",
      description: "\u8BAE\u9898",
      items: {
        type: "object",
        required: ["name", "description"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          description: { type: "string", description: "\u63CF\u8FF0" }
        }
      }
    }
  }
};
var ISSUE_SCHEMA = {
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: [
    "definition",
    "core_tension",
    "significance",
    "epistemic_barrier",
    "counter_intuition",
    "historical_genesis",
    "sub_issues",
    "stakeholder_perspectives",
    "boundary_conditions",
    "theories",
    "holistic_understanding"
  ],
  properties: {
    definition: {
      type: "string",
      description: "\u5B9A\u4E49",
      minLength: 50
    },
    core_tension: {
      type: "string",
      description: "\u6838\u5FC3\u5F20\u529B",
      minLength: 10
    },
    significance: {
      type: "string",
      description: "\u91CD\u8981\u6027",
      minLength: 50
    },
    epistemic_barrier: {
      type: "string",
      description: "\u8BA4\u8BC6\u8BBA\u969C\u788D",
      minLength: 50
    },
    counter_intuition: {
      type: "string",
      description: "\u53CD\u76F4\u89C9\u6027",
      minLength: 50
    },
    historical_genesis: {
      type: "string",
      description: "\u5386\u53F2\u8D77\u6E90",
      minLength: 100
    },
    sub_issues: {
      type: "array",
      description: "\u5B50\u8BAE\u9898",
      items: {
        type: "object",
        required: ["name", "description"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          description: { type: "string", description: "\u63CF\u8FF0" }
        }
      }
    },
    stakeholder_perspectives: {
      type: "array",
      description: "\u5229\u76CA\u76F8\u5173\u8005\u89C6\u89D2",
      items: {
        type: "object",
        required: ["stakeholder", "perspective"],
        properties: {
          stakeholder: { type: "string", description: "\u5229\u76CA\u76F8\u5173\u8005" },
          perspective: { type: "string", description: "\u89C2\u70B9" }
        }
      }
    },
    boundary_conditions: {
      type: "array",
      description: "\u8FB9\u754C\u6761\u4EF6",
      items: { type: "string", minLength: 10 }
    },
    theories: {
      type: "array",
      description: "\u7406\u8BBA",
      items: {
        type: "object",
        required: ["name", "status", "brief"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          status: {
            type: "string",
            enum: ["mainstream", "marginal", "falsified"],
            description: "\u72B6\u6001"
          },
          brief: { type: "string", description: "\u7B80\u4ECB" }
        }
      }
    },
    holistic_understanding: {
      type: "string",
      description: "\u6574\u4F53\u7406\u89E3",
      minLength: 100
    }
  }
};
var THEORY_SCHEMA = {
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: [
    "definition",
    "axioms",
    "sub_theories",
    "logical_structure",
    "entities",
    "mechanisms",
    "core_predictions",
    "limitations",
    "historical_genesis",
    "holistic_understanding"
  ],
  properties: {
    definition: {
      type: "string",
      description: "\u5B9A\u4E49",
      minLength: 50
    },
    axioms: {
      type: "array",
      description: "\u516C\u7406",
      items: {
        type: "object",
        required: ["statement", "justification"],
        properties: {
          statement: { type: "string", description: "\u9648\u8FF0" },
          justification: { type: "string", description: "\u7406\u7531" }
        }
      }
    },
    sub_theories: {
      type: "array",
      description: "\u5B50\u7406\u8BBA",
      items: {
        type: "object",
        required: ["name", "description"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          description: { type: "string", description: "\u63CF\u8FF0" }
        }
      }
    },
    logical_structure: {
      type: "string",
      description: "\u903B\u8F91\u7ED3\u6784",
      minLength: 100
    },
    entities: {
      type: "array",
      description: "\u5B9E\u4F53",
      items: {
        type: "object",
        required: ["name", "role", "attributes"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          role: { type: "string", description: "\u89D2\u8272" },
          attributes: { type: "string", description: "\u5C5E\u6027" }
        }
      }
    },
    mechanisms: {
      type: "array",
      description: "\u673A\u5236",
      items: {
        type: "object",
        required: ["name", "process", "function"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          process: { type: "string", description: "\u8FC7\u7A0B" },
          function: { type: "string", description: "\u529F\u80FD" }
        }
      }
    },
    core_predictions: {
      type: "array",
      description: "\u6838\u5FC3\u9884\u6D4B",
      items: { type: "string", description: "\u9884\u6D4B" }
    },
    limitations: {
      type: "array",
      description: "\u5C40\u9650\u6027",
      items: { type: "string", description: "\u9650\u5236" }
    },
    historical_genesis: {
      type: "string",
      description: "\u5386\u53F2\u8D77\u6E90",
      minLength: 100
    },
    holistic_understanding: {
      type: "string",
      description: "\u6574\u4F53\u7406\u89E3",
      minLength: 100
    }
  }
};
var ENTITY_SCHEMA = {
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: [
    "definition",
    "classification",
    "properties",
    "states",
    "constraints",
    "composition",
    "distinguishing_features",
    "examples",
    "counter_examples",
    "holistic_understanding"
  ],
  properties: {
    definition: {
      type: "string",
      description: "\u5B9A\u4E49",
      minLength: 50
    },
    classification: {
      type: "object",
      required: ["genus", "differentia"],
      properties: {
        genus: { type: "string", description: "\u5C5E" },
        differentia: { type: "string", description: "\u79CD\u5DEE" }
      }
    },
    properties: {
      type: "array",
      description: "\u5C5E\u6027",
      items: {
        type: "object",
        required: ["name", "type", "description"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          type: { type: "string", enum: ["intrinsic", "extrinsic"], description: "\u7C7B\u578B" },
          description: { type: "string", description: "\u63CF\u8FF0" }
        }
      }
    },
    states: {
      type: "array",
      description: "\u72B6\u6001",
      items: {
        type: "object",
        required: ["name", "description"],
        properties: {
          name: { type: "string", description: "\u540D\u79F0" },
          description: { type: "string", description: "\u63CF\u8FF0" }
        }
      }
    },
    constraints: {
      type: "array",
      description: "\u7EA6\u675F",
      items: { type: "string", description: "\u7EA6\u675F" }
    },
    composition: {
      type: "object",
      required: ["has_parts", "part_of"],
      properties: {
        has_parts: {
          type: "array",
          items: { type: "string" },
          description: "\u7EC4\u6210\u90E8\u5206"
        },
        part_of: { type: "string", description: "\u6240\u5C5E\u7CFB\u7EDF" }
      }
    },
    distinguishing_features: {
      type: "array",
      description: "\u533A\u522B\u7279\u5F81",
      items: { type: "string", description: "\u7279\u5F81" }
    },
    examples: {
      type: "array",
      description: "\u793A\u4F8B",
      items: { type: "string", description: "\u793A\u4F8B" }
    },
    counter_examples: {
      type: "array",
      description: "\u53CD\u4F8B",
      items: { type: "string", description: "\u53CD\u4F8B" }
    },
    holistic_understanding: {
      type: "string",
      description: "\u6574\u4F53\u7406\u89E3",
      minLength: 100
    }
  }
};
var MECHANISM_SCHEMA = {
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: [
    "definition",
    "trigger_conditions",
    "operates_on",
    "causal_chain",
    "modulation",
    "inputs",
    "outputs",
    "side_effects",
    "termination_conditions",
    "holistic_understanding"
  ],
  properties: {
    definition: {
      type: "string",
      description: "\u5B9A\u4E49",
      minLength: 50
    },
    trigger_conditions: {
      type: "array",
      description: "\u89E6\u53D1\u6761\u4EF6",
      items: { type: "string", description: "\u6761\u4EF6" }
    },
    operates_on: {
      type: "array",
      description: "\u4F5C\u7528\u5BF9\u8C61",
      items: {
        type: "object",
        required: ["entity", "role"],
        properties: {
          entity: { type: "string", description: "\u5B9E\u4F53" },
          role: { type: "string", description: "\u89D2\u8272" }
        }
      }
    },
    causal_chain: {
      type: "array",
      description: "\u56E0\u679C\u94FE",
      items: {
        type: "object",
        required: ["step", "description", "interaction"],
        properties: {
          step: { type: "number", description: "\u6B65\u9AA4" },
          description: { type: "string", description: "\u63CF\u8FF0" },
          interaction: { type: "string", description: "\u4EA4\u4E92" }
        }
      }
    },
    modulation: {
      type: "array",
      description: "\u8C03\u8282",
      items: {
        type: "object",
        required: ["factor", "effect", "mechanism"],
        properties: {
          factor: { type: "string", description: "\u56E0\u7D20" },
          effect: { type: "string", enum: ["promotes", "inhibits", "regulates"], description: "\u6548\u679C" },
          mechanism: { type: "string", description: "\u673A\u5236" }
        }
      }
    },
    inputs: {
      type: "array",
      description: "\u8F93\u5165",
      items: { type: "string", description: "\u8F93\u5165" }
    },
    outputs: {
      type: "array",
      description: "\u8F93\u51FA",
      items: { type: "string", description: "\u8F93\u51FA" }
    },
    side_effects: {
      type: "array",
      description: "\u526F\u4F5C\u7528",
      items: { type: "string", description: "\u526F\u4F5C\u7528" }
    },
    termination_conditions: {
      type: "array",
      description: "\u7EC8\u6B62\u6761\u4EF6",
      items: { type: "string", description: "\u6761\u4EF6" }
    },
    holistic_understanding: {
      type: "string",
      description: "\u6574\u4F53\u7406\u89E3",
      minLength: 100
    }
  }
};
var DEFINE_TASK_SCHEMA = {
  $schema: "http://json-schema.org/draft-07/schema#",
  type: "object",
  required: ["classification_result"],
  properties: {
    classification_result: {
      type: "object",
      required: ["Domain", "Issue", "Theory", "Entity", "Mechanism"],
      properties: {
        Domain: {
          type: "object",
          required: ["standard_name_cn", "standard_name_en", "confidence_score"],
          properties: {
            standard_name_cn: { type: "string" },
            standard_name_en: { type: "string" },
            confidence_score: { type: "number", minimum: 0, maximum: 1 }
          }
        },
        Issue: {
          type: "object",
          required: ["standard_name_cn", "standard_name_en", "confidence_score"],
          properties: {
            standard_name_cn: { type: "string" },
            standard_name_en: { type: "string" },
            confidence_score: { type: "number", minimum: 0, maximum: 1 }
          }
        },
        Theory: {
          type: "object",
          required: ["standard_name_cn", "standard_name_en", "confidence_score"],
          properties: {
            standard_name_cn: { type: "string" },
            standard_name_en: { type: "string" },
            confidence_score: { type: "number", minimum: 0, maximum: 1 }
          }
        },
        Entity: {
          type: "object",
          required: ["standard_name_cn", "standard_name_en", "confidence_score"],
          properties: {
            standard_name_cn: { type: "string" },
            standard_name_en: { type: "string" },
            confidence_score: { type: "number", minimum: 0, maximum: 1 }
          }
        },
        Mechanism: {
          type: "object",
          required: ["standard_name_cn", "standard_name_en", "confidence_score"],
          properties: {
            standard_name_cn: { type: "string" },
            standard_name_en: { type: "string" },
            confidence_score: { type: "number", minimum: 0, maximum: 1 }
          }
        }
      }
    }
  }
};
var SchemaRegistry = class {
  schemas;
  constructor() {
    this.schemas = /* @__PURE__ */ new Map([
      ["Domain", DOMAIN_SCHEMA],
      ["Issue", ISSUE_SCHEMA],
      ["Theory", THEORY_SCHEMA],
      ["Entity", ENTITY_SCHEMA],
      ["Mechanism", MECHANISM_SCHEMA]
    ]);
  }
  getSchema(type) {
    const schema4 = this.schemas.get(type);
    if (!schema4) {
      throw new Error(`Unknown type: ${type}`);
    }
    return schema4;
  }
  getDefineSchema() {
    return DEFINE_TASK_SCHEMA;
  }
  getFieldDescriptions(type) {
    const schema4 = this.getSchema(type);
    const descriptions = [];
    const fieldLabels = this.getFieldLabels(type);
    if (schema4.properties) {
      for (const [name, prop2] of Object.entries(schema4.properties)) {
        descriptions.push({
          name,
          type: prop2.type,
          required: schema4.required?.includes(name) ?? false,
          description: fieldLabels[name] || prop2.description || name,
          example: this.getExampleForField(type, name)
        });
      }
    }
    return descriptions;
  }
  /** 获取字段的中文标签映射 */
  getFieldLabels(type) {
    const commonLabels = {
      definition: "\u5B9A\u4E49",
      holistic_understanding: "\u6574\u4F53\u7406\u89E3",
      historical_genesis: "\u5386\u53F2\u8D77\u6E90"
    };
    const typeSpecificLabels = {
      Domain: {
        ...commonLabels,
        teleology: "\u76EE\u7684\u8BBA",
        methodology: "\u65B9\u6CD5\u8BBA",
        boundaries: "\u8FB9\u754C",
        sub_domains: "\u5B50\u9886\u57DF",
        issues: "\u6838\u5FC3\u8BAE\u9898"
      },
      Issue: {
        ...commonLabels,
        core_tension: "\u6838\u5FC3\u5F20\u529B",
        significance: "\u91CD\u8981\u6027",
        epistemic_barrier: "\u8BA4\u8BC6\u8BBA\u969C\u788D",
        counter_intuition: "\u53CD\u76F4\u89C9\u6027",
        sub_issues: "\u5B50\u8BAE\u9898",
        stakeholder_perspectives: "\u5229\u76CA\u76F8\u5173\u8005\u89C6\u89D2",
        boundary_conditions: "\u8FB9\u754C\u6761\u4EF6",
        theories: "\u76F8\u5173\u7406\u8BBA"
      },
      Theory: {
        ...commonLabels,
        axioms: "\u516C\u7406",
        sub_theories: "\u5B50\u7406\u8BBA",
        logical_structure: "\u903B\u8F91\u7ED3\u6784",
        entities: "\u6838\u5FC3\u5B9E\u4F53",
        mechanisms: "\u6838\u5FC3\u673A\u5236",
        core_predictions: "\u6838\u5FC3\u9884\u6D4B",
        limitations: "\u5C40\u9650\u6027"
      },
      Entity: {
        ...commonLabels,
        classification: "\u5206\u7C7B",
        properties: "\u5C5E\u6027",
        states: "\u72B6\u6001",
        constraints: "\u7EA6\u675F",
        composition: "\u7EC4\u6210\u7ED3\u6784",
        distinguishing_features: "\u533A\u522B\u7279\u5F81",
        examples: "\u793A\u4F8B",
        counter_examples: "\u53CD\u4F8B"
      },
      Mechanism: {
        ...commonLabels,
        trigger_conditions: "\u89E6\u53D1\u6761\u4EF6",
        operates_on: "\u4F5C\u7528\u5BF9\u8C61",
        causal_chain: "\u56E0\u679C\u94FE",
        modulation: "\u8C03\u8282\u56E0\u7D20",
        inputs: "\u8F93\u5165",
        outputs: "\u8F93\u51FA",
        side_effects: "\u526F\u4F5C\u7528",
        termination_conditions: "\u7EC8\u6B62\u6761\u4EF6"
      }
    };
    return typeSpecificLabels[type] || commonLabels;
  }
  getValidationRules(type) {
    const schema4 = this.getSchema(type);
    const rules = [];
    if (schema4.required) {
      rules.push(`\u5FC5\u586B\u5B57\u6BB5: ${schema4.required.join(", ")}`);
    }
    if (schema4.properties) {
      for (const [name, prop2] of Object.entries(schema4.properties)) {
        if (prop2.minLength) {
          rules.push(`${name}: \u6700\u5C0F\u957F\u5EA6 ${prop2.minLength} \u5B57\u7B26`);
        }
        if (prop2.minItems) {
          rules.push(`${name}: \u6700\u5C11 ${prop2.minItems} \u9879`);
        }
        if (prop2.pattern) {
          rules.push(`${name}: \u5FC5\u987B\u5339\u914D\u683C\u5F0F ${prop2.pattern}`);
        }
      }
    }
    return rules;
  }
  getAllTypes() {
    return Array.from(this.schemas.keys());
  }
  isValidType(type) {
    return this.schemas.has(type);
  }
  getExampleForField(type, fieldName) {
    const examples = {
      Domain: {
        definition: "\u91CF\u5B50\u529B\u5B66\u662F\u7269\u7406\u5B66\u7684\u4E00\u4E2A\u57FA\u7840\u5206\u652F...",
        teleology: "\u63ED\u793A\u5B87\u5B99\u7269\u8D28\u57FA\u5E95\u7684'\u8BED\u6CD5\u89C4\u5219'...",
        methodology: "\u5229\u7528\u7EBF\u6027\u4EE3\u6570\u3001\u590D\u6570\u57DF\u4E0A\u7684\u5E0C\u5C14\u4F2F\u7279\u7A7A\u95F4..."
      },
      Issue: {
        definition: "\u6D4B\u91CF\u95EE\u9898\u662F\u91CF\u5B50\u529B\u5B66\u4E2D\u6700\u6838\u5FC3\u7684\u8BA4\u8BC6\u8BBA\u5371\u673A...",
        core_tension: "\u786E\u5B9A\u6027\u6F14\u5316 vs \u975E\u786E\u5B9A\u6027\u574D\u7F29\uFF1B\u89C2\u5BDF\u8005\u89D2\u8272\uFF1B\u9000\u76F8\u5E72\u89E3\u91CA",
        significance: "\u7406\u8BBA\u672C\u8EAB\u65E0\u6CD5\u89E3\u91CA\u8FD9\u79CD\u4ECE'\u53EF\u80FD\u6027'\u5230'\u786E\u5B9A\u6027'\u7684\u7A81\u53D8\u673A\u5236..."
      },
      Theory: {
        definition: "\u72ED\u4E49\u76F8\u5BF9\u8BBA\u662F\u63CF\u8FF0\u65F6\u7A7A\u7ED3\u6784\u7684\u7406\u8BBA\u6846\u67B6...",
        logical_structure: "\u4ECE\u5149\u901F\u4E0D\u53D8\u539F\u7406\u548C\u76F8\u5BF9\u6027\u539F\u7406\u51FA\u53D1..."
      },
      Entity: {
        definition: "\u6CE2\u51FD\u6570\u662F\u91CF\u5B50\u529B\u5B66\u4E2D\u63CF\u8FF0\u7C92\u5B50\u72B6\u6001\u7684\u6570\u5B66\u5BF9\u8C61...",
        genus: "\u6570\u5B66\u51FD\u6570",
        differentia: "\u5B9A\u4E49\u5728\u5E0C\u5C14\u4F2F\u7279\u7A7A\u95F4\u4E2D\uFF0C\u6A21\u65B9\u8868\u793A\u6982\u7387\u5BC6\u5EA6"
      },
      Mechanism: {
        definition: "\u81EA\u7136\u9009\u62E9\u662F\u751F\u7269\u8FDB\u5316\u7684\u6838\u5FC3\u673A\u5236...",
        trigger_conditions: "\u79CD\u7FA4\u5185\u5B58\u5728\u9057\u4F20\u53D8\u5F02\uFF0C\u73AF\u5883\u8D44\u6E90\u6709\u9650"
      }
    };
    return examples[type]?.[fieldName];
  }
};
var schemaRegistry = new SchemaRegistry();
var WRITE_PHASES = {
  Domain: [
    {
      id: "framework",
      fields: ["definition", "teleology", "methodology", "boundaries"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u9886\u57DF\u7684\u6982\u5FF5\u6846\u67B6\uFF1A\u7ED9\u51FA\u4E25\u683C\u7684\u5F62\u5F0F\u5B9A\u4E49\uFF08\u5C5E+\u79CD\u5DEE\uFF09\uFF0C\u9610\u660E\u5176\u7EC8\u6781\u76EE\u7684\uFF08\u4E3A\u4EC0\u4E48\u5B58\u5728\uFF09\uFF0C\u63CF\u8FF0\u5176\u8BA4\u8BC6\u8BBA\u57FA\u7840\uFF08\u5982\u4F55\u9A8C\u8BC1\u771F\u7406\uFF09\uFF0C\u5E76\u5212\u5B9A\u660E\u786E\u7684\u8FB9\u754C\uFF08\u5B83\u4E0D\u662F\u4EC0\u4E48\uFF09\u3002"
    },
    {
      id: "narrative",
      fields: ["historical_genesis"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u9886\u57DF\u7684\u601D\u60F3\u53F2\u8C31\u7CFB\uFF1A\u8FFD\u6EAF\u5176\u8D77\u6E90\u3001\u5371\u673A\u3001\u8303\u5F0F\u8F6C\u6362\u548C\u5173\u952E\u4EBA\u7269\u3002\u7528\u8FA9\u8BC1\u6CD5\u7ED3\u6784\uFF08\u6B63\u9898\u2192\u53CD\u9898\u2192\u5408\u9898\uFF09\u91CD\u5EFA\u601D\u60F3\u7684\u620F\u5267\uFF0C\u4E0D\u8981\u7F57\u5217\u4E8B\u4EF6\u3002"
    },
    {
      id: "synthesis",
      fields: ["holistic_understanding"],
      focusInstruction: "\u805A\u7126\u4E8E\u5BF9\u8FD9\u4E2A\u9886\u57DF\u7684\u54F2\u5B66\u7EFC\u5408\u7406\u89E3\uFF1A\u672C\u4F53\u8BBA\uFF08\u8FD9\u4E2A\u9886\u57DF\u4E2D\u5B58\u5728\u7684\u6839\u672C\u6027\u8D28\u662F\u4EC0\u4E48\uFF1F\uFF09\u3001\u8BA4\u8BC6\u8BBA\uFF08\u77E5\u8BC6\u5982\u4F55\u83B7\u53D6\u548C\u9A8C\u8BC1\uFF1F\uFF09\u3001\u5B9E\u8DF5\u8BBA\uFF08\u5982\u4F55\u5728\u4EBA\u7C7B\u5B9E\u8DF5\u4E2D\u4F53\u73B0\uFF1F\uFF09\u3002\u7ED3\u5408\u524D\u9762\u5DF2\u751F\u6210\u7684\u5185\u5BB9\uFF0C\u7ED9\u51FA\u4E00\u4E2A\u5B8C\u6574\u7684\u8BA4\u77E5\u5730\u56FE\u3002"
    },
    {
      id: "structure",
      fields: ["sub_domains", "issues"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u9886\u57DF\u7684\u5185\u90E8\u7ED3\u6784\u5206\u89E3\uFF1A\u5217\u51FA\u5B50\u9886\u57DF\uFF08MECE \u539F\u5219\uFF09\u5E76\u8BF4\u660E\u6BCF\u4E2A\u5728\u6574\u4F53\u4E2D\u7684\u529F\u80FD\uFF1B\u5217\u51FA\u6838\u5FC3\u8BAE\u9898\uFF08\u4F18\u5148\u6D8C\u73B0\u6027\u8BAE\u9898\u2014\u2014\u7531\u90E8\u5206\u4EA4\u4E92\u6216\u6574\u4F53\u4EA7\u751F\u7684\u95EE\u9898\uFF09\u3002"
    }
  ],
  Issue: [
    {
      id: "framework",
      fields: ["definition", "core_tension", "significance", "epistemic_barrier", "counter_intuition"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u8BAE\u9898\u7684\u95EE\u9898\u6846\u67B6\uFF1A\u7ED9\u51FA\u4E25\u683C\u7684\u5F62\u5F0F\u5B9A\u4E49\uFF0C\u660E\u786E\u6838\u5FC3\u5F20\u529B\uFF08\u4E8C\u5143\u5BF9\u7ACB\u7528 A vs B\uFF0C\u591A\u6781\u7528\u5206\u53F7\u5206\u9694\uFF09\uFF0C\u89E3\u91CA\u5176\u91CD\u8981\u6027\uFF08\u5982\u679C\u4E0D\u89E3\u51B3\u4F1A\u600E\u6837\uFF09\uFF0C\u5206\u6790\u8BA4\u8BC6\u8BBA\u969C\u788D\uFF08\u4E3A\u4EC0\u4E48\u81F3\u4ECA\u672A\u89E3\u51B3\uFF09\uFF0C\u4EE5\u53CA\u5B83\u5982\u4F55\u6311\u6218\u5E38\u8BC6\u3002"
    },
    {
      id: "narrative",
      fields: ["historical_genesis"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u95EE\u9898\u7684\u601D\u60F3\u53F2\u8C31\u7CFB\uFF1A\u8FFD\u6EAF\u77DB\u76FE\u4F55\u65F6\u53D8\u5F97\u660E\u663E\uFF0C\u4EC0\u4E48\u5177\u4F53\u4E8B\u4EF6\u6216\u53D1\u73B0\u89E6\u53D1\u4E86\u5B83\u3002\u7528\u8FA9\u8BC1\u6CD5\u7ED3\u6784\u7EC4\u7EC7\u53D9\u4E8B\u3002"
    },
    {
      id: "synthesis",
      fields: ["holistic_understanding"],
      focusInstruction: "\u805A\u7126\u4E8E\u5BF9\u8FD9\u4E2A\u8BAE\u9898\u7684\u54F2\u5B66\u7EFC\u5408\u7406\u89E3\uFF1A\u8FD9\u4E2A\u672A\u89E3\u51B3\u7684\u5F20\u529B\u5982\u4F55\u5851\u9020\u4E86\u6574\u4E2A\u9886\u57DF\uFF1F\u89E3\u51B3\u5B83\u7684\u524D\u6CBF\u5728\u54EA\u91CC\uFF1F\u7ED3\u5408\u524D\u9762\u5DF2\u751F\u6210\u7684\u5185\u5BB9\uFF0C\u7ED9\u51FA\u5B8C\u6574\u7684\u8BA4\u77E5\u7EFC\u5408\u3002"
    },
    {
      id: "structure",
      fields: ["sub_issues", "stakeholder_perspectives", "boundary_conditions", "theories"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u8BAE\u9898\u7684\u7ED3\u6784\u5206\u89E3\uFF1A\u5217\u51FA\u5B50\u8BAE\u9898\uFF08MECE \u539F\u5219\uFF09\uFF0C\u5217\u51FA\u5404\u5229\u76CA\u76F8\u5173\u65B9\u7684\u7ACB\u573A\uFF0C\u660E\u786E\u8FB9\u754C\u6761\u4EF6\uFF08\u4F55\u65F6\u8FD9\u4E2A\u8BAE\u9898\u4E0D\u76F8\u5173\uFF09\uFF0C\u4EE5\u53CA\u8BD5\u56FE\u89E3\u51B3\u5B83\u7684\u7406\u8BBA\uFF08\u6807\u6CE8\u4E3B\u6D41/\u8FB9\u7F18/\u5DF2\u8BC1\u4F2A\uFF09\u3002"
    }
  ],
  Theory: [
    {
      id: "framework",
      fields: ["definition", "axioms", "logical_structure"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u7406\u8BBA\u7684\u903B\u8F91\u9AA8\u67B6\uFF1A\u7ED9\u51FA\u4E25\u683C\u7684\u5F62\u5F0F\u5B9A\u4E49\uFF0C\u5217\u51FA\u57FA\u672C\u516C\u7406\u53CA\u5176\u7406\u7531\uFF0C\u7136\u540E\u91CD\u5EFA\u4ECE\u516C\u7406\u5230\u7ED3\u8BBA\u7684\u5B8C\u6574\u63A8\u7406\u94FE\uFF08\u516C\u7406 A + \u516C\u7406 B \u2192 \u4E2D\u95F4\u5F15\u7406 \u2192 \u673A\u5236\u6FC0\u6D3B \u2192 \u6700\u7EC8\u7ED3\u8BBA/\u9884\u6D4B\uFF09\u3002"
    },
    {
      id: "narrative",
      fields: ["historical_genesis"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u7406\u8BBA\u7684\u601D\u60F3\u8003\u53E4\uFF1A\u524D\u8303\u5F0F\u72B6\u6001\uFF08\u4E4B\u524D\u76F8\u4FE1\u4EC0\u4E48\uFF1F\uFF09\u2192 \u53CD\u5E38\uFF08\u4EC0\u4E48\u51FA\u4E86\u95EE\u9898\uFF1F\uFF09\u2192 \u706B\u82B1\uFF08\u5177\u4F53\u7684\u6D1E\u89C1/\u8BBA\u6587\uFF09\u2192 \u6218\u6597\uFF08\u62B5\u6297\u4E0E\u63A5\u53D7\uFF09\u3002\u63D0\u53CA\u5177\u4F53\u7684\u5173\u952E\u4EBA\u7269\u3001\u5F00\u521B\u6027\u8BBA\u6587\u548C\u89E6\u53D1\u7406\u8BBA\u7684\u5177\u4F53\u667A\u8BC6\u5371\u673A\u3002"
    },
    {
      id: "synthesis",
      fields: ["holistic_understanding", "core_predictions", "limitations"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u7406\u8BBA\u7684\u54F2\u5B66\u542B\u4E49\u548C\u8FB9\u754C\uFF1A\u672C\u4F53\u8BBA\u627F\u8BFA\uFF08\u6839\u636E\u8FD9\u4E2A\u7406\u8BBA\uFF0C\u73B0\u5B9E\u7684\u672C\u8D28\u662F\u4EC0\u4E48\uFF1F\uFF09\u3001\u8BA4\u8BC6\u8BBA\u5730\u4F4D\uFF08\u6211\u4EEC\u5982\u4F55\u77E5\u9053\u5B83\u662F\u771F\u7684\uFF1F\uFF09\u3001\u76EE\u7684\u8BBA\uFF08\u7EC8\u6781\u89E3\u91CA\u76EE\u6807\u662F\u4EC0\u4E48\uFF1F\uFF09\u3002\u540C\u65F6\u5217\u51FA\u53EF\u68C0\u9A8C\u7684\u9884\u6D4B\u548C\u7406\u8BBA\u7684\u5C40\u9650\u6027\u3002"
    },
    {
      id: "structure",
      fields: ["sub_theories", "entities", "mechanisms"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u7406\u8BBA\u7684\u5185\u90E8\u7EC4\u4EF6\uFF1A\u5217\u51FA\u5B50\u7406\u8BBA\uFF08MECE \u539F\u5219\uFF09\uFF0C\u63D0\u53D6\u6784\u6210\u6027\u5B9E\u4F53\uFF08\u91CD\u5EFA\u7406\u8BBA\u903B\u8F91\u6240\u9700\u7684\u6700\u5C0F\u5145\u5206\u96C6\uFF09\uFF0C\u4EE5\u53CA\u56E0\u679C\u673A\u5236\uFF08\u6BCF\u4E2A\u673A\u5236\u5FC5\u987B\u4F5C\u7528\u4E8E\u5177\u4F53\u5B9E\u4F53\uFF09\u3002"
    }
  ],
  Entity: [
    {
      id: "framework",
      fields: ["definition", "classification", "properties", "states", "constraints"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u5B9E\u4F53\u7684\u672C\u4F53\u8BBA\u5B9A\u4E49\uFF1A\u7ED9\u51FA\u4E25\u683C\u7684\u5F62\u5F0F\u5B9A\u4E49\uFF08\u5C5E+\u79CD\u5DEE\uFF09\uFF0C\u660E\u786E\u5206\u7C7B\uFF08\u76F4\u63A5\u7236\u7C7B\u522B\u548C\u533A\u5206\u7279\u5F81\uFF09\uFF0C\u5217\u51FA\u5C5E\u6027\uFF08\u5185\u5728/\u5916\u5728\uFF09\u3001\u53EF\u80FD\u72B6\u6001\u548C\u7EA6\u675F\u6761\u4EF6\u3002"
    },
    {
      id: "synthesis",
      fields: ["holistic_understanding", "composition", "distinguishing_features", "examples", "counter_examples"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u5B9E\u4F53\u7684\u8BA4\u77E5\u5B9A\u4F4D\uFF1A\u5B83\u5728\u9886\u57DF\u4E2D\u626E\u6F14\u4EC0\u4E48\u89D2\u8272\uFF08\u4E3B\u89D2\u8FD8\u662F\u9053\u5177\uFF09\uFF1F\u5B83\u7684\u7EC4\u6210\u7ED3\u6784\uFF08\u5411\u4E0A/\u5411\u4E0B\uFF09\uFF0C\u4E0E\u76F8\u4F3C\u6982\u5FF5\u7684\u4E25\u683C\u5BF9\u6BD4\uFF08\u4E3A\u4EC0\u4E48 X \u4E0D\u662F Y\uFF1F\uFF09\uFF0C\u4EE5\u53CA\u5177\u4F53\u7684\u6B63\u4F8B\u548C\u53CD\u4F8B\u3002"
    }
  ],
  Mechanism: [
    {
      id: "framework",
      fields: ["definition", "trigger_conditions", "operates_on", "inputs", "outputs", "side_effects", "termination_conditions"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u673A\u5236\u7684\u52A8\u529B\u5B66\u6846\u67B6\uFF1A\u7ED9\u51FA\u4E25\u683C\u7684\u5F62\u5F0F\u5B9A\u4E49\uFF0C\u660E\u786E\u89E6\u53D1\u6761\u4EF6\u3001\u4F5C\u7528\u5BF9\u8C61\uFF08\u4E3B\u4F53/\u5BA2\u4F53\uFF09\u3001\u8F93\u5165\u3001\u8F93\u51FA\u3001\u526F\u4F5C\u7528\u548C\u7EC8\u6B62\u6761\u4EF6\u3002"
    },
    {
      id: "process",
      fields: ["causal_chain", "modulation"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u673A\u5236\u7684\u56E0\u679C\u8FC7\u7A0B\uFF1A\u5C06\u673A\u5236\u5206\u89E3\u4E3A\u79BB\u6563\u7684\u539F\u5B50\u6B65\u9AA4\uFF08\u89E6\u53D1 \u2192 \u6B65\u9AA41 \u2192 \u6B65\u9AA42 \u2192 ... \u2192 \u7ED3\u679C\uFF09\uFF0C\u4E0D\u8981\u8DF3\u8FC7\u903B\u8F91\u73AF\u8282\u3002\u540C\u65F6\u5217\u51FA\u8C03\u8282\u56E0\u7D20\uFF08\u4EC0\u4E48\u52A0\u901F/\u51CF\u901F/\u8C03\u8282\u5B83\uFF09\u3002"
    },
    {
      id: "synthesis",
      fields: ["holistic_understanding"],
      focusInstruction: "\u805A\u7126\u4E8E\u8FD9\u4E2A\u673A\u5236\u7684\u7CFB\u7EDF\u610F\u4E49\uFF1A\u5B83\u5982\u4F55\u9A71\u52A8\u7CFB\u7EDF\u7684\u6F14\u5316\u6216\u7A33\u5B9A\uFF1F\u5C06\u5FAE\u89C2\u8FC7\u7A0B\u8FDE\u63A5\u5230\u5B8F\u89C2\u73B0\u8C61\u3002\u7ED3\u5408\u524D\u9762\u5DF2\u751F\u6210\u7684\u56E0\u679C\u94FE\u548C\u8C03\u8282\u56E0\u7D20\uFF0C\u7ED9\u51FA\u5B8C\u6574\u7684\u7CFB\u7EDF\u89C6\u89D2\u3002"
    }
  ]
};

// src/core/naming-utils.ts
var import_obsidian5 = require("obsidian");
var ILLEGAL_FILENAME_CHARS = /[\\/:*?"<>|]/g;
var KNOWN_PLACEHOLDERS = ["chinese", "english", "type", "type_cn", "uid", "alias"];
function renderNamingTemplate(template, context, logger) {
  let result = template;
  result = result.replace(/\{\{chinese\}\}/g, context.chinese || "");
  result = result.replace(/\{\{english\}\}/g, context.english || "");
  result = result.replace(/\{\{type\}\}/g, context.type || "");
  result = result.replace(/\{\{type_cn\}\}/g, context.type_cn || "");
  result = result.replace(/\{\{uid\}\}/g, context.uid || "");
  result = result.replace(/\{\{alias\}\}/g, context.alias || "");
  result = result.replace(/\{\{(\w+)\}\}/g, (_match, name) => {
    if (logger) {
      logger.warn("NamingUtils", `\u672A\u5B9A\u4E49\u7684\u547D\u540D\u6A21\u677F\u5360\u4F4D\u7B26: {{${name}}}\uFF0C\u5DF2\u66FF\u6362\u4E3A\u7A7A\u5B57\u7B26\u4E32`, {
        placeholder: name,
        template
      });
    }
    return "";
  });
  result = result.replace(/\(\s*\)/g, "");
  result = result.replace(/\s+/g, " ");
  result = result.trim();
  result = result.replace(ILLEGAL_FILENAME_CHARS, "");
  result = result.replace(/\s+/g, " ").trim();
  return result;
}
function generateSignatureText(signature) {
  const parts = [signature.standardName];
  if (signature.aliases && signature.aliases.length > 0) {
    parts.push(...signature.aliases);
  }
  if (signature.coreDefinition) {
    parts.push(signature.coreDefinition);
  }
  return parts.join(" | ");
}
function createConceptSignature(standardizedData, type, namingTemplate = "{{chinese}} ({{english}})", uid, logger) {
  const standardName = renderNamingTemplate(namingTemplate, {
    chinese: standardizedData.standardName.chinese,
    english: standardizedData.standardName.english,
    type,
    type_cn: getTypeChinese(type),
    uid,
    alias: standardizedData.aliases[0]
  }, logger);
  return {
    standardName,
    aliases: standardizedData.aliases,
    coreDefinition: standardizedData.coreDefinition || "",
    type
  };
}
function getTypeChinese(type) {
  const typeMap = {
    Domain: "\u9886\u57DF",
    Issue: "\u8BAE\u9898",
    Theory: "\u7406\u8BBA",
    Entity: "\u5B9E\u4F53",
    Mechanism: "\u673A\u5236"
  };
  return typeMap[type];
}
function validateNamingTemplate(template) {
  const errors = [];
  if (!template || template.trim() === "") {
    errors.push("\u547D\u540D\u6A21\u677F\u4E0D\u80FD\u4E3A\u7A7A");
    return { valid: false, errors };
  }
  const validPlaceholders = KNOWN_PLACEHOLDERS.map((p) => `{{${p}}}`);
  const hasValidPlaceholder = validPlaceholders.some((p) => template.includes(p));
  if (!hasValidPlaceholder) {
    errors.push("\u547D\u540D\u6A21\u677F\u5FC5\u987B\u5305\u542B\u81F3\u5C11\u4E00\u4E2A\u6709\u6548\u5360\u4F4D\u7B26: {{chinese}}, {{english}}, {{type}}, {{type_cn}}, {{uid}}, {{alias}}");
  }
  const openBraces = (template.match(/\{\{/g) || []).length;
  const closeBraces = (template.match(/\}\}/g) || []).length;
  if (openBraces !== closeBraces) {
    errors.push("\u547D\u540D\u6A21\u677F\u4E2D\u5B58\u5728\u672A\u95ED\u5408\u7684\u5360\u4F4D\u7B26");
  }
  const placeholderRegex = /\{\{(\w+)\}\}/g;
  let match;
  while ((match = placeholderRegex.exec(template)) !== null) {
    const placeholder = match[1];
    if (!KNOWN_PLACEHOLDERS.includes(placeholder)) {
      errors.push(`\u65E0\u6548\u7684\u5360\u4F4D\u7B26: {{${placeholder}}}`);
    }
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function sanitizeFileName(name) {
  return name.replace(ILLEGAL_FILENAME_CHARS, "").replace(/\s+/g, " ").trim();
}
function getDirectoryForType(type, scheme) {
  return scheme[type] || "";
}
function generateFilePath(standardName, directoryScheme, type) {
  const directory = getDirectoryForType(type, directoryScheme);
  const fileName = sanitizeFileName(standardName);
  let path;
  if (directory) {
    path = `${directory}/${fileName}.md`;
  } else {
    path = `${fileName}.md`;
  }
  return (0, import_obsidian5.normalizePath)(path);
}

// src/core/standardize-mapper.ts
var TYPES = ["Domain", "Issue", "Theory", "Entity", "Mechanism"];
function normalizeConfidences(confidences) {
  const sum = TYPES.reduce((acc, type) => acc + confidences[type], 0);
  if (Math.abs(sum - 1) < 1e-4) {
    return confidences;
  }
  if (sum === 0) {
    const normalized2 = {};
    TYPES.forEach((type) => {
      normalized2[type] = 0.2;
    });
    return normalized2;
  }
  const normalized = {};
  TYPES.forEach((type) => {
    normalized[type] = confidences[type] / sum;
  });
  return normalized;
}
function mapStandardizeOutput(raw) {
  const standardNames = {
    Domain: { chinese: "", english: "" },
    Issue: { chinese: "", english: "" },
    Theory: { chinese: "", english: "" },
    Entity: { chinese: "", english: "" },
    Mechanism: { chinese: "", english: "" }
  };
  const typeConfidences = {
    Domain: 0,
    Issue: 0,
    Theory: 0,
    Entity: 0,
    Mechanism: 0
  };
  const classificationResult = raw.classification_result || raw;
  TYPES.forEach((type) => {
    const entry = classificationResult[type] || {};
    standardNames[type] = {
      chinese: entry.standard_name_cn || entry.chinese || "",
      english: entry.standard_name_en || entry.english || ""
    };
    const confidence = entry.confidence_score ?? entry.confidences ?? 0;
    typeConfidences[type] = typeof confidence === "number" ? confidence : 0;
  });
  const normalizedConfidences = normalizeConfidences(typeConfidences);
  return {
    standardNames,
    typeConfidences: normalizedConfidences,
    primaryType: getPrimaryType(normalizedConfidences),
    coreDefinition: raw.core_definition || raw.coreDefinition || ""
  };
}
function getPrimaryType(typeConfidences) {
  return TYPES.reduce(
    (best, current) => typeConfidences[current] > typeConfidences[best] ? current : best,
    "Domain"
  );
}

// src/utils/image.ts
var DATA_URL_REGEX = /data:image\/[a-zA-Z0-9.+-]+;base64,[A-Za-z0-9+/=]+/;
function extractMarkdownDataUrl(markdown) {
  const match = markdown.match(DATA_URL_REGEX);
  return match ? match[0] : null;
}
function dataUrlToArrayBuffer(dataUrl) {
  try {
    const parts = dataUrl.split(",");
    if (parts.length !== 2) {
      return err("E210_MODEL_OUTPUT_PARSE_FAILED", "data URL \u683C\u5F0F\u4E0D\u6B63\u786E");
    }
    const base64 = parts[1];
    const binary2 = Uint8Array.from(Buffer.from(base64, "base64"));
    return ok(binary2.buffer);
  } catch (error) {
    return err("E210_MODEL_OUTPUT_PARSE_FAILED", "\u89E3\u6790 data URL \u5931\u8D25", error);
  }
}
function inferImageExtension(dataUrl) {
  const mimeMatch = dataUrl.match(/data:(image\/[a-zA-Z0-9.+-]+);base64/);
  if (!mimeMatch) return "png";
  const mime = mimeMatch[1];
  const subtype = mime.split("/")[1] || "png";
  if (subtype.includes("jpeg")) return "jpg";
  return subtype;
}

// src/core/note-repository.ts
var import_obsidian6 = require("obsidian");
var NoteRepository = class {
  app;
  logger;
  constructor(app, logger) {
    this.app = app;
    this.logger = logger;
  }
  async readByPath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new Error(`\u6587\u4EF6\u4E0D\u5B58\u5728: ${path}`);
    }
    return this.app.vault.cachedRead(file);
  }
  getFileByPath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    return file instanceof import_obsidian6.TFile ? file : null;
  }
  async read(file) {
    return this.app.vault.cachedRead(file);
  }
  listMarkdownFiles() {
    return this.app.vault.getMarkdownFiles();
  }
  async modify(file, content) {
    await this.app.vault.process(file, () => content);
  }
  async readByPathIfExists(path) {
    const adapter = this.app.vault.adapter;
    const exists = await adapter.exists(path);
    if (!exists) {
      return null;
    }
    return adapter.read(path);
  }
  async deleteByPath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian6.TFile)) {
      throw new Error(`\u6587\u4EF6\u4E0D\u5B58\u5728: ${path}`);
    }
    await this.app.fileManager.trashFile(file);
  }
  async deleteByPathIfExists(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!(file instanceof import_obsidian6.TFile)) {
      return false;
    }
    await this.app.fileManager.trashFile(file);
    return true;
  }
  async writeAtomic(path, content) {
    const adapter = this.app.vault.adapter;
    const existingFile = this.app.vault.getAbstractFileByPath(path);
    if (existingFile && existingFile instanceof import_obsidian6.TFile) {
      await this.app.vault.process(existingFile, () => content);
      this.logger.debug("NoteRepository", "\u9759\u9ED8\u66F4\u65B0\u5DF2\u5B58\u5728\u6587\u4EF6", { path });
      return;
    }
    const temp = `${path}.tmp`;
    try {
      await this.ensureVaultDir(path);
      await adapter.write(temp, content);
      const verify = await adapter.read(temp);
      if (verify !== content) {
        throw new Error("\u5199\u5165\u6821\u9A8C\u5931\u8D25");
      }
      await adapter.rename(temp, path);
      this.logger.debug("NoteRepository", "\u539F\u5B50\u5199\u5165\u65B0\u6587\u4EF6", { path });
    } catch (error) {
      try {
        if (await adapter.exists(temp)) {
          await adapter.remove(temp);
        }
      } catch (cleanupError) {
        this.logger.warn("NoteRepository", "\u6E05\u7406\u4E34\u65F6\u6587\u4EF6\u5931\u8D25", {
          temp,
          error: cleanupError instanceof Error ? cleanupError.message : String(cleanupError)
        });
      }
      throw error;
    }
  }
  async ensureDirForPath(targetPath) {
    await this.ensureVaultDir(targetPath);
  }
  getAvailablePathForAttachment(fileName, currentFilePath) {
    const vaultAny = this.app.vault;
    if (typeof vaultAny.getAvailablePathForAttachment === "function") {
      return vaultAny.getAvailablePathForAttachment(fileName, currentFilePath);
    }
    const currentFile = this.getFileByPath(currentFilePath);
    if (currentFile?.parent) {
      return `${currentFile.parent.path}/${fileName}`;
    }
    return fileName;
  }
  async createBinary(path, data) {
    await this.ensureVaultDir(path);
    await this.app.vault.createBinary(path, data);
  }
  async ensureVaultDir(targetPath) {
    const adapter = this.app.vault.adapter;
    const parts = targetPath.split("/").slice(0, -1);
    if (parts.length === 0) return;
    let current = "";
    for (const part of parts) {
      current = current ? `${current}/${part}` : part;
      const exists = await adapter.exists(current);
      if (!exists) {
        await adapter.mkdir(current);
      }
    }
  }
};

// src/core/task-runner.ts
var import_obsidian7 = require("obsidian");
var TASK_PIPELINE_ORDER = [
  "define",
  "tag",
  "write",
  "index",
  "verify"
];
var TYPE_REQUIRED_FIELDS = {
  Domain: [
    "definition",
    "teleology",
    "methodology",
    "historical_genesis",
    "boundaries",
    "sub_domains",
    "issues",
    "holistic_understanding"
  ],
  Issue: [
    "definition",
    "core_tension",
    "significance",
    "epistemic_barrier",
    "counter_intuition",
    "historical_genesis",
    "sub_issues",
    "stakeholder_perspectives",
    "boundary_conditions",
    "theories",
    "holistic_understanding"
  ],
  Theory: [
    "definition",
    "axioms",
    "sub_theories",
    "logical_structure",
    "entities",
    "mechanisms",
    "core_predictions",
    "limitations",
    "historical_genesis",
    "holistic_understanding"
  ],
  Entity: [
    "definition",
    "classification",
    "properties",
    "states",
    "constraints",
    "composition",
    "distinguishing_features",
    "examples",
    "counter_examples",
    "holistic_understanding"
  ],
  Mechanism: [
    "definition",
    "trigger_conditions",
    "operates_on",
    "causal_chain",
    "modulation",
    "inputs",
    "outputs",
    "side_effects",
    "termination_conditions",
    "holistic_understanding"
  ]
};
var InputValidator = class {
  MAX_INPUT_LENGTH = 1e4;
  SUSPICIOUS_PATTERNS = [
    /ignore\s+previous\s+instructions/i,
    /system\s*:/i,
    /\[INST\]/i,
    /<\|im_start\|>/i
  ];
  validate(input) {
    if (typeof input !== "string") {
      throw new CognitiveRazorError("E101_INVALID_INPUT", "\u8F93\u5165\u5FC5\u987B\u662F\u5B57\u7B26\u4E32");
    }
    if (input.length > this.MAX_INPUT_LENGTH) {
      throw new CognitiveRazorError("E101_INVALID_INPUT", `\u8F93\u5165\u8FC7\u957F: ${input.length} \u5B57\u7B26 (\u6700\u5927 ${this.MAX_INPUT_LENGTH})`, {
        length: input.length,
        maxLength: this.MAX_INPUT_LENGTH
      });
    }
    for (const pattern of this.SUSPICIOUS_PATTERNS) {
      if (pattern.test(input)) {
        throw new CognitiveRazorError("E101_INVALID_INPUT", "\u8F93\u5165\u5305\u542B\u53EF\u7591\u6307\u4EE4\uFF0C\u8BF7\u68C0\u67E5\u540E\u518D\u8BD5");
      }
    }
    const sanitized = input.replace(/[\x00-\x1F\x7F]/g, "").replace(/\s+/g, " ").trim();
    return sanitized;
  }
};
function narrowTask(task) {
  return task;
}
var TaskRunner = class {
  providerManager;
  promptManager;
  validator;
  undoManager;
  logger;
  vectorIndex;
  schemaRegistry;
  settingsStore;
  abortControllers;
  inputValidator;
  app;
  noteRepository;
  taskHandlers;
  constructor(deps) {
    this.providerManager = deps.providerManager;
    this.promptManager = deps.promptManager;
    this.validator = deps.validator;
    this.undoManager = deps.undoManager;
    this.logger = deps.logger;
    this.vectorIndex = deps.vectorIndex;
    this.schemaRegistry = deps.schemaRegistry || schemaRegistry;
    this.settingsStore = deps.settingsStore;
    this.app = deps.app;
    this.noteRepository = deps.noteRepository ?? new NoteRepository(deps.app, deps.logger);
    this.abortControllers = /* @__PURE__ */ new Map();
    this.inputValidator = new InputValidator();
    this.taskHandlers = /* @__PURE__ */ new Map([
      [
        "define",
        { taskType: "define", run: (task, signal) => this.executeDefine(task, signal) }
      ],
      [
        "tag",
        { taskType: "tag", run: (task, signal) => this.executeTag(task, signal) }
      ],
      [
        "index",
        { taskType: "index", run: (task, signal) => this.executeIndex(task, signal) }
      ],
      [
        "write",
        { taskType: "write", run: (task, signal) => this.executeWrite(task, signal) }
      ],
      [
        "amend",
        { taskType: "amend", run: (task, signal) => this.executeAmend(task, signal) }
      ],
      [
        "merge",
        { taskType: "merge", run: (task, signal) => this.executeMerge(task, signal) }
      ],
      [
        "verify",
        { taskType: "verify", run: (task, signal) => this.executeVerify(task, signal) }
      ],
      [
        "image-generate",
        { taskType: "image-generate", run: (task, signal) => this.executeImageGenerate(task, signal) }
      ]
    ]);
    this.logger.debug("TaskRunner", "TaskRunner \u521D\u59CB\u5316\u5B8C\u6210");
  }
  /** 执行任务 - 验证 Provider 能力后分发到具体执行方法 */
  async run(task) {
    const startTime = Date.now();
    const capabilityCheck = await this.validateProviderCapability(task);
    if (!capabilityCheck.ok) {
      this.logger.error("TaskRunner", "Provider \u80FD\u529B\u9A8C\u8BC1\u5931\u8D25", void 0, {
        taskId: task.id,
        error: capabilityCheck.error
      });
      return capabilityCheck;
    }
    const abortController = new AbortController();
    this.abortControllers.set(task.id, abortController);
    try {
      this.logger.info("TaskRunner", `\u5F00\u59CB\u6267\u884C\u4EFB\u52A1: ${task.id}`, {
        taskType: task.taskType,
        nodeId: task.nodeId,
        attempt: task.attempt
      });
      const handler = this.taskHandlers.get(task.taskType);
      const result = handler ? await handler.run(task, abortController.signal) : err("E310_INVALID_STATE", `\u672A\u77E5\u7684\u4EFB\u52A1\u7C7B\u578B: ${task.taskType}`);
      const elapsedTime = Date.now() - startTime;
      if (result.ok) {
        this.logger.info("TaskRunner", `\u4EFB\u52A1\u6267\u884C\u6210\u529F: ${task.id}`, {
          taskType: task.taskType,
          elapsedTime
        });
      } else {
        this.logger.error("TaskRunner", `\u4EFB\u52A1\u6267\u884C\u5931\u8D25: ${task.id}`, void 0, {
          taskType: task.taskType,
          error: result.error,
          elapsedTime
        });
      }
      return result;
    } catch (error) {
      const elapsedTime = Date.now() - startTime;
      this.logger.error("TaskRunner", `\u4EFB\u52A1\u6267\u884C\u5F02\u5E38: ${task.id}`, error, {
        taskType: task.taskType,
        elapsedTime
      });
      return err("E500_INTERNAL_ERROR", "\u4EFB\u52A1\u6267\u884C\u5F02\u5E38", error);
    } finally {
      this.abortControllers.delete(task.id);
    }
  }
  /** 中断任务执行 */
  abort(taskId) {
    const abortController = this.abortControllers.get(taskId);
    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(taskId);
      this.logger.info("TaskRunner", `\u4EFB\u52A1\u5DF2\u4E2D\u65AD: ${taskId}`);
    }
  }
  /** 创建写入前快照 */
  async createSnapshotBeforeWrite(context) {
    try {
      this.logger.debug("TaskRunner", "\u521B\u5EFA\u5199\u5165\u524D\u5FEB\u7167", {
        filePath: context.filePath,
        nodeId: context.nodeId,
        taskId: context.taskId
      });
      let originalContent = context.originalContent;
      if (originalContent === void 0) {
        const existing = await this.noteRepository.readByPathIfExists(context.filePath);
        originalContent = existing ?? "";
      }
      if (originalContent === void 0) {
        originalContent = "";
      }
      const snapshotResult = await this.undoManager.createSnapshot(
        context.filePath,
        originalContent,
        context.taskId,
        context.nodeId
      );
      if (!snapshotResult.ok) {
        this.logger.error("TaskRunner", "\u521B\u5EFA\u5FEB\u7167\u5931\u8D25", void 0, {
          filePath: context.filePath,
          error: snapshotResult.error
        });
        return snapshotResult;
      }
      this.logger.info("TaskRunner", `\u5FEB\u7167\u5DF2\u521B\u5EFA: ${snapshotResult.value}`, {
        filePath: context.filePath,
        nodeId: context.nodeId,
        taskId: context.taskId
      });
      return snapshotResult;
    } catch (error) {
      this.logger.error("TaskRunner", "\u521B\u5EFA\u5FEB\u7167\u5F02\u5E38", error, {
        filePath: context.filePath
      });
      return err("E304_SNAPSHOT_FAILED", "\u521B\u5EFA\u5FEB\u7167\u5931\u8D25", error);
    }
  }
  /** 更新笔记状态 */
  async updateNoteStatus(filePath, newStatus) {
    try {
      const content = await this.noteRepository.readByPathIfExists(filePath);
      if (content === null) {
        return err("E301_FILE_NOT_FOUND", `\u76EE\u6807\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`, { filePath });
      }
      const updatedContent = this.updateFrontmatterStatus(content, newStatus);
      await this.noteRepository.writeAtomic(filePath, updatedContent);
      this.logger.info("TaskRunner", `\u7B14\u8BB0\u72B6\u6001\u5DF2\u66F4\u65B0\u4E3A ${newStatus}`, { filePath });
      return ok(void 0);
    } catch (error) {
      this.logger.error("TaskRunner", "\u66F4\u65B0\u7B14\u8BB0\u72B6\u6001\u5931\u8D25", error, { filePath });
      return err("E302_PERMISSION_DENIED", "\u66F4\u65B0\u7B14\u8BB0\u72B6\u6001\u5931\u8D25", error);
    }
  }
  /** 更新 frontmatter 中的 status 字段 */
  updateFrontmatterStatus(content, newStatus) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---/;
    const match = content.match(frontmatterRegex);
    if (!match) {
      return content;
    }
    const frontmatter = match[1];
    const withStatus = frontmatter.replace(
      /^status:\s*.*$/m,
      `status: ${newStatus}`
    );
    const now2 = formatCRTimestamp();
    const updatedFrontmatter = withStatus.replace(
      /^updated:\s*.*$/m,
      `updated: ${now2}`
    );
    return content.replace(frontmatterRegex, `---
${updatedFrontmatter}
---`);
  }
  /** 完成合并流程 - 删除被合并笔记并更新向量索引 */
  async completeMergeFlow(keepNodeId, deleteNodeId, deleteFilePath) {
    try {
      this.logger.info("TaskRunner", "\u5F00\u59CB\u5B8C\u6210\u5408\u5E76\u6D41\u7A0B", {
        keepNodeId,
        deleteNodeId,
        deleteFilePath
      });
      const deleted = await this.noteRepository.deleteByPathIfExists(deleteFilePath);
      if (!deleted) {
        this.logger.warn("TaskRunner", "\u88AB\u5408\u5E76\u7B14\u8BB0\u4E0D\u5B58\u5728\uFF0C\u8DF3\u8FC7\u5220\u9664", { deleteFilePath });
      } else {
        this.logger.info("TaskRunner", `\u5DF2\u5220\u9664\u88AB\u5408\u5E76\u7B14\u8BB0: ${deleteFilePath}`);
      }
      if (this.vectorIndex) {
        const deleteIndexResult = await this.vectorIndex.delete(deleteNodeId);
        if (!deleteIndexResult.ok) {
          this.logger.warn("TaskRunner", "\u4ECE\u5411\u91CF\u7D22\u5F15\u79FB\u9664\u6761\u76EE\u5931\u8D25", {
            deleteNodeId,
            error: deleteIndexResult.error
          });
        } else {
          this.logger.info("TaskRunner", `\u5DF2\u4ECE\u5411\u91CF\u7D22\u5F15\u79FB\u9664: ${deleteNodeId}`);
        }
      }
      this.logger.info("TaskRunner", "\u5408\u5E76\u6D41\u7A0B\u5B8C\u6210", {
        keepNodeId,
        deleteNodeId
      });
      return ok(void 0);
    } catch (error) {
      this.logger.error("TaskRunner", "\u5B8C\u6210\u5408\u5E76\u6D41\u7A0B\u5931\u8D25", error, {
        keepNodeId,
        deleteNodeId
      });
      return err("E500_INTERNAL_ERROR", "\u5B8C\u6210\u5408\u5E76\u6D41\u7A0B\u5931\u8D25", error);
    }
  }
  /** 验证任务管线顺序 */
  validatePipelineOrder(previousTaskType, currentTaskType) {
    if (previousTaskType === null) {
      return true;
    }
    const previousIndex = TASK_PIPELINE_ORDER.indexOf(previousTaskType);
    const currentIndex = TASK_PIPELINE_ORDER.indexOf(currentTaskType);
    if (previousIndex === -1 || currentIndex === -1) {
      return true;
    }
    if (currentTaskType === "index") {
      return previousTaskType === "write" || previousIndex <= 2;
    }
    return currentIndex >= previousIndex;
  }
  /** 获取任务管线中的下一个任务类型 */
  getNextPipelineTask(currentTaskType) {
    const currentIndex = TASK_PIPELINE_ORDER.indexOf(currentTaskType);
    if (currentIndex === -1 || currentIndex >= TASK_PIPELINE_ORDER.length - 1) {
      return null;
    }
    switch (currentTaskType) {
      case "define":
        return "tag";
      case "tag":
        return "write";
      case "write":
        return "index";
      default:
        return null;
    }
  }
  // 任务执行方法
  /** 执行 define 任务 */
  async executeDefine(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "define") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B define" });
      }
      const payload = typed.payload;
      const sanitizedInput = this.inputValidator.validate(payload.userInput);
      const slots = {
        CTX_INPUT: sanitizedInput,
        CTX_LANGUAGE: this.getLanguage()
      };
      const prompt = this.promptManager.build(task.taskType, slots);
      const modelConfig = this.getTaskModelConfig("define", task.providerRef);
      const chatRequest = {
        providerId: task.providerRef || modelConfig.providerId,
        model: modelConfig.model,
        messages: [
          { role: "user", content: prompt }
        ],
        temperature: modelConfig.temperature,
        topP: modelConfig.topP,
        maxTokens: modelConfig.maxTokens,
        reasoning_effort: modelConfig.reasoning_effort
      };
      const chatResult = await this.providerManager.chat(chatRequest, signal);
      if (!chatResult.ok) {
        return this.createTaskError(task, chatResult.error);
      }
      const schema4 = this.schemaRegistry.getDefineSchema();
      const validationResult = await this.validator.validate(
        chatResult.value.content,
        schema4,
        ["C009"]
      );
      if (!validationResult.valid) {
        return this.createValidationError(task, validationResult.errors);
      }
      const data = validationResult.data || JSON.parse(chatResult.value.content);
      const parsed = mapStandardizeOutput(data);
      return ok({
        taskId: task.id,
        state: "Completed",
        data: parsed
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C define \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C define \u5931\u8D25");
    }
  }
  /** 执行 tag 任务 */
  async executeTag(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "tag") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B tag" });
      }
      const payload = typed.payload;
      const metaContext = this.buildMetaContext(payload);
      const slots = {
        CTX_META: metaContext,
        CTX_LANGUAGE: this.getLanguage()
      };
      const prompt = this.promptManager.build(task.taskType, slots);
      const modelConfig = this.getTaskModelConfig("tag", task.providerRef);
      const chatRequest = {
        providerId: task.providerRef || modelConfig.providerId,
        model: modelConfig.model,
        messages: [
          { role: "user", content: prompt }
        ],
        temperature: modelConfig.temperature,
        topP: modelConfig.topP,
        maxTokens: modelConfig.maxTokens,
        reasoning_effort: modelConfig.reasoning_effort
      };
      const chatResult = await this.providerManager.chat(chatRequest, signal);
      if (!chatResult.ok) {
        return this.createTaskError(task, chatResult.error);
      }
      const schema4 = {
        type: "object",
        properties: {
          aliases: { type: "array" },
          tags: { type: "array" }
        },
        required: ["aliases", "tags"]
      };
      const validationResult = await this.validator.validate(
        chatResult.value.content,
        schema4,
        []
      );
      if (!validationResult.valid) {
        return this.createValidationError(task, validationResult.errors);
      }
      const data = validationResult.data || JSON.parse(chatResult.value.content);
      const parsed = {
        aliases: Array.isArray(data.aliases) ? data.aliases : [],
        tags: Array.isArray(data.tags) ? data.tags : []
      };
      return ok({
        taskId: task.id,
        state: "Completed",
        data: parsed
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C tag \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C tag \u5931\u8D25");
    }
  }
  /** 执行 index 任务 */
  async executeIndex(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "index") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B index" });
      }
      const payload = typed.payload;
      let text2 = payload.text;
      if (!text2) {
        const standardized = payload.standardizedData;
        if (!standardized) {
          return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u7F3A\u5C11\u6807\u51C6\u5316\u6570\u636E\uFF0C\u65E0\u6CD5\u751F\u6210\u5D4C\u5165\u6587\u672C" });
        }
        const primaryType = standardized.primaryType || payload.conceptType || "Entity";
        const currentName = standardized.standardNames?.[primaryType];
        if (!currentName) {
          return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u6807\u51C6\u5316\u540D\u79F0\u7F3A\u5931\uFF0C\u65E0\u6CD5\u751F\u6210\u5D4C\u5165\u6587\u672C" });
        }
        const signature = createConceptSignature(
          {
            standardName: currentName,
            aliases: Array.isArray(payload.aliases) ? payload.aliases : [],
            coreDefinition: standardized.coreDefinition
          },
          primaryType,
          payload.namingTemplate || "{{chinese}} ({{english}})"
        );
        text2 = generateSignatureText(signature);
      }
      const modelConfig = this.getTaskModelConfig("index", task.providerRef);
      const embeddingDimension = this.vectorIndex?.getEmbeddingDimension() ?? modelConfig.embeddingDimension ?? this.settingsStore?.getSettings().embeddingDimension ?? 1536;
      const embeddingModel = this.vectorIndex?.getEmbeddingModel() ?? modelConfig.model;
      const embedResult = await this.providerManager.embed({
        providerId: task.providerRef || modelConfig.providerId,
        model: embeddingModel,
        input: text2,
        dimensions: embeddingDimension
      }, signal);
      if (!embedResult.ok) {
        return this.createTaskError(task, embedResult.error);
      }
      return ok({
        taskId: task.id,
        state: "Completed",
        data: {
          embedding: embedResult.value.embedding,
          tokensUsed: embedResult.value.tokensUsed,
          text: text2
        }
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C index \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C index \u5931\u8D25");
    }
  }
  /** 执行 write 任务（分阶段 Chain-of-Fields） */
  async executeWrite(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "write") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B write" });
      }
      const payload = typed.payload;
      const conceptType = payload.conceptType || "Entity";
      const fullSchema = this.getSchema(conceptType);
      const sources = typeof payload.sources === "string" ? payload.sources : "";
      const metaContext = this.buildMetaContext(payload);
      const language = this.getLanguage();
      const phases = WRITE_PHASES[conceptType];
      if (!phases || phases.length === 0) {
        return this.executeWriteLegacy(task, signal);
      }
      const modelConfig = this.getTaskModelConfig("write", task.providerRef);
      const accumulated = {};
      this.logger.info("TaskRunner", `\u5F00\u59CB\u5206\u9636\u6BB5 Write: ${conceptType}`, {
        taskId: task.id,
        phaseCount: phases.length
      });
      for (let i = 0; i < phases.length; i++) {
        const phase = phases[i];
        if (signal.aborted) {
          return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u5DF2\u88AB\u4E2D\u65AD" });
        }
        const phaseSchema = this.buildPhaseSchema(fullSchema, phase.fields);
        const previousContext = Object.keys(accumulated).length > 0 ? JSON.stringify(accumulated, null, 2) : "";
        const prompt = this.promptManager.buildPhasedWrite({
          CTX_META: metaContext,
          CTX_PREVIOUS: previousContext,
          CTX_SOURCES: sources,
          CTX_LANGUAGE: language,
          CONCEPT_TYPE: conceptType,
          PHASE_SCHEMA: phaseSchema,
          PHASE_FOCUS: phase.focusInstruction
        });
        const chatResult = await this.providerManager.chat({
          providerId: task.providerRef || modelConfig.providerId,
          model: modelConfig.model,
          messages: [{ role: "user", content: prompt }],
          temperature: modelConfig.temperature,
          topP: modelConfig.topP,
          maxTokens: modelConfig.maxTokens,
          reasoning_effort: modelConfig.reasoning_effort
        }, signal);
        if (!chatResult.ok) {
          return this.createTaskError(task, chatResult.error);
        }
        const phaseValidationSchema = this.buildPhaseValidationSchema(fullSchema, phase.fields);
        const validationResult = await this.validator.validate(
          chatResult.value.content,
          phaseValidationSchema,
          []
        );
        if (!validationResult.valid) {
          this.logger.warn("TaskRunner", `\u9636\u6BB5 ${phase.id} \u9A8C\u8BC1\u5931\u8D25\uFF0C\u5C1D\u8BD5\u89E3\u6790\u539F\u59CB\u5185\u5BB9`, {
            taskId: task.id,
            phase: phase.id,
            errors: validationResult.errors
          });
          try {
            const content = chatResult.value.content.trim();
            const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/) || content.match(/```\s*([\s\S]*?)\s*```/);
            const jsonStr = jsonMatch ? jsonMatch[1] : content;
            const parsed = JSON.parse(jsonStr);
            for (const field of phase.fields) {
              if (parsed[field] !== void 0) {
                accumulated[field] = parsed[field];
              }
            }
          } catch {
            return this.createValidationError(task, validationResult.errors);
          }
        } else {
          const phaseData = validationResult.data || {};
          for (const field of phase.fields) {
            if (phaseData[field] !== void 0) {
              accumulated[field] = phaseData[field];
            }
          }
        }
        this.logger.info("TaskRunner", `\u9636\u6BB5 ${phase.id} \u5B8C\u6210`, {
          taskId: task.id,
          phase: phase.id,
          phaseIndex: i + 1,
          totalPhases: phases.length,
          fieldsGenerated: phase.fields.filter((f) => accumulated[f] !== void 0)
        });
      }
      const skipSnapshot = payload.skipSnapshot === true;
      if (payload.filePath && !skipSnapshot) {
        const snapshotResult = await this.createSnapshotBeforeWrite({
          filePath: payload.filePath,
          content: "",
          nodeId: task.nodeId,
          taskId: task.id,
          originalContent: payload.originalContent || ""
        });
        if (snapshotResult.ok) {
          accumulated.snapshotId = snapshotResult.value;
        }
      }
      return ok({
        taskId: task.id,
        state: "Completed",
        data: accumulated
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C write \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C write \u5931\u8D25");
    }
  }
  /** 旧版一次性 Write（回退路径） */
  async executeWriteLegacy(task, signal) {
    const typed = narrowTask(task);
    if (typed.taskType !== "write") {
      return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D" });
    }
    const payload = typed.payload;
    const conceptType = payload.conceptType || "Entity";
    const schema4 = this.getSchema(conceptType);
    const sources = typeof payload.sources === "string" ? payload.sources : "";
    const slots = {
      CTX_META: this.buildMetaContext(payload),
      CTX_SOURCES: sources,
      CTX_LANGUAGE: this.getLanguage()
    };
    const prompt = this.promptManager.build(task.taskType, slots, conceptType);
    const modelConfig = this.getTaskModelConfig("write", task.providerRef);
    const chatResult = await this.providerManager.chat({
      providerId: task.providerRef || modelConfig.providerId,
      model: modelConfig.model,
      messages: [{ role: "user", content: prompt }],
      temperature: modelConfig.temperature,
      topP: modelConfig.topP,
      maxTokens: modelConfig.maxTokens,
      reasoning_effort: modelConfig.reasoning_effort
    }, signal);
    if (!chatResult.ok) {
      return this.createTaskError(task, chatResult.error);
    }
    const validationResult = await this.validator.validate(
      chatResult.value.content,
      schema4,
      []
    );
    if (!validationResult.valid) {
      return this.createValidationError(task, validationResult.errors);
    }
    const data = validationResult.data || JSON.parse(chatResult.value.content);
    const skipSnapshot = payload.skipSnapshot === true;
    if (payload.filePath && !skipSnapshot) {
      const snapshotResult = await this.createSnapshotBeforeWrite({
        filePath: payload.filePath,
        content: "",
        nodeId: task.nodeId,
        taskId: task.id,
        originalContent: payload.originalContent || ""
      });
      if (snapshotResult.ok) {
        data.snapshotId = snapshotResult.value;
      }
    }
    return ok({ taskId: task.id, state: "Completed", data });
  }
  /**
   * 构建阶段 Schema 描述（用于 prompt 中的 PHASE_SCHEMA 槽位）
   * 生成人类可读的字段描述，而非完整 JSON Schema
   */
  buildPhaseSchema(fullSchema, fields) {
    const properties = fullSchema.properties;
    if (!properties) return fields.map((f) => `"${f}": "..."`).join(",\n");
    const lines = ["{"];
    for (const field of fields) {
      const prop2 = properties[field];
      if (!prop2) {
        lines.push(`  "${field}": "..."`);
        continue;
      }
      const desc = prop2.description || field;
      const type = prop2.type || "string";
      if (type === "array" && prop2.items) {
        const items = prop2.items;
        if (items.type === "object" && items.properties) {
          const subProps = items.properties;
          const subFields = Object.keys(subProps).map((k) => `"${k}": "${subProps[k].description || k}"`).join(", ");
          lines.push(`  "${field}": [{ ${subFields} }, ...]  // ${desc}`);
        } else {
          lines.push(`  "${field}": ["...", ...]  // ${desc}`);
        }
      } else if (type === "object" && prop2.properties) {
        const subProps = prop2.properties;
        const subFields = Object.keys(subProps).map((k) => `"${k}": "${subProps[k].description || k}"`).join(", ");
        lines.push(`  "${field}": { ${subFields} }  // ${desc}`);
      } else {
        lines.push(`  "${field}": "..."  // ${desc}`);
      }
    }
    lines.push("}");
    return lines.join("\n");
  }
  /**
   * 构建阶段验证 Schema（仅包含本阶段字段的 JSON Schema）
   */
  buildPhaseValidationSchema(fullSchema, fields) {
    const full = fullSchema;
    const properties = full.properties;
    if (!properties) {
      return { type: "object", required: fields, properties: {} };
    }
    const phaseProperties = {};
    for (const field of fields) {
      if (properties[field]) {
        phaseProperties[field] = properties[field];
      }
    }
    return {
      type: "object",
      required: fields,
      properties: phaseProperties
    };
  }
  /** 执行 amend 任务（修订） */
  async executeAmend(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "amend") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B amend" });
      }
      const payload = typed.payload;
      if (!payload.currentContent || !payload.instruction) {
        return this.createTaskError(task, { code: "E102_MISSING_FIELD", message: "\u4FEE\u8BA2\u4EFB\u52A1\u8F7D\u8377\u7F3A\u5931\u5FC5\u8981\u5B57\u6BB5" });
      }
      const conceptType = payload.conceptType || "Entity";
      const slots = {
        CTX_CURRENT: payload.currentContent,
        USER_INSTRUCTION: payload.instruction,
        CONCEPT_TYPE: conceptType,
        CTX_LANGUAGE: this.getLanguage()
      };
      const prompt = this.promptManager.build("amend", slots, conceptType);
      const modelConfig = this.getTaskModelConfig("amend", task.providerRef);
      const chatRequest = {
        providerId: task.providerRef || modelConfig.providerId,
        model: modelConfig.model,
        messages: [{ role: "user", content: prompt }],
        temperature: modelConfig.temperature,
        topP: modelConfig.topP,
        maxTokens: modelConfig.maxTokens,
        reasoning_effort: modelConfig.reasoning_effort
      };
      const chatResult = await this.providerManager.chat(chatRequest, signal);
      if (!chatResult.ok) {
        return this.createTaskError(task, chatResult.error);
      }
      const amendOutputSchema = {
        type: "object",
        properties: {
          content: { type: "object" },
          changes_summary: { type: "string" },
          preserved_sections: { type: "array" },
          enhanced_sections: { type: "array" }
        },
        required: ["content"]
      };
      const validationResult = await this.validator.validate(
        chatResult.value.content,
        amendOutputSchema,
        []
      );
      if (!validationResult.valid) {
        return this.createValidationError(task, validationResult.errors);
      }
      const parsed = validationResult.data || {};
      const rawContent = parsed.content;
      if (!rawContent || typeof rawContent !== "object" || Array.isArray(rawContent)) {
        return this.createTaskError(task, { code: "E211_MODEL_SCHEMA_VIOLATION", message: "\u4FEE\u8BA2\u7ED3\u679C\u7F3A\u5C11\u6709\u6548\u7684 content \u5BF9\u8C61" });
      }
      const schema4 = this.getSchema(conceptType);
      const rules = this.getValidationRules(conceptType);
      const contentValidation = await this.validator.validate(
        JSON.stringify(rawContent),
        schema4,
        rules,
        { type: conceptType }
      );
      if (!contentValidation.valid) {
        return this.createValidationError(task, contentValidation.errors);
      }
      return ok({
        taskId: task.id,
        state: "Completed",
        data: contentValidation.data || {}
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C amend \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C amend \u5931\u8D25");
    }
  }
  /** 执行 merge 任务（合并） */
  async executeMerge(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "merge") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B merge" });
      }
      const payload = typed.payload;
      if (!payload.keepContent || !payload.deleteContent || !payload.keepName || !payload.deleteName) {
        return this.createTaskError(task, { code: "E102_MISSING_FIELD", message: "\u5408\u5E76\u4EFB\u52A1\u8F7D\u8377\u7F3A\u5931\u5FC5\u8981\u5B57\u6BB5" });
      }
      const conceptType = payload.conceptType || "Entity";
      const instruction = payload.finalFileName ? `\u5408\u5E76\u8FD9\u4E24\u4E2A ${conceptType} \u7C7B\u578B\u7684\u6982\u5FF5\u7B14\u8BB0\uFF0C\u6700\u7EC8\u6587\u4EF6\u540D\u4E3A "${payload.finalFileName}"` : `\u5408\u5E76\u8FD9\u4E24\u4E2A ${conceptType} \u7C7B\u578B\u7684\u6982\u5FF5\u7B14\u8BB0`;
      const slots = {
        SOURCE_A_NAME: payload.keepName,
        CTX_SOURCE_A: payload.keepContent,
        SOURCE_B_NAME: payload.deleteName,
        CTX_SOURCE_B: payload.deleteContent,
        USER_INSTRUCTION: instruction,
        CONCEPT_TYPE: conceptType,
        CTX_LANGUAGE: this.getLanguage()
      };
      const prompt = this.promptManager.build("merge", slots, conceptType);
      const modelConfig = this.getTaskModelConfig("merge", task.providerRef);
      const chatRequest = {
        providerId: task.providerRef || modelConfig.providerId,
        model: modelConfig.model,
        messages: [{ role: "user", content: prompt }],
        temperature: modelConfig.temperature,
        topP: modelConfig.topP,
        maxTokens: modelConfig.maxTokens,
        reasoning_effort: modelConfig.reasoning_effort
      };
      const chatResult = await this.providerManager.chat(chatRequest, signal);
      if (!chatResult.ok) {
        return this.createTaskError(task, chatResult.error);
      }
      const mergeOutputSchema = {
        type: "object",
        properties: {
          merged_name: { type: "object" },
          merge_rationale: { type: "string" },
          content: { type: "object" },
          preserved_from_a: { type: "array" },
          preserved_from_b: { type: "array" }
        },
        required: ["merged_name", "merge_rationale", "content", "preserved_from_a", "preserved_from_b"]
      };
      const validationResult = await this.validator.validate(
        chatResult.value.content,
        mergeOutputSchema,
        []
      );
      if (!validationResult.valid) {
        return this.createValidationError(task, validationResult.errors);
      }
      const parsed = validationResult.data || {};
      const rawContent = parsed.content;
      if (!rawContent || typeof rawContent !== "object" || Array.isArray(rawContent)) {
        return this.createTaskError(task, { code: "E211_MODEL_SCHEMA_VIOLATION", message: "\u5408\u5E76\u7ED3\u679C\u7F3A\u5C11\u6709\u6548\u7684 content \u5BF9\u8C61" });
      }
      const schema4 = this.getSchema(conceptType);
      const rules = this.getValidationRules(conceptType);
      const contentValidation = await this.validator.validate(
        JSON.stringify(rawContent),
        schema4,
        rules,
        { type: conceptType }
      );
      if (!contentValidation.valid) {
        return this.createValidationError(task, contentValidation.errors);
      }
      const mergeResult = {
        ...parsed,
        content: contentValidation.data || {}
      };
      return ok({
        taskId: task.id,
        state: "Completed",
        data: mergeResult
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C merge \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C merge \u5931\u8D25");
    }
  }
  /** 执行 verify 任务（校验） */
  async executeVerify(task, signal) {
    try {
      const typed = narrowTask(task);
      if (typed.taskType !== "verify") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B verify" });
      }
      const payload = typed.payload;
      if (!payload.currentContent) {
        return this.createTaskError(task, { code: "E102_MISSING_FIELD", message: "\u7F3A\u5C11\u5F85\u9A8C\u8BC1\u5185\u5BB9 (currentContent)" });
      }
      const conceptType = payload.conceptType || payload.noteType || "Entity";
      const slots = {
        CTX_META: this.buildMetaContext(payload),
        CTX_CURRENT: payload.currentContent,
        CTX_SOURCES: payload.sources || "",
        CTX_LANGUAGE: this.getLanguage()
      };
      const prompt = this.promptManager.build(task.taskType, slots, conceptType);
      const modelConfig = this.getTaskModelConfig("verify", task.providerRef);
      const chatRequest = {
        providerId: task.providerRef || modelConfig.providerId,
        model: modelConfig.model,
        messages: [
          { role: "user", content: prompt }
        ],
        temperature: modelConfig.temperature,
        topP: modelConfig.topP,
        maxTokens: modelConfig.maxTokens,
        reasoning_effort: modelConfig.reasoning_effort
      };
      const chatResult = await this.providerManager.chat(chatRequest, signal);
      if (!chatResult.ok) {
        return this.createTaskError(task, chatResult.error);
      }
      const verifyOutputSchema = {
        type: "object",
        required: [
          "overall_assessment",
          "confidence_score",
          "issues",
          "verified_claims",
          "recommendations",
          "requires_human_review"
        ],
        properties: {
          overall_assessment: { type: "string" },
          confidence_score: { type: "number" },
          issues: { type: "array" },
          verified_claims: { type: "array" },
          recommendations: { type: "array" },
          requires_human_review: { type: "boolean" }
        }
      };
      const validationResult = await this.validator.validate(
        chatResult.value.content,
        verifyOutputSchema,
        []
      );
      if (!validationResult.valid) {
        return this.createValidationError(task, validationResult.errors);
      }
      const resultData = validationResult.data || {};
      this.logger.info("TaskRunner", `Verify \u4EFB\u52A1\u5B8C\u6210: ${task.id}`, {
        overall_assessment: resultData.overall_assessment,
        issueCount: resultData.issues.length
      });
      return ok({
        taskId: task.id,
        state: "Completed",
        data: resultData
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C verify \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C verify \u5931\u8D25");
    }
  }
  /** 执行图片生成任务 */
  async executeImageGenerate(task, signal) {
    try {
      if (!this.settingsStore) {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u8BBE\u7F6E\u672A\u521D\u59CB\u5316" });
      }
      const typed = narrowTask(task);
      if (typed.taskType !== "image-generate") {
        return this.createTaskError(task, { code: "E310_INVALID_STATE", message: "\u4EFB\u52A1\u7C7B\u578B\u4E0D\u5339\u914D: \u671F\u671B image-generate" });
      }
      const payload = typed.payload;
      if (!payload.userPrompt || !payload.filePath) {
        return this.createTaskError(task, { code: "E102_MISSING_FIELD", message: "\u56FE\u7247\u751F\u6210\u4EFB\u52A1\u8F7D\u8377\u7F3A\u5931\u5FC5\u8981\u5B57\u6BB5" });
      }
      const settings = this.settingsStore.getSettings();
      const promptSlots = {
        USER_PROMPT: payload.userPrompt,
        CONTEXT_BEFORE: payload.contextBefore ?? "",
        CONTEXT_AFTER: payload.contextAfter ?? "",
        CONCEPT_TYPE: payload.frontmatter?.type ?? "",
        CONCEPT_NAME: payload.frontmatter?.name ?? "",
        CTX_LANGUAGE: this.getLanguage()
      };
      let promptTemplate;
      try {
        promptTemplate = this.promptManager.build("image-generate", promptSlots);
      } catch (error) {
        return toErr(error, "E500_INTERNAL_ERROR", "\u6784\u5EFA\u56FE\u7247\u63D0\u793A\u8BCD\u5931\u8D25");
      }
      const promptModelConfig = this.getTaskModelConfig("write", task.providerRef);
      if (!promptModelConfig.providerId) {
        return this.createTaskError(task, { code: "E401_PROVIDER_NOT_CONFIGURED", message: "\u8BF7\u5148\u914D\u7F6E Provider" });
      }
      const promptRequest = {
        providerId: task.providerRef || promptModelConfig.providerId,
        model: promptModelConfig.model,
        messages: [{ role: "user", content: promptTemplate }],
        temperature: promptModelConfig.temperature,
        topP: promptModelConfig.topP,
        maxTokens: promptModelConfig.maxTokens,
        reasoning_effort: promptModelConfig.reasoning_effort
      };
      const promptResult = await this.providerManager.chat(promptRequest, signal);
      if (!promptResult.ok) {
        return this.createTaskError(task, promptResult.error);
      }
      const promptSchema = {
        type: "object",
        required: ["prompt", "altText"],
        properties: {
          prompt: { type: "string" },
          altText: { type: "string" },
          styleHints: { type: "array" },
          negativePrompt: { type: "string" }
        }
      };
      const promptValidation = await this.validator.validate(
        promptResult.value.content,
        promptSchema,
        []
      );
      if (!promptValidation.valid) {
        return this.createValidationError(task, promptValidation.errors);
      }
      const promptData = promptValidation.data || {};
      if (!promptData.prompt) {
        return this.createTaskError(task, { code: "E211_MODEL_SCHEMA_VIOLATION", message: "\u56FE\u7247\u63D0\u793A\u8BCD\u7F3A\u5931" });
      }
      const imageModelConfig = this.getTaskModelConfig("image-generate", task.providerRef);
      if (!imageModelConfig.providerId) {
        return this.createTaskError(task, { code: "E401_PROVIDER_NOT_CONFIGURED", message: "\u8BF7\u5148\u914D\u7F6E Provider" });
      }
      const imageResult = await this.providerManager.generateImage(
        {
          providerId: imageModelConfig.providerId,
          model: imageModelConfig.model,
          prompt: promptData.prompt,
          size: settings.imageGeneration.defaultSize,
          quality: settings.imageGeneration.defaultQuality,
          style: settings.imageGeneration.defaultStyle
        },
        signal
      );
      if (!imageResult.ok) {
        return this.createTaskError(task, imageResult.error);
      }
      const binaryResult = dataUrlToArrayBuffer(imageResult.value.imageUrl);
      if (!binaryResult.ok) {
        return this.createTaskError(task, binaryResult.error);
      }
      const file = this.noteRepository.getFileByPath(payload.filePath);
      if (!file) {
        return this.createTaskError(task, { code: "E301_FILE_NOT_FOUND", message: "\u76EE\u6807\u6587\u4EF6\u4E0D\u5B58\u5728" });
      }
      const currentContent = await this.noteRepository.read(file);
      const ext = inferImageExtension(imageResult.value.imageUrl);
      const attachmentPath = this.noteRepository.getAvailablePathForAttachment(
        `generated-image.${ext}`,
        payload.filePath
      );
      await this.noteRepository.createBinary(attachmentPath, binaryResult.value);
      const altText = promptData.altText || imageResult.value.altText || payload.userPrompt;
      const markdown = `![${altText}](${attachmentPath})
`;
      await this.insertImageReference(file, currentContent, markdown, payload.cursorPosition);
      return ok({
        taskId: task.id,
        state: "Completed",
        data: {
          localPath: attachmentPath,
          imageUrl: imageResult.value.imageUrl,
          revisedPrompt: imageResult.value.revisedPrompt,
          altText
        }
      });
    } catch (error) {
      this.logger.error("TaskRunner", "\u6267\u884C image-generate \u5931\u8D25", error, {
        taskId: task.id
      });
      return toErr(error, "E500_INTERNAL_ERROR", "\u6267\u884C image-generate \u5931\u8D25");
    }
  }
  async insertImageReference(file, originalContent, markdown, cursor) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    if (activeView && activeView.file && activeView.file.path === file.path) {
      const editor = activeView.editor;
      editor.replaceRange(markdown, cursor);
      await this.noteRepository.modify(file, editor.getValue());
      return;
    }
    const lines = originalContent.split("\n");
    const lineIndex = Math.min(Math.max(cursor.line ?? lines.length, 0), lines.length);
    if (lineIndex >= lines.length) {
      lines.push("");
    }
    const targetLine = lines[lineIndex] ?? "";
    const ch = Math.min(Math.max(cursor.ch ?? targetLine.length, 0), targetLine.length);
    const updatedLine = `${targetLine.slice(0, ch)}${markdown}${targetLine.slice(ch)}`;
    lines[lineIndex] = updatedLine;
    const nextContent = lines.join("\n");
    await this.noteRepository.modify(file, nextContent);
  }
  // 辅助方法
  /** 获取任务模型配置 */
  getTaskModelConfig(taskType, providerRef) {
    const settings = this.settingsStore?.getSettings();
    const taskConfig = settings?.taskModels?.[taskType];
    const defaultConfig = DEFAULT_TASK_MODEL_CONFIGS[taskType];
    return {
      providerId: taskConfig?.providerId || providerRef || settings?.defaultProviderId || "",
      model: taskConfig?.model || defaultConfig.model,
      temperature: taskConfig?.temperature ?? defaultConfig.temperature,
      topP: taskConfig?.topP ?? defaultConfig.topP,
      maxTokens: taskConfig?.maxTokens,
      reasoning_effort: taskConfig?.reasoning_effort,
      embeddingDimension: taskConfig?.embeddingDimension ?? defaultConfig.embeddingDimension
    };
  }
  /** 构建 CTX_META 上下文字符串（丰富版） */
  buildMetaContext(payload) {
    const standardized = "standardizedData" in payload ? payload.standardizedData : void 0;
    const primaryType = standardized?.primaryType || ("conceptType" in payload ? payload.conceptType : void 0);
    const standardNames = standardized?.standardNames;
    const selectedName = primaryType && standardNames ? standardNames[primaryType] : void 0;
    const meta = {
      Type: primaryType || "",
      standard_name_cn: selectedName?.chinese || "",
      standard_name_en: selectedName?.english || ""
    };
    if (standardized?.coreDefinition) {
      meta.core_definition = standardized.coreDefinition;
    }
    if ("coreDefinition" in payload && typeof payload.coreDefinition === "string" && payload.coreDefinition) {
      meta.core_definition = payload.coreDefinition;
    }
    if ("enrichedData" in payload && payload.enrichedData) {
      const enriched = payload.enrichedData;
      if (enriched.aliases?.length) {
        meta.aliases = enriched.aliases;
      }
      if (enriched.tags?.length) {
        meta.tags = enriched.tags;
      }
    }
    if ("userInput" in payload && typeof payload.userInput === "string" && payload.userInput) {
      meta.user_input = payload.userInput;
    }
    return JSON.stringify(meta, null, 2);
  }
  /**
   * 获取 CTX_LANGUAGE 值
   */
  getLanguage() {
    const settings = this.settingsStore?.getSettings();
    return settings?.language === "en" ? "English" : "Chinese";
  }
  /**
   * 创建任务错误结果
   */
  createTaskError(task, error) {
    return err(error.code, error.message, {
      taskId: task.id,
      details: error.details
    });
  }
  /**
   * 创建验证错误结果
   */
  createValidationError(task, errors) {
    const firstError = errors[0];
    return err(firstError.code, firstError.message, {
      taskId: task.id,
      validationErrors: errors
    });
  }
  /**
   * 获取验证规则
   * 
   * 简化版本：返回空数组，不再使用业务规则校验
   * 
   * @param _conceptType 知识类型（未使用）
   * @returns 空数组
   */
  getValidationRules(_conceptType) {
    return [];
  }
  /**
   * 获取 Schema
   * 
   * 从 SchemaRegistry 根据目标类型获取完整的 JSON Schema，
   * 包含字段定义、类型约束和必填标记
   * 
   * @param conceptType 知识类型
   * @returns 完整的 JSON Schema
   */
  getSchema(conceptType) {
    if (!this.schemaRegistry.isValidType(conceptType)) {
      this.logger.warn("TaskRunner", `\u672A\u77E5\u7684\u77E5\u8BC6\u7C7B\u578B: ${conceptType}\uFF0C\u4F7F\u7528\u57FA\u7840 Schema`);
      return {
        type: "object",
        properties: {
          holistic_understanding: { type: "string", minLength: 10 }
        },
        required: ["holistic_understanding"]
      };
    }
    const schema4 = this.schemaRegistry.getSchema(conceptType);
    this.logger.debug("TaskRunner", `\u83B7\u53D6 Schema: ${conceptType}`, {
      requiredFields: schema4.required
    });
    return schema4;
  }
  /**
   * 验证 Provider 能力匹配
   * 
   * 遵循设计文档 A-FUNC-03：
   * 任务执行前必须找到匹配的 Provider 与 PDD 模板；
   * 缺失或能力不符时本地终止并返回可诊断错误。
   * 
   * @param task 任务记录
   * @returns 验证结果
   */
  async validateProviderCapability(task) {
    const modelConfig = this.getTaskModelConfig(task.taskType, task.providerRef);
    const providerId = modelConfig.providerId;
    if (!providerId) {
      return err("E401_PROVIDER_NOT_CONFIGURED", "\u8BF7\u5148\u914D\u7F6E Provider", {
        taskType: task.taskType,
        hint: "\u6253\u5F00\u8BBE\u7F6E \u2192 Cognitive Razor \u2192 Providers \u8FDB\u884C\u914D\u7F6E"
      });
    }
    const requiredCapability = this.getRequiredCapability(task.taskType);
    this.logger.debug("TaskRunner", "\u9A8C\u8BC1 Provider \u80FD\u529B", {
      taskId: task.id,
      taskType: task.taskType,
      providerId,
      requiredCapability
    });
    const configuredProviders = this.providerManager.getConfiguredProviders();
    const providerExists = configuredProviders.some((p) => p.id === providerId);
    if (!providerExists) {
      if (configuredProviders.length === 0) {
        return err("E401_PROVIDER_NOT_CONFIGURED", "\u5C1A\u672A\u914D\u7F6E\u4EFB\u4F55 AI Provider\u3002\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6E\u81F3\u5C11\u4E00\u4E2A Provider\uFF08\u5982 OpenAI\uFF09\u540E\u518D\u4F7F\u7528\u6B64\u529F\u80FD\u3002", {
          providerId,
          taskType: task.taskType,
          hint: "\u6253\u5F00\u8BBE\u7F6E \u2192 Cognitive Razor \u2192 Providers \u8FDB\u884C\u914D\u7F6E"
        });
      }
      const availableIds = configuredProviders.map((p) => p.id).join(", ");
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider "${providerId}" \u4E0D\u5B58\u5728\u3002\u53EF\u7528\u7684 Provider: ${availableIds}`, {
        providerId,
        taskType: task.taskType,
        availableProviders: availableIds
      });
    }
    const availabilityResult = await this.providerManager.checkAvailability(providerId);
    if (!availabilityResult.ok) {
      return err(availabilityResult.error.code, `Provider \u4E0D\u53EF\u7528: ${availabilityResult.error.message}`, {
        providerId,
        taskType: task.taskType,
        availabilityError: availabilityResult.error
      });
    }
    const capabilities = availabilityResult.value;
    if (requiredCapability === "chat" && !capabilities.chat) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider ${providerId} \u4E0D\u652F\u6301\u804A\u5929\u80FD\u529B`, {
        providerId,
        requiredCapability,
        availableCapabilities: capabilities
      });
    }
    if (requiredCapability === "embedding" && !capabilities.embedding) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider ${providerId} \u4E0D\u652F\u6301\u5D4C\u5165\u80FD\u529B`, {
        providerId,
        requiredCapability,
        availableCapabilities: capabilities
      });
    }
    if (requiredCapability === "image" && !capabilities.image) {
      return err("E401_PROVIDER_NOT_CONFIGURED", `Provider ${providerId} \u4E0D\u652F\u6301\u56FE\u7247\u751F\u6210\u80FD\u529B`, {
        providerId,
        requiredCapability,
        availableCapabilities: capabilities
      });
    }
    this.logger.debug("TaskRunner", "Provider \u80FD\u529B\u9A8C\u8BC1\u901A\u8FC7", {
      taskId: task.id,
      providerId,
      requiredCapability
    });
    return ok(void 0);
  }
  /**
   * 获取任务所需的能力
   * 
   * @param taskType 任务类型
   * @returns 所需能力类型
   */
  getRequiredCapability(taskType) {
    switch (taskType) {
      case "index":
        return "embedding";
      case "image-generate":
        return "image";
      case "define":
      case "tag":
      case "write":
      case "amend":
      case "merge":
      case "verify":
      default:
        return "chat";
    }
  }
};

// src/core/pipeline-state-store.ts
var PipelineStateStore = class {
  fileStorage;
  logger;
  path;
  saveChain = Promise.resolve();
  constructor(fileStorage, logger, path = "data/pipeline-state.json") {
    this.fileStorage = fileStorage;
    this.logger = logger;
    this.path = path;
  }
  /**
   * 加载管线状态文件
   *
   * 文件不存在时返回 null；文件损坏时清空状态并记录警告（需求 33.5）
   */
  async load() {
    try {
      const exists = await this.fileStorage.exists(this.path);
      if (!exists) {
        return ok(null);
      }
      const readResult = await this.fileStorage.read(this.path);
      if (!readResult.ok) {
        return readResult;
      }
      const parsed = JSON.parse(readResult.value);
      if (!parsed || typeof parsed !== "object") {
        this.logger.warn("PipelineStateStore", "\u7BA1\u7EBF\u72B6\u6001\u6587\u4EF6\u683C\u5F0F\u65E0\u6548\uFF0C\u5DF2\u6E05\u7A7A", {
          path: this.path
        });
        await this.clear();
        return ok(null);
      }
      const obj = parsed;
      const pipelinesRaw = obj.pipelines && typeof obj.pipelines === "object" ? obj.pipelines : {};
      const taskToPipelineRaw = obj.taskToPipeline && typeof obj.taskToPipeline === "object" ? obj.taskToPipeline : {};
      const pipelines = {};
      for (const [pipelineId, ctx] of Object.entries(pipelinesRaw)) {
        if (!ctx || typeof ctx !== "object") continue;
        pipelines[pipelineId] = ctx;
      }
      const taskToPipeline = {};
      for (const [taskId, pipelineId] of Object.entries(taskToPipelineRaw)) {
        if (typeof pipelineId !== "string") continue;
        taskToPipeline[taskId] = pipelineId;
      }
      return ok({
        version: "1.0.0",
        pipelines,
        taskToPipeline
      });
    } catch (error) {
      this.logger.warn("PipelineStateStore", "\u7BA1\u7EBF\u72B6\u6001\u6587\u4EF6\u635F\u574F\uFF0C\u5DF2\u6E05\u7A7A", {
        path: this.path,
        error: error instanceof Error ? error.message : String(error)
      });
      await this.clear();
      return ok(null);
    }
  }
  /**
   * 保存完整管线状态
   */
  async save(state2) {
    const content = JSON.stringify(state2, null, 2);
    this.saveChain = this.saveChain.then(async () => {
      const writeResult = await this.fileStorage.atomicWrite(this.path, content);
      if (!writeResult.ok) {
        this.logger.error("PipelineStateStore", "\u4FDD\u5B58\u7BA1\u7EBF\u72B6\u6001\u5931\u8D25", void 0, {
          path: this.path,
          error: writeResult.error
        });
      }
    }).catch((error) => {
      this.logger.error("PipelineStateStore", "\u4FDD\u5B58\u7BA1\u7EBF\u72B6\u6001\u5F02\u5E38", error, {
        path: this.path
      });
    });
    await this.saveChain;
    return ok(void 0);
  }
  /**
   * 清空管线状态文件（损坏恢复用）
   *
   * @see 需求 33.5
   */
  async clear() {
    const emptyState = {
      version: "1.0.0",
      pipelines: {},
      taskToPipeline: {}
    };
    return this.save(emptyState);
  }
  /**
   * 从多个 Orchestrator 收集活跃管线状态并持久化
   *
   * 仅持久化处于 review_changes 阶段的管线（需求 33.1）
   * 管线完成或取消后自动从文件中移除（需求 33.4）
   */
  async persistFromOrchestrators(orchestrators) {
    const allPipelines = {};
    const allTaskToPipeline = {};
    for (const orch of orchestrators) {
      const state2 = orch.getActiveState();
      for (const [id, ctx] of state2.pipelines) {
        if (ctx.stage === "review_changes") {
          allPipelines[id] = ctx;
        }
      }
      for (const [taskId, pipelineId] of state2.taskToPipeline) {
        if (allPipelines[pipelineId]) {
          allTaskToPipeline[taskId] = pipelineId;
        }
      }
    }
    return this.save({
      version: "1.0.0",
      pipelines: allPipelines,
      taskToPipeline: allTaskToPipeline
    });
  }
  /**
   * 从文件恢复管线状态到各 Orchestrator
   *
   * @see 需求 33.2
   */
  async restoreToOrchestrators(orchestrators) {
    const loadResult = await this.load();
    if (!loadResult.ok) {
      return err(loadResult.error.code, loadResult.error.message);
    }
    const state2 = loadResult.value;
    if (!state2 || Object.keys(state2.pipelines).length === 0) {
      return ok(0);
    }
    const pipelines = /* @__PURE__ */ new Map();
    const taskToPipeline = /* @__PURE__ */ new Map();
    for (const [id, ctx] of Object.entries(state2.pipelines)) {
      pipelines.set(id, ctx);
    }
    for (const [taskId, pipelineId] of Object.entries(state2.taskToPipeline)) {
      taskToPipeline.set(taskId, pipelineId);
    }
    for (const orch of orchestrators) {
      orch.restorePipelines(pipelines, taskToPipeline);
    }
    const count = pipelines.size;
    this.logger.info("PipelineStateStore", `\u5DF2\u6062\u590D ${count} \u6761\u7BA1\u7EBF\u72B6\u6001`, {
      pipelineIds: Array.from(pipelines.keys())
    });
    return ok(count);
  }
};

// src/core/orchestrator-utils.ts
function validatePrerequisites(settings, taskType, providerId, promptManager, logger, callerName, conceptType) {
  if (!providerId) {
    logger.error(callerName, "Provider \u672A\u914D\u7F6E", void 0, {
      taskType,
      event: "PREREQUISITE_CHECK_FAILED"
    });
    return err("E401_PROVIDER_NOT_CONFIGURED", `\u4EFB\u52A1 ${taskType} \u672A\u914D\u7F6E Provider\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6E Provider`);
  }
  const providerConfig = settings.providers[providerId];
  if (!providerConfig) {
    logger.error(callerName, "Provider \u4E0D\u5B58\u5728", void 0, {
      taskType,
      providerId,
      event: "PREREQUISITE_CHECK_FAILED"
    });
    return err("E401_PROVIDER_NOT_CONFIGURED", `Provider "${providerId}" \u4E0D\u5B58\u5728\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u91CD\u65B0\u914D\u7F6E`);
  }
  if (!providerConfig.enabled) {
    logger.error(callerName, "Provider \u5DF2\u7981\u7528", void 0, {
      taskType,
      providerId,
      event: "PREREQUISITE_CHECK_FAILED"
    });
    return err("E401_PROVIDER_NOT_CONFIGURED", `Provider "${providerId}" \u5DF2\u7981\u7528\uFF0C\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u542F\u7528`);
  }
  if (!providerConfig.apiKey) {
    logger.error(callerName, "Provider API Key \u672A\u914D\u7F6E", void 0, {
      taskType,
      providerId,
      event: "PREREQUISITE_CHECK_FAILED"
    });
    return err("E401_PROVIDER_NOT_CONFIGURED", `Provider "${providerId}" \u7684 API Key \u672A\u914D\u7F6E`);
  }
  const templateId = promptManager.resolveTemplateId(taskType, conceptType);
  if (!promptManager.hasTemplate(templateId)) {
    logger.error(callerName, "\u6A21\u677F\u672A\u52A0\u8F7D", void 0, {
      taskType,
      templateId,
      event: "PREREQUISITE_CHECK_FAILED"
    });
    return err("E404_TEMPLATE_NOT_FOUND", `\u6A21\u677F "${templateId}" \u672A\u52A0\u8F7D\uFF0C\u8BF7\u68C0\u67E5 prompts \u76EE\u5F55`);
  }
  logger.debug(callerName, "\u524D\u7F6E\u6821\u9A8C\u901A\u8FC7", {
    taskType,
    providerId,
    event: "PREREQUISITE_CHECK_PASSED"
  });
  return ok(void 0);
}
function resolveProviderIdForTask(settings, taskType, logger, callerName) {
  const taskModel = settings.taskModels[taskType];
  if (taskModel?.providerId && taskModel.providerId.trim() !== "") {
    return taskModel.providerId;
  }
  if (settings.defaultProviderId && settings.defaultProviderId.trim() !== "") {
    return settings.defaultProviderId;
  }
  const firstProvider = Object.keys(settings.providers).find(
    (id) => settings.providers[id].enabled
  );
  if (firstProvider) {
    logger.warn(callerName, `\u4EFB\u52A1 ${taskType} \u672A\u914D\u7F6E Provider\uFF0C\u4F7F\u7528\u7B2C\u4E00\u4E2A\u53EF\u7528 Provider: ${firstProvider}`);
    return firstProvider;
  }
  logger.error(callerName, `\u4EFB\u52A1 ${taskType} \u672A\u914D\u7F6E Provider\uFF0C\u4E14\u6CA1\u6709\u53EF\u7528\u7684 Provider`);
  return "";
}
function buildVerificationReportMarkdown(result) {
  const now2 = formatCRTimestamp();
  const lines = [];
  lines.push("## \u4E8B\u5B9E\u6838\u67E5\u62A5\u544A\n");
  const assessment = result.overall_assessment;
  if (typeof assessment === "string" && assessment) {
    const label2 = assessment === "pass" ? "\u2705 \u901A\u8FC7" : assessment === "needs_review" ? "\u26A0\uFE0F \u9700\u8981\u5BA1\u67E5" : assessment === "fail" ? "\u274C \u672A\u901A\u8FC7" : assessment;
    lines.push(`**\u603B\u4F53\u8BC4\u4F30**: ${label2}`);
  }
  const score = result.confidence_score;
  if (typeof score === "number") {
    lines.push(`**\u7F6E\u4FE1\u5EA6**: ${(score * 100).toFixed(0)}%`);
  }
  const humanReview = result.requires_human_review;
  if (typeof humanReview === "boolean" && humanReview) {
    lines.push(`**\u9700\u8981\u4EBA\u5DE5\u5BA1\u67E5**: \u662F`);
  }
  lines.push("");
  const claims = result.verified_claims;
  if (Array.isArray(claims) && claims.length > 0) {
    lines.push("### \u5DF2\u9A8C\u8BC1\u58F0\u660E\n");
    for (const claim of claims) {
      if (typeof claim === "string") {
        lines.push(`- \u2705 ${claim}`);
      }
    }
    lines.push("");
  }
  const issues = result.issues;
  if (Array.isArray(issues) && issues.length > 0) {
    lines.push("### \u53D1\u73B0\u7684\u95EE\u9898\n");
    for (const issue of issues) {
      if (typeof issue === "object" && issue !== null) {
        const i = issue;
        const verdict = i.verdict === "false" ? "\u274C" : i.verdict === "suspect" ? "\u26A0\uFE0F" : "\u2753";
        lines.push(`- ${verdict} ${i.claim || ""}`);
        if (i.correction) {
          lines.push(`  - **\u4FEE\u6B63**: ${i.correction}`);
        }
        if (i.source) {
          lines.push(`  - **\u6765\u6E90**: ${i.source}`);
        }
        if (i.notes) {
          lines.push(`  - ${i.notes}`);
        }
      }
    }
    lines.push("");
  }
  const recs = result.recommendations;
  if (Array.isArray(recs) && recs.length > 0) {
    lines.push("### \u5EFA\u8BAE\n");
    for (const rec of recs) {
      if (typeof rec === "string") {
        lines.push(`- ${rec}`);
      }
    }
    lines.push("");
  }
  lines.push(`> \u6838\u67E5\u65F6\u95F4: ${now2}
`);
  return lines.join("\n");
}

// src/core/task-factory.ts
var TaskFactory = class {
  static create(params) {
    return {
      nodeId: params.nodeId,
      taskType: params.taskType,
      state: "Pending",
      attempt: 0,
      maxAttempts: params.maxAttempts,
      providerRef: params.providerRef,
      promptRef: params.promptRef,
      typeLockKey: params.typeLockKey,
      payload: params.payload
    };
  }
};

// src/data/validators.ts
var UUID_V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
function isValidUUID(uid) {
  return UUID_V4_REGEX.test(uid);
}
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r2 = Math.random() * 16 | 0;
    const v = c === "x" ? r2 : r2 & 3 | 8;
    return v.toString(16);
  });
}
function isValidCRTimestamp(timestamp2) {
  const regex = /^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/;
  if (!regex.test(timestamp2)) {
    return false;
  }
  const date = new Date(timestamp2.replace(" ", "T"));
  return !isNaN(date.getTime());
}
function generateTimestamp() {
  return formatCRTimestamp();
}
function isValidCRType(type) {
  return ["Domain", "Issue", "Theory", "Entity", "Mechanism"].includes(type);
}
function isValidNoteState(state2) {
  return ["Stub", "Draft", "Evergreen"].includes(state2);
}
function validateCRFrontmatter(data) {
  if (!data || typeof data !== "object") {
    return err("INVALID_FRONTMATTER", "Frontmatter \u5FC5\u987B\u662F\u5BF9\u8C61");
  }
  const fm = data;
  if (!fm.cruid || typeof fm.cruid !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: cruid");
  }
  if (!isValidUUID(fm.cruid)) {
    return err("INVALID_UUID", `\u65E0\u6548\u7684 UUID \u683C\u5F0F: ${fm.cruid}`);
  }
  if (!fm.type || !isValidCRType(fm.type)) {
    return err("INVALID_TYPE", `\u65E0\u6548\u7684\u77E5\u8BC6\u7C7B\u578B: ${fm.type}`);
  }
  if (!fm.name || typeof fm.name !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: name");
  }
  if (!fm.status || !isValidNoteState(fm.status)) {
    return err("INVALID_STATUS", `\u65E0\u6548\u7684\u7B14\u8BB0\u72B6\u6001: ${fm.status}`);
  }
  if (!fm.created || typeof fm.created !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: created");
  }
  if (!isValidCRTimestamp(fm.created)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${fm.created}`);
  }
  if (!fm.updated || typeof fm.updated !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: updated");
  }
  if (!isValidCRTimestamp(fm.updated)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${fm.updated}`);
  }
  if (!Array.isArray(fm.parents)) {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: parents");
  }
  for (const parent of fm.parents) {
    if (typeof parent !== "string") {
      return err("INVALID_FIELD", "parents \u5FC5\u987B\u662F\u5B57\u7B26\u4E32\u6570\u7EC4");
    }
  }
  if (fm.aliases !== void 0 && !Array.isArray(fm.aliases)) {
    return err("INVALID_FIELD", "aliases \u5FC5\u987B\u662F\u6570\u7EC4");
  }
  if (fm.tags !== void 0 && !Array.isArray(fm.tags)) {
    return err("INVALID_FIELD", "tags \u5FC5\u987B\u662F\u6570\u7EC4");
  }
  if (fm.sourceUids !== void 0) {
    if (!Array.isArray(fm.sourceUids)) {
      return err("INVALID_FIELD", "sourceUids \u5FC5\u987B\u662F\u6570\u7EC4");
    }
    for (const uid of fm.sourceUids) {
      if (!isValidUUID(uid)) {
        return err("INVALID_UUID", `\u65E0\u6548\u7684\u6765\u6E90 UUID: ${uid}`);
      }
    }
  }
  return ok(fm);
}
function isValidTaskType(type) {
  return [
    "define",
    "tag",
    "write",
    "amend",
    "merge",
    "index",
    "verify",
    "image-generate"
  ].includes(type);
}
function isValidTaskState(state2) {
  return ["Pending", "Running", "Completed", "Failed", "Cancelled"].includes(state2);
}
function validateTaskRecord(data) {
  if (!data || typeof data !== "object") {
    return err("INVALID_TASK", "TaskRecord \u5FC5\u987B\u662F\u5BF9\u8C61");
  }
  const task = data;
  if (!task.id || typeof task.id !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: id");
  }
  if (!task.taskType || !isValidTaskType(task.taskType)) {
    return err("INVALID_TYPE", `\u65E0\u6548\u7684\u4EFB\u52A1\u7C7B\u578B: ${task.taskType}`);
  }
  if (!task.nodeId || typeof task.nodeId !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: nodeId");
  }
  if (!isValidUUID(task.nodeId) && task.taskType !== "image-generate") {
    return err("INVALID_UUID", `\u65E0\u6548\u7684\u8282\u70B9 UUID: ${task.nodeId}`);
  }
  if (!task.state || !isValidTaskState(task.state)) {
    return err("INVALID_STATE", `\u65E0\u6548\u7684\u4EFB\u52A1\u72B6\u6001: ${task.state}`);
  }
  if (typeof task.attempt !== "number" || task.attempt < 0) {
    return err("INVALID_FIELD", "attempt \u5FC5\u987B\u662F\u975E\u8D1F\u6574\u6570");
  }
  if (typeof task.maxAttempts !== "number" || task.maxAttempts < 1) {
    return err("INVALID_FIELD", "maxAttempts \u5FC5\u987B\u662F\u6B63\u6574\u6570");
  }
  if (!task.payload || typeof task.payload !== "object") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: payload");
  }
  if (!task.created || typeof task.created !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: created");
  }
  if (!isValidCRTimestamp(task.created)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${task.created}`);
  }
  if (!task.updated || typeof task.updated !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: updated");
  }
  if (!isValidCRTimestamp(task.updated)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${task.updated}`);
  }
  if (task.startedAt !== void 0 && !isValidCRTimestamp(task.startedAt)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${task.startedAt}`);
  }
  if (task.completedAt !== void 0 && !isValidCRTimestamp(task.completedAt)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${task.completedAt}`);
  }
  if (task.errors !== void 0 && !Array.isArray(task.errors)) {
    return err("INVALID_FIELD", "errors \u5FC5\u987B\u662F\u6570\u7EC4");
  }
  return ok(task);
}
function isValidDuplicatePairStatus(status) {
  return ["pending", "merging", "merged", "dismissed"].includes(status);
}
function validateDuplicatePair(data) {
  if (!data || typeof data !== "object") {
    return err("INVALID_DUPLICATE_PAIR", "DuplicatePair \u5FC5\u987B\u662F\u5BF9\u8C61");
  }
  const pair = data;
  if (!pair.id || typeof pair.id !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: id");
  }
  if (!pair.nodeIdA || typeof pair.nodeIdA !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: nodeIdA");
  }
  if (!isValidUUID(pair.nodeIdA)) {
    return err("INVALID_UUID", `\u65E0\u6548\u7684 nodeIdA: ${pair.nodeIdA}`);
  }
  if (!pair.nodeIdB || typeof pair.nodeIdB !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: nodeIdB");
  }
  if (!isValidUUID(pair.nodeIdB)) {
    return err("INVALID_UUID", `\u65E0\u6548\u7684 nodeIdB: ${pair.nodeIdB}`);
  }
  if (!pair.type || !isValidCRType(pair.type)) {
    return err("INVALID_TYPE", `\u65E0\u6548\u7684\u77E5\u8BC6\u7C7B\u578B: ${pair.type}`);
  }
  if (typeof pair.similarity !== "number" || pair.similarity < 0 || pair.similarity > 1) {
    return err("INVALID_FIELD", "similarity \u5FC5\u987B\u662F 0-1 \u4E4B\u95F4\u7684\u6570\u5B57");
  }
  if (!pair.detectedAt || typeof pair.detectedAt !== "string") {
    return err("MISSING_FIELD", "\u7F3A\u5C11\u5FC5\u586B\u5B57\u6BB5: detectedAt");
  }
  if (!isValidCRTimestamp(pair.detectedAt)) {
    return err("INVALID_TIMESTAMP", `\u65E0\u6548\u7684\u65F6\u95F4\u6233\u683C\u5F0F: ${pair.detectedAt}`);
  }
  if (!pair.status || !isValidDuplicatePairStatus(pair.status)) {
    return err("INVALID_STATUS", `\u65E0\u6548\u7684\u91CD\u590D\u5BF9\u72B6\u6001: ${pair.status}`);
  }
  return ok(pair);
}
function validateUrl(url) {
  if (!url || typeof url !== "string") {
    return "URL \u4E0D\u80FD\u4E3A\u7A7A";
  }
  const trimmedUrl = url.trim();
  if (trimmedUrl.length === 0) {
    return "URL \u4E0D\u80FD\u4E3A\u7A7A";
  }
  if (!/^https?:\/\/.+/.test(trimmedUrl)) {
    return "URL \u5FC5\u987B\u4EE5 http:// \u6216 https:// \u5F00\u5934";
  }
  try {
    const parsedUrl = new URL(trimmedUrl);
    if (parsedUrl.protocol !== "http:" && parsedUrl.protocol !== "https:") {
      return "URL \u5FC5\u987B\u4F7F\u7528 HTTP \u6216 HTTPS \u534F\u8BAE";
    }
    if (!parsedUrl.hostname || parsedUrl.hostname.length === 0) {
      return "URL \u5FC5\u987B\u5305\u542B\u6709\u6548\u7684\u4E3B\u673A\u540D";
    }
    return null;
  } catch {
    return "\u65E0\u6548\u7684 URL \u683C\u5F0F";
  }
}

// src/core/create-orchestrator.ts
var CreateOrchestrator = class {
  deps;
  logger;
  /** 活跃管线上下文 */
  pipelines = /* @__PURE__ */ new Map();
  /** 事件监听器 */
  listeners = [];
  /** taskId → pipelineId 映射 */
  taskToPipeline = /* @__PURE__ */ new Map();
  /** 队列事件取消订阅 */
  unsubscribeQueue;
  constructor(deps) {
    this.deps = deps;
    this.logger = deps.logger;
    this.subscribeToTaskQueue();
    this.logger.debug("CreateOrchestrator", "\u521B\u5EFA\u7BA1\u7EBF\u7F16\u6392\u5668\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // ========================================================================
  // 公开方法
  // ========================================================================
  /**
   * 直接 Define（不入队）
   *
   * 直接调用 ProviderManager.chat，不进入任务队列，
   * 立即返回结果给 UI 用于用户确认。
   *
   * @param userInput 用户输入的概念
   * @returns Define 结果（包含类型置信度与标准命名）
   */
  async defineDirect(userInput) {
    try {
      const prerequisiteCheck = this.validatePrerequisites("define");
      if (!prerequisiteCheck.ok) {
        return prerequisiteCheck;
      }
      const suspicious = [/ignore\s+previous\s+instructions/i, /system\s*:/i, /\[INST\]/i, /<\|im_start\|>/i];
      if (typeof userInput !== "string" || userInput.trim().length === 0) {
        return err("E101_INVALID_INPUT", "\u8F93\u5165\u4E0D\u80FD\u4E3A\u7A7A");
      }
      if (userInput.length > 1e4) {
        return err("E101_INVALID_INPUT", "\u8F93\u5165\u8FC7\u957F\uFF0C\u8BF7\u7F29\u77ED\u540E\u91CD\u8BD5\uFF08\u6700\u5927 10000 \u5B57\u7B26\uFF09");
      }
      for (const pattern of suspicious) {
        if (pattern.test(userInput)) {
          return err("E101_INVALID_INPUT", "\u8F93\u5165\u5305\u542B\u53EF\u7591\u6307\u4EE4\uFF0C\u8BF7\u68C0\u67E5\u540E\u91CD\u8BD5");
        }
      }
      const sanitizedInput = userInput.replace(/[\x00-\x1F\x7F]/g, "").replace(/\s+/g, " ").trim();
      this.logger.info("CreateOrchestrator", "\u5F00\u59CB\u76F4\u63A5\u6807\u51C6\u5316", {
        userInput: userInput.substring(0, 50),
        event: "STANDARDIZE_DIRECT_START"
      });
      const settings = this.getSettings();
      const taskConfig = settings.taskModels["define"];
      const providerId = taskConfig.providerId;
      let prompt;
      try {
        prompt = this.deps.promptManager.build("define", { CTX_INPUT: sanitizedInput });
      } catch (error) {
        this.logger.error("CreateOrchestrator", "\u6784\u5EFA\u6807\u51C6\u5316\u63D0\u793A\u8BCD\u5931\u8D25", error, {
          event: "STANDARDIZE_DIRECT_ERROR"
        });
        return toErr(error, "E500_INTERNAL_ERROR", "\u6784\u5EFA\u6807\u51C6\u5316\u63D0\u793A\u8BCD\u5931\u8D25");
      }
      const chatResult = await this.deps.providerManager.chat({
        providerId,
        model: taskConfig.model,
        messages: [
          { role: "system", content: prompt },
          { role: "user", content: sanitizedInput }
        ],
        temperature: taskConfig.temperature,
        topP: taskConfig.topP,
        maxTokens: taskConfig.maxTokens
      });
      if (!chatResult.ok) {
        this.logger.error("CreateOrchestrator", "\u6807\u51C6\u5316 API \u8C03\u7528\u5931\u8D25", void 0, {
          errorCode: chatResult.error.code,
          errorMessage: chatResult.error.message,
          event: "STANDARDIZE_DIRECT_ERROR"
        });
        return err(chatResult.error.code, chatResult.error.message);
      }
      try {
        const content = chatResult.value.content.trim();
        const jsonMatch = content.match(/```json\s*([\s\S]*?)\s*```/) || content.match(/```\s*([\s\S]*?)\s*```/);
        const jsonStr = jsonMatch ? jsonMatch[1] : content;
        const rawParsed = JSON.parse(jsonStr);
        const parsed = mapStandardizeOutput(rawParsed);
        this.logger.info("CreateOrchestrator", "\u76F4\u63A5\u6807\u51C6\u5316\u5B8C\u6210", {
          primaryType: parsed.primaryType,
          event: "STANDARDIZE_DIRECT_SUCCESS"
        });
        return ok(parsed);
      } catch (parseError) {
        this.logger.error("CreateOrchestrator", "\u89E3\u6790\u6807\u51C6\u5316\u7ED3\u679C\u5931\u8D25", parseError, {
          response: chatResult.value.content.substring(0, 200),
          event: "STANDARDIZE_DIRECT_PARSE_ERROR"
        });
        return err("E210_MODEL_OUTPUT_PARSE_FAILED", "\u89E3\u6790\u6807\u51C6\u5316\u7ED3\u679C\u5931\u8D25", parseError);
      }
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u76F4\u63A5\u6807\u51C6\u5316\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u76F4\u63A5\u6807\u51C6\u5316\u5931\u8D25", error);
    }
  }
  /**
   * standardizeDirect 的别名（向后兼容）
   */
  async standardizeDirect(userInput) {
    return this.defineDirect(userInput);
  }
  /**
   * 启动创建管线（使用已标准化的数据）
   *
   * @param standardizedData 标准化结果
   * @param selectedType 用户选择的知识类型
   * @param options 预设选项（Expand 场景使用）
   * @returns 管线 ID
   */
  startCreatePipeline(standardizedData, selectedType, options) {
    try {
      const prerequisiteCheck = this.validatePrerequisites("tag");
      if (!prerequisiteCheck.ok) {
        return prerequisiteCheck;
      }
      const duplicateCheck = this.checkDuplicateByName(
        standardizedData,
        selectedType,
        options?.targetPathOverride
      );
      if (!duplicateCheck.ok) {
        this.logger.warn("CreateOrchestrator", "\u91CD\u590D\u540D\u79F0\u68C0\u67E5\u5931\u8D25\uFF0C\u7BA1\u7EBF\u672A\u542F\u52A8", {
          type: selectedType,
          error: duplicateCheck.error,
          targetPathOverride: options?.targetPathOverride
        });
        return duplicateCheck;
      }
      const pipelineId = this.generatePipelineId();
      const nodeId = this.generateNodeId();
      const now2 = formatCRTimestamp();
      const context = {
        kind: "create",
        pipelineId,
        nodeId,
        type: selectedType,
        stage: "tagging",
        // 直接进入 tagging 阶段
        userInput: standardizedData.standardNames[selectedType].chinese,
        standardizedData: {
          standardNames: standardizedData.standardNames,
          typeConfidences: standardizedData.typeConfidences,
          primaryType: selectedType,
          coreDefinition: standardizedData.coreDefinition
        },
        parents: options?.parents,
        targetPathOverride: options?.targetPathOverride,
        sources: options?.sources,
        filePath: options?.targetPathOverride,
        createdAt: now2,
        updatedAt: now2
      };
      this.pipelines.set(pipelineId, context);
      this.logger.info("CreateOrchestrator", `\u542F\u52A8\u521B\u5EFA\u7BA1\u7EBF: ${pipelineId}`, {
        nodeId,
        selectedType,
        chinese: standardizedData.standardNames[selectedType].chinese,
        targetPathOverride: options?.targetPathOverride,
        parents: options?.parents
      });
      const settings = this.getSettings();
      let taskId;
      try {
        taskId = this.deps.taskQueue.enqueue(
          TaskFactory.create({
            nodeId,
            taskType: "tag",
            maxAttempts: settings.maxRetryAttempts,
            providerRef: this.getProviderIdForTask("tag"),
            payload: {
              pipelineId,
              standardizedData: context.standardizedData,
              conceptType: selectedType,
              userInput: context.userInput
            }
          })
        );
      } catch (error) {
        this.pipelines.delete(pipelineId);
        if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
          const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
          return err("E320_TASK_CONFLICT", msg);
        }
        return toErr(error, "E500_INTERNAL_ERROR", "\u521B\u5EFA\u4EFB\u52A1\u5931\u8D25");
      }
      this.taskToPipeline.set(taskId, pipelineId);
      this.publishEvent({
        type: "stage_changed",
        pipelineId,
        stage: "tagging",
        context,
        timestamp: now2
      });
      return ok(pipelineId);
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u542F\u52A8\u7BA1\u7EBF\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u542F\u52A8\u7BA1\u7EBF\u5931\u8D25", error);
    }
  }
  /**
   * startCreatePipelineWithStandardized 的别名（向后兼容）
   */
  startCreatePipelineWithStandardized(standardizedData, selectedType) {
    return this.startCreatePipeline(standardizedData, selectedType);
  }
  /**
   * startCreatePipelineWithPreset 的别名（向后兼容）
   */
  startCreatePipelineWithPreset(standardizedData, selectedType, options) {
    return this.startCreatePipeline(standardizedData, selectedType, options);
  }
  /**
   * 确认创建：生成 Stub → 入队 Write 任务
   *
   * @param pipelineId 管线 ID
   */
  async confirmCreate(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (context.stage !== "review_draft") {
      return err("E310_INVALID_STATE", `\u7BA1\u7EBF\u72B6\u6001\u4E0D\u6B63\u786E: ${context.stage}\uFF0C\u671F\u671B: review_draft`);
    }
    try {
      this.logger.info("CreateOrchestrator", `\u7528\u6237\u786E\u8BA4\u521B\u5EFA: ${pipelineId}`);
      const stubResult = await this.createStubFile(context);
      if (!stubResult.ok) {
        context.stage = "failed";
        context.error = { code: stubResult.error.code, message: stubResult.error.message };
        return stubResult;
      }
      context.stage = "writing";
      context.updatedAt = formatCRTimestamp();
      const settings = this.getSettings();
      let taskId;
      try {
        taskId = this.deps.taskQueue.enqueue(
          TaskFactory.create({
            nodeId: context.nodeId,
            taskType: "write",
            maxAttempts: settings.maxRetryAttempts,
            providerRef: this.getProviderIdForTask("write"),
            payload: {
              pipelineId,
              standardizedData: context.standardizedData,
              conceptType: context.type,
              coreDefinition: context.standardizedData?.coreDefinition,
              enrichedData: context.enrichedData,
              embedding: context.embedding,
              filePath: context.filePath,
              skipSnapshot: true,
              userInput: context.userInput,
              sources: context.sources
            }
          })
        );
      } catch (error) {
        context.stage = "failed";
        if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
          const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
          context.error = { code: "E320_TASK_CONFLICT", message: msg };
          return err("E320_TASK_CONFLICT", msg);
        }
        const converted = toErr(error, "E500_INTERNAL_ERROR", "\u521B\u5EFA\u4EFB\u52A1\u5931\u8D25");
        context.error = { code: converted.error.code, message: converted.error.message };
        return converted;
      }
      this.taskToPipeline.set(taskId, pipelineId);
      this.publishEvent({
        type: "stage_changed",
        pipelineId,
        stage: "writing",
        context,
        timestamp: context.updatedAt
      });
      return ok(void 0);
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u786E\u8BA4\u521B\u5EFA\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u786E\u8BA4\u521B\u5EFA\u5931\u8D25", error);
    }
  }
  /**
   * 确认写入（Create 管线的最终写入）
   *
   * @param pipelineId 管线 ID
   */
  async confirmWrite(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (context.stage !== "review_changes") {
      return err("E310_INVALID_STATE", `\u7BA1\u7EBF\u72B6\u6001\u4E0D\u6B63\u786E: ${context.stage}\uFF0C\u671F\u671B: review_changes`);
    }
    try {
      context.stage = "writing";
      context.updatedAt = formatCRTimestamp();
      this.logger.info("CreateOrchestrator", `\u786E\u8BA4\u5199\u5165: ${pipelineId}`);
      return await this.confirmCreateWrite(context);
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u786E\u8BA4\u5199\u5165\u5931\u8D25", error);
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: String(error) };
      return err("E500_INTERNAL_ERROR", "\u786E\u8BA4\u5199\u5165\u5931\u8D25", error);
    }
  }
  /**
   * 更新标准化数据（用户修改类型/名称）
   */
  updateStandardizedData(pipelineId, updates) {
    const edits = updates || {};
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (!context.standardizedData) {
      return err("E310_INVALID_STATE", "\u6807\u51C6\u5316\u7ED3\u679C\u5C1A\u672A\u751F\u6210\uFF0C\u65E0\u6CD5\u66F4\u65B0");
    }
    const merged = {
      ...context.standardizedData,
      ...edits,
      standardNames: {
        ...context.standardizedData.standardNames,
        ...edits.standardNames || {}
      },
      typeConfidences: edits.typeConfidences ?? context.standardizedData.typeConfidences ?? {}
    };
    if (edits.primaryType) {
      merged.primaryType = edits.primaryType;
      context.type = edits.primaryType;
    } else if (merged.typeConfidences) {
      const primaryType = Object.entries(merged.typeConfidences).sort(([, a], [, b]) => b - a)[0]?.[0];
      if (primaryType) {
        merged.primaryType = primaryType;
        context.type = primaryType;
      }
    }
    context.standardizedData = merged;
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "stage_changed",
      pipelineId,
      stage: context.stage,
      context,
      timestamp: context.updatedAt
    });
    return ok(context);
  }
  /**
   * 构建写入预览
   */
  async buildWritePreview(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (!["review_changes", "saving", "checking_duplicates"].includes(context.stage)) {
      return err("E310_INVALID_STATE", `\u5F53\u524D\u9636\u6BB5\u4E0D\u652F\u6301\u9884\u89C8: ${context.stage}`);
    }
    return this.composeWriteContent(context);
  }
  /**
   * 取消管线
   */
  cancelPipeline(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    for (const [taskId, pid] of this.taskToPipeline.entries()) {
      if (pid === pipelineId) {
        try {
          this.deps.taskQueue.cancel(taskId);
        } catch (error) {
          this.logger.warn("CreateOrchestrator", `\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25: ${taskId}`, {
            pipelineId,
            error: error instanceof Error ? error.message : String(error)
          });
        }
        this.taskToPipeline.delete(taskId);
      }
    }
    context.stage = "failed";
    context.error = { code: "E310_INVALID_STATE", message: "\u7528\u6237\u53D6\u6D88" };
    context.updatedAt = formatCRTimestamp();
    this.logger.info("CreateOrchestrator", `\u7BA1\u7EBF\u5DF2\u53D6\u6D88: ${pipelineId}`);
    return ok(void 0);
  }
  /**
   * 获取管线上下文
   */
  getContext(pipelineId) {
    return this.pipelines.get(pipelineId);
  }
  /**
   * 获取所有活跃管线
   */
  getActivePipelines() {
    return Array.from(this.pipelines.values()).filter(
      (ctx) => ctx.stage !== "completed" && ctx.stage !== "failed"
    );
  }
  /**
   * 订阅管线事件
   */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /**
   * 恢复持久化的管线状态
   */
  restorePipelines(pipelines, taskToPipeline) {
    for (const [id, ctx] of pipelines) {
      if (ctx.kind === "create") {
        this.pipelines.set(id, ctx);
      }
    }
    for (const [taskId, pipelineId] of taskToPipeline) {
      if (this.pipelines.has(pipelineId)) {
        this.taskToPipeline.set(taskId, pipelineId);
      }
    }
  }
  /**
   * 获取活跃管线和任务映射（用于持久化）
   */
  getActiveState() {
    const activePipelines = /* @__PURE__ */ new Map();
    for (const [id, ctx] of this.pipelines) {
      if (ctx.stage !== "completed" && ctx.stage !== "failed") {
        activePipelines.set(id, ctx);
      }
    }
    const activeTaskMap = /* @__PURE__ */ new Map();
    for (const [taskId, pipelineId] of this.taskToPipeline) {
      if (activePipelines.has(pipelineId)) {
        activeTaskMap.set(taskId, pipelineId);
      }
    }
    return { pipelines: activePipelines, taskToPipeline: activeTaskMap };
  }
  /**
   * 释放资源
   */
  dispose() {
    if (this.unsubscribeQueue) {
      this.unsubscribeQueue();
      this.unsubscribeQueue = void 0;
    }
  }
  // ========================================================================
  // 私有方法 — 任务队列事件处理
  // ========================================================================
  /**
   * 订阅任务队列事件
   */
  subscribeToTaskQueue() {
    this.unsubscribeQueue?.();
    this.unsubscribeQueue = this.deps.taskQueue.subscribe((event2) => {
      if (event2.type === "task-completed" && event2.taskId) {
        this.handleTaskCompleted(event2.taskId);
      } else if (event2.type === "task-failed" && event2.taskId) {
        this.handleTaskFailed(event2.taskId);
      }
    });
  }
  /**
   * 处理任务完成事件
   */
  async handleTaskCompleted(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    if (!task) return;
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    this.logger.debug("CreateOrchestrator", `\u4EFB\u52A1\u5B8C\u6210: ${taskId}`, {
      pipelineId,
      taskType: task.taskType
    });
    switch (task.taskType) {
      case "tag":
        await this.handleTagCompleted(context, task);
        break;
      case "write":
        await this.handleWriteCompleted(context, task);
        break;
      case "verify":
        await this.handleVerifyCompleted(context, task);
        break;
    }
  }
  /**
   * 处理任务失败事件
   */
  handleTaskFailed(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task?.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    context.stage = "failed";
    context.error = {
      code: task?.errors?.[0]?.code || "E500_INTERNAL_ERROR",
      message: task?.errors?.[0]?.message || "\u4EFB\u52A1\u6267\u884C\u5931\u8D25"
    };
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "pipeline_failed",
      pipelineId,
      stage: "failed",
      context,
      timestamp: context.updatedAt
    });
    this.logger.error("CreateOrchestrator", `\u7BA1\u7EBF\u5931\u8D25: ${pipelineId}`, void 0, {
      taskId,
      error: context.error
    });
  }
  // ========================================================================
  // 私有方法 — 各阶段任务完成处理
  // ========================================================================
  /**
   * Tag 任务完成：自动确认创建
   */
  async handleTagCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      context.stage = "failed";
      context.error = { code: "E310_INVALID_STATE", message: "\u4E30\u5BCC\u7ED3\u679C\u7F3A\u5931" };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
      return;
    }
    context.enrichedData = result;
    context.stage = "review_draft";
    context.updatedAt = formatCRTimestamp();
    this.logger.info("CreateOrchestrator", `\u81EA\u52A8\u786E\u8BA4\u521B\u5EFA\u5E76\u751F\u6210\u5185\u5BB9: ${context.pipelineId}`);
    const confirmResult = await this.confirmCreate(context.pipelineId);
    if (!confirmResult.ok) {
      context.stage = "failed";
      context.error = { code: confirmResult.error.code, message: confirmResult.error.message };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
    }
  }
  /**
   * Write 任务完成：进入 indexing 阶段
   */
  async handleWriteCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (result?.content) {
      context.generatedContent = result.content;
    } else if (result) {
      context.generatedContent = result;
    }
    if (result?.snapshotId) {
      context.snapshotId = result.snapshotId;
    }
    if (!context.filePath && context.standardizedData) {
      const fileName = sanitizeFileName(context.standardizedData.standardNames[context.type].chinese);
      context.filePath = `${fileName}.md`;
    }
    context.stage = "indexing";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "stage_changed",
      pipelineId: context.pipelineId,
      stage: "indexing",
      context,
      timestamp: context.updatedAt
    });
    await this.executeEmbeddingDirect(context);
  }
  /**
   * Verify 任务完成：追加报告并完成管线
   */
  async handleVerifyCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      this.logger.warn("CreateOrchestrator", "Verify \u7ED3\u679C\u7F3A\u5931\uFF0C\u8DF3\u8FC7\u62A5\u544A\u8FFD\u52A0", {
        pipelineId: context.pipelineId
      });
      this.completePipeline(context);
      return;
    }
    context.verificationResult = result;
    if (context.filePath) {
      await this.appendVerificationReportToNote(context.filePath, result);
    }
    this.completePipeline(context);
  }
  // ========================================================================
  // 私有方法 — 管线核心逻辑
  // ========================================================================
  /**
   * 执行创建写入（Stub → Draft）
   */
  async confirmCreateWrite(context) {
    const composed = await this.composeWriteContent(context);
    if (!composed.ok) {
      context.stage = "failed";
      context.error = { code: composed.error.code, message: composed.error.message };
      return composed;
    }
    const { targetPath, newContent } = composed.value;
    context.filePath = targetPath;
    await this.deps.noteRepository.writeAtomic(targetPath, newContent);
    this.logger.info("CreateOrchestrator", `\u6587\u4EF6\u5DF2\u5199\u5165 (Stub \u2192 Draft): ${targetPath}`, {
      pipelineId: context.pipelineId,
      fileSize: newContent.length,
      hasSnapshot: !!context.snapshotId,
      statusTransition: "Stub \u2192 Draft"
    });
    if (context.embedding) {
      await this.deps.vectorIndex.upsert({
        uid: context.nodeId,
        type: context.type,
        embedding: context.embedding,
        updated: formatCRTimestamp()
      });
    }
    context.stage = "checking_duplicates";
    context.updatedAt = formatCRTimestamp();
    if (context.embedding) {
      await this.deps.duplicateManager.detect(
        context.nodeId,
        context.type,
        context.embedding
      );
    }
    await this.maybeStartAutoVerifyOrComplete(context);
    return ok(void 0);
  }
  /**
   * 直接执行 embedding（不进入队列）
   */
  async executeEmbeddingDirect(context) {
    try {
      this.logger.info("CreateOrchestrator", `\u76F4\u63A5\u6267\u884C index: ${context.pipelineId}`);
      const embeddingText = this.buildEmbeddingText(context);
      const settings = this.getSettings();
      const taskConfig = settings.taskModels["index"];
      const providerId = taskConfig?.providerId || this.getProviderIdForTask("index");
      const embeddingModel = this.deps.vectorIndex.getEmbeddingModel();
      const embeddingDimension = this.deps.vectorIndex.getEmbeddingDimension();
      const embedResult = await this.deps.providerManager.embed({
        providerId,
        model: embeddingModel,
        input: embeddingText,
        dimensions: embeddingDimension
      });
      if (!embedResult.ok) {
        throw new Error(`Embedding \u5931\u8D25: ${embedResult.error.message}`);
      }
      context.embedding = embedResult.value.embedding;
      context.updatedAt = formatCRTimestamp();
      this.logger.info("CreateOrchestrator", `Embedding \u5B8C\u6210: ${context.pipelineId}`, {
        tokensUsed: embedResult.value.tokensUsed
      });
      await this.autoConfirmWrite(context);
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u76F4\u63A5\u6267\u884C embedding \u5931\u8D25", error);
      context.stage = "failed";
      context.error = {
        code: "E500_INTERNAL_ERROR",
        message: error instanceof Error ? error.message : String(error)
      };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
    }
  }
  /**
   * 自动确认写入（无需 UI 交互）
   */
  async autoConfirmWrite(context) {
    this.logger.info("CreateOrchestrator", `\u81EA\u52A8\u5199\u5165\uFF08\u65E0\u9700\u786E\u8BA4\uFF09: ${context.pipelineId}`);
    context.stage = "review_changes";
    context.updatedAt = formatCRTimestamp();
    const writeResult = await this.confirmWrite(context.pipelineId);
    if (!writeResult.ok) {
      context.stage = "failed";
      context.error = { code: writeResult.error.code, message: writeResult.error.message };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
    }
  }
  /**
   * 根据设置决定是否自动 Verify 或直接完成
   */
  async maybeStartAutoVerifyOrComplete(context) {
    const settings = this.getSettings();
    if (!settings.enableAutoVerify) {
      this.completePipeline(context);
      return;
    }
    const prereqResult = this.validatePrerequisites("verify", context.type);
    if (!prereqResult.ok) {
      this.logger.warn("CreateOrchestrator", "Verify \u524D\u7F6E\u6821\u9A8C\u5931\u8D25\uFF0C\u8DF3\u8FC7\u81EA\u52A8\u6821\u9A8C\u5E76\u7ED3\u675F\u7BA1\u7EBF", {
        pipelineId: context.pipelineId,
        error: prereqResult.error
      });
      this.completePipeline(context);
      return;
    }
    const startResult = await this.startVerifyTask(context);
    if (!startResult.ok) {
      this.logger.warn("CreateOrchestrator", "\u542F\u52A8 Verify \u5931\u8D25\uFF0C\u8DF3\u8FC7\u81EA\u52A8\u6821\u9A8C\u5E76\u7ED3\u675F\u7BA1\u7EBF", {
        pipelineId: context.pipelineId,
        error: startResult.error
      });
      this.completePipeline(context);
    }
  }
  /**
   * 启动 Verify 任务
   */
  async startVerifyTask(context) {
    const filePath = context.filePath;
    if (!filePath) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6587\u4EF6\u8DEF\u5F84\uFF0C\u65E0\u6CD5\u6267\u884C Verify");
    }
    const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
    if (currentContent === null) {
      return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`, { filePath });
    }
    context.stage = "verifying";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "stage_changed",
      pipelineId: context.pipelineId,
      stage: "verifying",
      context,
      timestamp: context.updatedAt
    });
    this.logger.info("CreateOrchestrator", `\u542F\u52A8 Verify \u4EFB\u52A1: ${context.pipelineId}`, {
      filePath
    });
    const settings = this.getSettings();
    try {
      const taskId = this.deps.taskQueue.enqueue(
        TaskFactory.create({
          nodeId: context.nodeId,
          taskType: "verify",
          maxAttempts: settings.maxRetryAttempts,
          providerRef: this.getProviderIdForTask("verify"),
          payload: {
            pipelineId: context.pipelineId,
            filePath,
            currentContent,
            conceptType: context.type,
            standardizedData: context.standardizedData
          }
        })
      );
      this.taskToPipeline.set(taskId, context.pipelineId);
      return ok(void 0);
    } catch (error) {
      return toErr(error, "E500_INTERNAL_ERROR", "Verify \u4EFB\u52A1\u521B\u5EFA\u5931\u8D25");
    }
  }
  /**
   * 完成管线
   */
  completePipeline(context) {
    context.stage = "completed";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "pipeline_completed",
      pipelineId: context.pipelineId,
      stage: "completed",
      context,
      timestamp: context.updatedAt
    });
  }
  // ========================================================================
  // 私有方法 — 辅助工具
  // ========================================================================
  /**
   * 获取设置
   */
  getSettings() {
    return this.deps.settingsStore.getSettings();
  }
  /**
   * 前置校验：检查 Provider 和模板是否可用
   * 委托给 orchestrator-utils 共享实现（DRY）
   */
  validatePrerequisites(taskType, conceptType) {
    const settings = this.getSettings();
    const providerId = this.getProviderIdForTask(taskType);
    return validatePrerequisites(
      settings,
      taskType,
      providerId,
      this.deps.promptManager,
      this.logger,
      "CreateOrchestrator",
      conceptType
    );
  }
  /**
   * 检查是否存在同类型同名的笔记
   */
  checkDuplicateByName(standardizedData, type, targetPathOverride) {
    const settings = this.getSettings();
    const normalizedOverride = targetPathOverride && targetPathOverride.trim().length > 0 ? targetPathOverride.endsWith(".md") ? targetPathOverride : `${targetPathOverride}.md` : void 0;
    const signature = createConceptSignature(
      {
        standardName: standardizedData.standardNames[type],
        aliases: [],
        coreDefinition: standardizedData.coreDefinition
      },
      type,
      settings.namingTemplate
    );
    const targetPath = normalizedOverride ? normalizedOverride : generateFilePath(signature.standardName, settings.directoryScheme, type);
    const file = this.deps.noteRepository.getFileByPath(targetPath);
    if (file) {
      this.logger.warn("CreateOrchestrator", "\u68C0\u6D4B\u5230\u540C\u7C7B\u578B\u540C\u540D\u7B14\u8BB0", {
        type,
        name: signature.standardName,
        path: targetPath,
        event: "DUPLICATE_NAME_DETECTED"
      });
      return err(
        "E320_TASK_CONFLICT",
        `\u5DF2\u5B58\u5728\u540C\u7C7B\u578B\u540C\u540D\u7684\u7B14\u8BB0\uFF1A${signature.standardName}
\u8DEF\u5F84\uFF1A${targetPath}

\u8BF7\u4FEE\u6539\u6982\u5FF5\u540D\u79F0\u6216\u68C0\u67E5\u662F\u5426\u4E3A\u91CD\u590D\u521B\u5EFA\u3002`,
        {
          type,
          name: signature.standardName,
          path: targetPath
        }
      );
    }
    return ok(void 0);
  }
  /**
   * 获取任务对应的 Provider ID
   * 委托给 orchestrator-utils 共享实现（DRY）
   */
  getProviderIdForTask(taskType) {
    return resolveProviderIdForTask(this.getSettings(), taskType, this.logger, "CreateOrchestrator");
  }
  /**
   * 创建 Stub 文件（仅含 frontmatter）
   */
  async createStubFile(context) {
    try {
      if (!context.standardizedData) {
        return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6807\u51C6\u5316\u6570\u636E\uFF0C\u65E0\u6CD5\u521B\u5EFA Stub");
      }
      const settings = this.getSettings();
      const signature = createConceptSignature(
        {
          standardName: context.standardizedData.standardNames[context.type],
          aliases: context.enrichedData?.aliases || [],
          coreDefinition: context.standardizedData.coreDefinition
        },
        context.type,
        settings.namingTemplate
      );
      const { targetPath, targetName } = this.resolveCreateTarget(context, signature.standardName);
      context.filePath = targetPath;
      await this.deps.noteRepository.ensureDirForPath(targetPath);
      const frontmatter = generateFrontmatter({
        cruid: context.nodeId,
        type: context.type,
        name: targetName,
        parents: context.parents ?? [],
        status: "Stub",
        aliases: context.enrichedData?.aliases,
        tags: context.enrichedData?.tags
      });
      const stubContent = generateMarkdownContent(frontmatter, "");
      await this.deps.noteRepository.writeAtomic(targetPath, stubContent);
      this.logger.info("CreateOrchestrator", `Stub \u6587\u4EF6\u5DF2\u521B\u5EFA: ${targetPath}`, {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        status: "Stub"
      });
      return ok(targetPath);
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u521B\u5EFA Stub \u6587\u4EF6\u5931\u8D25", error);
      return err("E302_PERMISSION_DENIED", "\u521B\u5EFA Stub \u6587\u4EF6\u5931\u8D25", error);
    }
  }
  /**
   * 解析创建目标路径
   */
  resolveCreateTarget(context, signatureStandardName) {
    const settings = this.getSettings();
    const hasOverride = !!context.targetPathOverride && context.targetPathOverride.trim().length > 0;
    const targetPath = hasOverride ? context.targetPathOverride.endsWith(".md") ? context.targetPathOverride : `${context.targetPathOverride}.md` : context.filePath || generateFilePath(signatureStandardName, settings.directoryScheme, context.type);
    const targetName = hasOverride ? (targetPath.split("/").pop() || signatureStandardName).replace(/\.md$/i, "") || signatureStandardName : signatureStandardName;
    return { targetPath, targetName };
  }
  /**
   * 组合写入内容（Create 管线专用）
   */
  async composeWriteContent(context) {
    if (!context.standardizedData || !context.generatedContent) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u751F\u6210\u5185\u5BB9\u6216\u6807\u51C6\u5316\u6570\u636E");
    }
    const settings = this.getSettings();
    const signature = createConceptSignature(
      {
        standardName: context.standardizedData.standardNames[context.type],
        aliases: context.enrichedData?.aliases || [],
        coreDefinition: context.standardizedData.coreDefinition
      },
      context.type,
      settings.namingTemplate
    );
    const { targetPath, targetName } = this.resolveCreateTarget(context, signature.standardName);
    context.filePath = targetPath;
    await this.deps.noteRepository.ensureDirForPath(targetPath);
    const previousContent = await this.deps.noteRepository.readByPathIfExists(targetPath) ?? "";
    const markdownBody = this.renderContentToMarkdown(context, targetName);
    const definition = context.generatedContent && typeof context.generatedContent === "object" ? typeof context.generatedContent.definition === "string" ? context.generatedContent.definition : void 0 : void 0;
    const frontmatter = generateFrontmatter({
      cruid: context.nodeId,
      type: context.type,
      name: targetName,
      definition,
      parents: context.parents ?? [],
      status: "Draft",
      aliases: context.enrichedData?.aliases,
      tags: context.enrichedData?.tags
    });
    const fullContent = generateMarkdownContent(frontmatter, markdownBody);
    return ok({
      targetPath,
      previousContent,
      newContent: fullContent
    });
  }
  /**
   * 渲染内容为 Markdown
   */
  renderContentToMarkdown(context, standardName) {
    const settings = this.getSettings();
    const language = settings.language || "zh";
    const title = language === "en" ? context.standardizedData?.standardNames[context.type].english || standardName : standardName;
    return this.deps.contentRenderer.renderNoteMarkdown({
      title,
      type: context.type,
      content: context.generatedContent,
      language
    });
  }
  /**
   * 构建嵌入文本
   */
  buildEmbeddingText(context) {
    const parts = [];
    if (context.standardizedData) {
      const currentName = context.standardizedData.standardNames[context.type];
      parts.push(currentName.chinese);
      parts.push(currentName.english);
      if (context.standardizedData.coreDefinition) {
        parts.push(context.standardizedData.coreDefinition);
      }
    }
    parts.push(`\u7C7B\u578B: ${context.type}`);
    if (context.enrichedData?.tags) {
      parts.push(`\u6807\u7B7E: ${context.enrichedData.tags.join(", ")}`);
    }
    return parts.join("\n");
  }
  /**
   * 追加验证报告到笔记末尾
   * 委托给 orchestrator-utils 共享的 buildVerificationReportMarkdown（DRY）
   */
  async appendVerificationReportToNote(filePath, result) {
    try {
      const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
      if (currentContent === null) {
        this.logger.warn("CreateOrchestrator", "\u6587\u4EF6\u4E0D\u5B58\u5728\uFF0C\u65E0\u6CD5\u8FFD\u52A0\u62A5\u544A", { filePath });
        return;
      }
      const report = buildVerificationReportMarkdown(result);
      const separator = currentContent.endsWith("\n") ? "\n" : "\n\n";
      const newContent = `${currentContent}${separator}${report}`;
      await this.deps.noteRepository.writeAtomic(filePath, newContent);
      this.logger.info("CreateOrchestrator", `\u9A8C\u8BC1\u62A5\u544A\u5DF2\u8FFD\u52A0: ${filePath}`);
    } catch (error) {
      this.logger.error("CreateOrchestrator", "\u8FFD\u52A0\u9A8C\u8BC1\u62A5\u544A\u5931\u8D25", error, { filePath });
    }
  }
  /**
   * 生成管线 ID
   */
  generatePipelineId() {
    return `pipeline-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * 生成节点 ID (UUID v4)
   */
  generateNodeId() {
    return generateUUID();
  }
  /**
   * 发布事件
   */
  publishEvent(event2) {
    for (const listener of this.listeners) {
      try {
        listener(event2);
      } catch (error) {
        this.logger.error("CreateOrchestrator", "\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error);
      }
    }
  }
};

// src/core/amend-orchestrator.ts
var AmendOrchestrator = class {
  deps;
  logger;
  /** 活跃管线上下文 */
  pipelines = /* @__PURE__ */ new Map();
  /** 事件监听器 */
  listeners = [];
  /** taskId → pipelineId 映射 */
  taskToPipeline = /* @__PURE__ */ new Map();
  /** 队列事件取消订阅 */
  unsubscribeQueue;
  constructor(deps) {
    this.deps = deps;
    this.logger = deps.logger;
    this.subscribeToTaskQueue();
    this.logger.debug("AmendOrchestrator", "\u4FEE\u8BA2\u7BA1\u7EBF\u7F16\u6392\u5668\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // ========================================================================
  // 公开方法
  // ========================================================================
  /**
   * 启动修订管线
   *
   * 流程：读取笔记 → 创建快照 → 入队 Amend 任务
   *
   * @param filePath 目标笔记路径
   * @param instruction 修订指令
   * @returns 管线 ID
   */
  startAmendPipeline(filePath, instruction) {
    const prereqResult = this.validatePrerequisites("amend");
    if (!prereqResult.ok) {
      return prereqResult;
    }
    const file = this.deps.noteRepository.getFileByPath(filePath);
    if (!file) {
      return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`);
    }
    const pipelineId = this.generatePipelineId();
    const now2 = formatCRTimestamp();
    const nodeId = generateUUID();
    const context = {
      kind: "amend",
      pipelineId,
      nodeId,
      type: "Entity",
      // 临时类型，后续从 frontmatter 读取
      stage: "idle",
      userInput: instruction,
      filePath,
      createdAt: now2,
      updatedAt: now2
    };
    this.pipelines.set(pipelineId, context);
    this.logger.info("AmendOrchestrator", `\u542F\u52A8\u4FEE\u8BA2\u7BA1\u7EBF: ${pipelineId}`, {
      filePath,
      instruction: instruction.substring(0, 100)
    });
    void this.executeAmendPipeline(context, file, instruction);
    return ok(pipelineId);
  }
  /**
   * 确认写入（用户在 Diff 预览后确认）
   *
   * 流程：冲突检测 → 写入文件 → 重算 Embedding → 去重检测
   *
   * @param pipelineId 管线 ID
   */
  async confirmWrite(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (context.stage !== "review_changes") {
      return err("E310_INVALID_STATE", `\u7BA1\u7EBF\u72B6\u6001\u4E0D\u6B63\u786E: ${context.stage}\uFF0C\u671F\u671B: review_changes`);
    }
    try {
      context.stage = "writing";
      context.updatedAt = formatCRTimestamp();
      this.logger.info("AmendOrchestrator", `\u7528\u6237\u786E\u8BA4\u5199\u5165: ${pipelineId}`);
      return await this.confirmAmendWrite(context);
    } catch (error) {
      this.logger.error("AmendOrchestrator", "\u786E\u8BA4\u5199\u5165\u5931\u8D25", error);
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: String(error) };
      return err("E500_INTERNAL_ERROR", "\u786E\u8BA4\u5199\u5165\u5931\u8D25", error);
    }
  }
  /**
   * 构建写入预览（供 DiffView 使用）
   */
  async buildWritePreview(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (!["review_changes", "saving"].includes(context.stage)) {
      return err("E310_INVALID_STATE", `\u5F53\u524D\u9636\u6BB5\u4E0D\u652F\u6301\u9884\u89C8: ${context.stage}`);
    }
    return this.composeWriteContent(context);
  }
  /**
   * 取消管线
   */
  cancelPipeline(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    for (const [taskId, pid] of this.taskToPipeline.entries()) {
      if (pid === pipelineId) {
        try {
          this.deps.taskQueue.cancel(taskId);
        } catch (error) {
          this.logger.warn("AmendOrchestrator", `\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25: ${taskId}`, {
            pipelineId,
            error: error instanceof Error ? error.message : String(error)
          });
        }
        this.taskToPipeline.delete(taskId);
      }
    }
    context.stage = "failed";
    context.error = { code: "E310_INVALID_STATE", message: "\u7528\u6237\u53D6\u6D88" };
    context.updatedAt = formatCRTimestamp();
    void this.savePipelineState();
    this.logger.info("AmendOrchestrator", `\u7BA1\u7EBF\u5DF2\u53D6\u6D88: ${pipelineId}`);
    return ok(void 0);
  }
  /**
   * 获取管线上下文
   */
  getContext(pipelineId) {
    return this.pipelines.get(pipelineId);
  }
  /**
   * 获取所有活跃管线
   */
  getActivePipelines() {
    return Array.from(this.pipelines.values()).filter(
      (ctx) => ctx.stage !== "completed" && ctx.stage !== "failed"
    );
  }
  /**
   * 订阅管线事件
   */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /**
   * 恢复持久化的管线状态
   */
  restorePipelines(pipelines, taskToPipeline) {
    for (const [id, ctx] of pipelines) {
      if (ctx.kind === "amend") {
        this.pipelines.set(id, ctx);
      }
    }
    for (const [taskId, pipelineId] of taskToPipeline) {
      if (this.pipelines.has(pipelineId)) {
        this.taskToPipeline.set(taskId, pipelineId);
      }
    }
  }
  /**
   * 获取活跃管线和任务映射（用于持久化）
   */
  getActiveState() {
    const activePipelines = /* @__PURE__ */ new Map();
    for (const [id, ctx] of this.pipelines) {
      if (ctx.stage !== "completed" && ctx.stage !== "failed") {
        activePipelines.set(id, ctx);
      }
    }
    const activeTaskMap = /* @__PURE__ */ new Map();
    for (const [taskId, pipelineId] of this.taskToPipeline) {
      if (activePipelines.has(pipelineId)) {
        activeTaskMap.set(taskId, pipelineId);
      }
    }
    return { pipelines: activePipelines, taskToPipeline: activeTaskMap };
  }
  /**
   * 释放资源
   */
  dispose() {
    if (this.unsubscribeQueue) {
      this.unsubscribeQueue();
      this.unsubscribeQueue = void 0;
    }
  }
  // ========================================================================
  // 私有方法 — 任务队列事件处理
  // ========================================================================
  /**
   * 订阅任务队列事件
   */
  subscribeToTaskQueue() {
    this.unsubscribeQueue?.();
    this.unsubscribeQueue = this.deps.taskQueue.subscribe((event2) => {
      if (event2.type === "task-completed" && event2.taskId) {
        this.handleTaskCompleted(event2.taskId);
      } else if (event2.type === "task-failed" && event2.taskId) {
        this.handleTaskFailed(event2.taskId);
      }
    });
  }
  /**
   * 处理任务完成事件
   */
  async handleTaskCompleted(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    if (!task) return;
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    this.logger.debug("AmendOrchestrator", `\u4EFB\u52A1\u5B8C\u6210: ${taskId}`, {
      pipelineId,
      taskType: task.taskType
    });
    switch (task.taskType) {
      case "amend":
        await this.handleAmendCompleted(context, task);
        break;
      case "verify":
        await this.handleVerifyCompleted(context, task);
        break;
    }
  }
  /**
   * 处理任务失败事件
   */
  handleTaskFailed(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task?.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    context.stage = "failed";
    context.error = {
      code: task?.errors?.[0]?.code || "E500_INTERNAL_ERROR",
      message: task?.errors?.[0]?.message || "\u4EFB\u52A1\u6267\u884C\u5931\u8D25"
    };
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "pipeline_failed",
      pipelineId,
      stage: "failed",
      context,
      timestamp: context.updatedAt
    });
    this.logger.error("AmendOrchestrator", `\u7BA1\u7EBF\u5931\u8D25: ${pipelineId}`, void 0, {
      taskId,
      error: context.error
    });
  }
  // ========================================================================
  // 私有方法 — 各阶段任务完成处理
  // ========================================================================
  /**
   * Amend 任务完成：生成新内容并进入 Diff 确认阶段
   */
  async handleAmendCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      context.stage = "failed";
      context.error = { code: "E310_INVALID_STATE", message: "Amend \u7ED3\u679C\u7F3A\u5931" };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    if (!context.previousContent || !context.filePath) {
      context.stage = "failed";
      context.error = { code: "E310_INVALID_STATE", message: "\u7F3A\u5C11\u4FEE\u8BA2\u524D\u5185\u5BB9\u6216\u6587\u4EF6\u8DEF\u5F84" };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    const extracted = extractFrontmatter(context.previousContent);
    if (!extracted) {
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: "\u65E0\u6CD5\u89E3\u6790\u76EE\u6807\u7B14\u8BB0\u7684 frontmatter" };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    context.generatedContent = result;
    const file = this.deps.noteRepository.getFileByPath(context.filePath);
    const fallbackName = extracted.frontmatter.name?.trim() || file?.basename || "Unnamed Concept";
    const updatedFrontmatter = {
      ...extracted.frontmatter,
      name: fallbackName,
      parents: extracted.frontmatter.parents ?? [],
      updated: formatCRTimestamp()
    };
    const nextDefinition = typeof result.definition === "string" ? result.definition.trim() : void 0;
    if (nextDefinition) {
      updatedFrontmatter.definition = nextDefinition;
    }
    context.newContent = generateMarkdownContent(
      updatedFrontmatter,
      this.renderContentToMarkdown(context, updatedFrontmatter.name)
    );
    context.stage = "review_changes";
    context.updatedAt = formatCRTimestamp();
    void this.savePipelineState();
    this.publishEvent({
      type: "confirmation_required",
      pipelineId: context.pipelineId,
      stage: "review_changes",
      context,
      timestamp: context.updatedAt
    });
  }
  /**
   * Verify 任务完成：追加报告并完成管线
   */
  async handleVerifyCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      this.logger.warn("AmendOrchestrator", "Verify \u7ED3\u679C\u7F3A\u5931\uFF0C\u8DF3\u8FC7\u62A5\u544A\u8FFD\u52A0", {
        pipelineId: context.pipelineId
      });
      this.completePipeline(context);
      return;
    }
    context.verificationResult = result;
    if (context.filePath) {
      await this.appendVerificationReportToNote(context.filePath, result);
    }
    this.completePipeline(context);
  }
  // ========================================================================
  // 私有方法 — 管线核心逻辑
  // ========================================================================
  /**
   * 执行修订管线（异步）
   *
   * 流程：读取笔记 → 解析 frontmatter → 创建快照 → 入队 Amend 任务
   */
  async executeAmendPipeline(context, file, instruction) {
    try {
      const content = await this.deps.noteRepository.readByPath(file.path);
      context.previousContent = content;
      const extracted = extractFrontmatter(content);
      if (!extracted) {
        context.stage = "failed";
        context.error = { code: "E500_INTERNAL_ERROR", message: "\u65E0\u6CD5\u89E3\u6790\u76EE\u6807\u7B14\u8BB0\u7684 frontmatter" };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      context.nodeId = extracted.frontmatter.cruid;
      context.type = extracted.frontmatter.type;
      const snapshotResult = await this.deps.undoManager.createSnapshot(
        context.filePath,
        content,
        context.pipelineId,
        context.nodeId
      );
      if (!snapshotResult.ok) {
        context.stage = "failed";
        context.error = { code: snapshotResult.error.code, message: snapshotResult.error.message };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      context.snapshotId = snapshotResult.value;
      this.logger.info("AmendOrchestrator", "\u4FEE\u8BA2\u5FEB\u7167\u5DF2\u521B\u5EFA", {
        pipelineId: context.pipelineId,
        snapshotId: context.snapshotId
      });
      context.stage = "writing";
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "stage_changed",
        pipelineId: context.pipelineId,
        stage: "writing",
        context,
        timestamp: context.updatedAt
      });
      const settings = this.getSettings();
      let taskId;
      try {
        taskId = this.deps.taskQueue.enqueue(
          TaskFactory.create({
            nodeId: context.nodeId,
            taskType: "amend",
            maxAttempts: settings.maxRetryAttempts,
            providerRef: this.getProviderIdForTask("amend"),
            payload: {
              pipelineId: context.pipelineId,
              currentContent: content,
              instruction,
              conceptType: context.type
            }
          })
        );
      } catch (error) {
        context.stage = "failed";
        if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
          const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
          context.error = { code: "E320_TASK_CONFLICT", message: msg };
        } else {
          context.error = { code: "E500_INTERNAL_ERROR", message: "\u521B\u5EFA\u4FEE\u8BA2\u4EFB\u52A1\u5931\u8D25" };
        }
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      this.taskToPipeline.set(taskId, context.pipelineId);
    } catch (error) {
      this.logger.error("AmendOrchestrator", "\u4FEE\u8BA2\u7BA1\u7EBF\u6267\u884C\u5931\u8D25", error, {
        pipelineId: context.pipelineId
      });
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: String(error) };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
    }
  }
  /**
   * 确认修订写入
   *
   * 流程：组合内容 → 冲突检测 → 写入 → 重算 Embedding → 去重 → 可选 Verify
   */
  async confirmAmendWrite(context) {
    const composed = await this.composeWriteContent(context);
    if (!composed.ok) {
      context.stage = "failed";
      context.error = { code: composed.error.code, message: composed.error.message };
      return composed;
    }
    const { targetPath, previousContent, newContent } = composed.value;
    context.filePath = targetPath;
    const currentContent = await this.deps.noteRepository.readByPathIfExists(targetPath);
    if (currentContent !== null && currentContent !== previousContent) {
      const message = `\u68C0\u6D4B\u5230\u6587\u4EF6\u5728\u786E\u8BA4\u5199\u5165\u524D\u5DF2\u88AB\u4FEE\u6539\uFF1A${targetPath}
\u8BF7\u91CD\u65B0\u751F\u6210\u9884\u89C8\uFF08Diff\uFF09\u540E\u518D\u786E\u8BA4\u5199\u5165\uFF0C\u4EE5\u907F\u514D\u8986\u76D6\u6539\u52A8\u3002`;
      context.stage = "failed";
      context.error = { code: "E320_TASK_CONFLICT", message };
      return err("E320_TASK_CONFLICT", message, { targetPath });
    }
    if (!context.snapshotId) {
      const snapshotResult = await this.deps.undoManager.createSnapshot(
        targetPath,
        previousContent,
        context.pipelineId,
        context.nodeId
      );
      if (snapshotResult.ok) {
        context.snapshotId = snapshotResult.value;
      }
    }
    await this.deps.noteRepository.writeAtomic(targetPath, newContent);
    context.stage = "indexing";
    context.updatedAt = formatCRTimestamp();
    await this.refreshEmbeddingAndDuplicates(context, newContent);
    await this.maybeStartAutoVerifyOrComplete(context);
    return ok(void 0);
  }
  /**
   * 组合写入内容（Amend 管线专用）
   */
  async composeWriteContent(context) {
    if (!context.filePath) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6587\u4EF6\u8DEF\u5F84");
    }
    if (context.previousContent === void 0 || context.newContent === void 0) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u9884\u89C8\u5185\u5BB9");
    }
    await this.deps.noteRepository.ensureDirForPath(context.filePath);
    const normalized = extractFrontmatter(context.newContent);
    if (!normalized) {
      return err("E500_INTERNAL_ERROR", "\u65E0\u6CD5\u89E3\u6790\u751F\u6210\u7684 frontmatter");
    }
    const normalizedFrontmatter = {
      ...normalized.frontmatter,
      parents: normalized.frontmatter.parents ?? [],
      updated: formatCRTimestamp()
    };
    const normalizedContent = generateMarkdownContent(normalizedFrontmatter, normalized.body);
    return ok({
      targetPath: context.filePath,
      previousContent: context.previousContent,
      newContent: normalizedContent
    });
  }
  /**
   * 重算 Embedding 并触发去重检测
   */
  async refreshEmbeddingAndDuplicates(context, newContent) {
    const extracted = extractFrontmatter(newContent);
    const embeddingText = extracted ? this.buildEmbeddingTextFromFrontmatter(extracted.frontmatter) : newContent;
    const settings = this.getSettings();
    const taskConfig = settings.taskModels["index"];
    const providerId = taskConfig?.providerId || this.getProviderIdForTask("index");
    const embeddingModel = this.deps.vectorIndex.getEmbeddingModel();
    const embeddingDimension = this.deps.vectorIndex.getEmbeddingDimension();
    const embedResult = await this.deps.providerManager.embed({
      providerId,
      model: embeddingModel,
      input: embeddingText,
      dimensions: embeddingDimension
    });
    if (!embedResult.ok) {
      this.logger.warn("AmendOrchestrator", "Embedding \u91CD\u7B97\u5931\u8D25\uFF0C\u5DF2\u79FB\u9664\u65E7\u5411\u91CF\u907F\u514D\u9648\u65E7\u7ED3\u679C", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: embedResult.error
      });
      const deleteResult = await this.deps.vectorIndex.delete(context.nodeId);
      if (!deleteResult.ok && deleteResult.error.code !== "E311_NOT_FOUND") {
        this.logger.warn("AmendOrchestrator", "\u79FB\u9664\u65E7\u5411\u91CF\u5931\u8D25", {
          pipelineId: context.pipelineId,
          nodeId: context.nodeId,
          error: deleteResult.error
        });
      }
      const clearResult2 = await this.deps.duplicateManager.clearPendingPairsByNodeId(context.nodeId);
      if (!clearResult2.ok) {
        this.logger.warn("AmendOrchestrator", "\u6E05\u7406\u65E7\u91CD\u590D\u5BF9\u5931\u8D25", {
          pipelineId: context.pipelineId,
          nodeId: context.nodeId,
          error: clearResult2.error
        });
      }
      context.embedding = void 0;
      return;
    }
    context.embedding = embedResult.value.embedding;
    context.updatedAt = formatCRTimestamp();
    const clearResult = await this.deps.duplicateManager.clearPendingPairsByNodeId(context.nodeId);
    if (!clearResult.ok) {
      this.logger.warn("AmendOrchestrator", "\u6E05\u7406\u65E7\u91CD\u590D\u5BF9\u5931\u8D25", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: clearResult.error
      });
    }
    const upsertResult = await this.deps.vectorIndex.upsert({
      uid: context.nodeId,
      type: context.type,
      embedding: context.embedding,
      updated: context.updatedAt
    });
    if (!upsertResult.ok) {
      this.logger.warn("AmendOrchestrator", "\u66F4\u65B0\u5411\u91CF\u7D22\u5F15\u5931\u8D25", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: upsertResult.error
      });
    }
    const detectResult = await this.deps.duplicateManager.detect(context.nodeId, context.type, context.embedding);
    if (!detectResult.ok) {
      this.logger.warn("AmendOrchestrator", "\u53BB\u91CD\u68C0\u6D4B\u5931\u8D25", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: detectResult.error
      });
    }
  }
  /**
   * 根据设置决定是否自动 Verify 或直接完成
   */
  async maybeStartAutoVerifyOrComplete(context) {
    const settings = this.getSettings();
    if (!settings.enableAutoVerify) {
      this.completePipeline(context);
      return;
    }
    const prereqResult = this.validatePrerequisites("verify", context.type);
    if (!prereqResult.ok) {
      this.logger.warn("AmendOrchestrator", "Verify \u524D\u7F6E\u6821\u9A8C\u5931\u8D25\uFF0C\u8DF3\u8FC7\u81EA\u52A8\u6821\u9A8C\u5E76\u7ED3\u675F\u7BA1\u7EBF", {
        pipelineId: context.pipelineId,
        error: prereqResult.error
      });
      this.completePipeline(context);
      return;
    }
    const startResult = await this.startVerifyTask(context);
    if (!startResult.ok) {
      this.logger.warn("AmendOrchestrator", "\u542F\u52A8 Verify \u5931\u8D25\uFF0C\u8DF3\u8FC7\u81EA\u52A8\u6821\u9A8C\u5E76\u7ED3\u675F\u7BA1\u7EBF", {
        pipelineId: context.pipelineId,
        error: startResult.error
      });
      this.completePipeline(context);
    }
  }
  /**
   * 启动 Verify 任务
   */
  async startVerifyTask(context) {
    const filePath = context.filePath;
    if (!filePath) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6587\u4EF6\u8DEF\u5F84\uFF0C\u65E0\u6CD5\u6267\u884C Verify");
    }
    const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
    if (currentContent === null) {
      return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`, { filePath });
    }
    context.stage = "verifying";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "stage_changed",
      pipelineId: context.pipelineId,
      stage: "verifying",
      context,
      timestamp: context.updatedAt
    });
    this.logger.info("AmendOrchestrator", `\u542F\u52A8 Verify \u4EFB\u52A1: ${context.pipelineId}`, {
      filePath
    });
    const settings = this.getSettings();
    try {
      const taskId = this.deps.taskQueue.enqueue(
        TaskFactory.create({
          nodeId: context.nodeId,
          taskType: "verify",
          maxAttempts: settings.maxRetryAttempts,
          providerRef: this.getProviderIdForTask("verify"),
          payload: {
            pipelineId: context.pipelineId,
            filePath,
            currentContent,
            conceptType: context.type,
            standardizedData: context.standardizedData
          }
        })
      );
      this.taskToPipeline.set(taskId, context.pipelineId);
      return ok(void 0);
    } catch (error) {
      if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
        const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
        return err("E320_TASK_CONFLICT", msg);
      }
      return toErr(error, "E500_INTERNAL_ERROR", "Verify \u4EFB\u52A1\u521B\u5EFA\u5931\u8D25");
    }
  }
  /**
   * 完成管线
   */
  completePipeline(context) {
    context.stage = "completed";
    context.updatedAt = formatCRTimestamp();
    void this.savePipelineState();
    this.publishEvent({
      type: "pipeline_completed",
      pipelineId: context.pipelineId,
      stage: "completed",
      context,
      timestamp: context.updatedAt
    });
  }
  // ========================================================================
  // 私有方法 — 辅助工具
  // ========================================================================
  /**
   * 持久化管线状态到文件
   *
   * 收集当前 Orchestrator 的活跃管线状态并通过 PipelineStateStore 保存。
   * 仅保存处于 review_changes 阶段的管线（需求 33.1）。
   * 管线完成或取消后，因不再处于 review_changes，自动从文件中移除（需求 33.4）。
   */
  async savePipelineState() {
    try {
      await this.deps.pipelineStateStore.persistFromOrchestrators([this]);
    } catch (error) {
      this.logger.warn("AmendOrchestrator", "\u6301\u4E45\u5316\u7BA1\u7EBF\u72B6\u6001\u5931\u8D25", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * 获取设置
   */
  getSettings() {
    return this.deps.settingsStore.getSettings();
  }
  /**
   * 前置校验：检查 Provider 和模板是否可用
   */
  validatePrerequisites(taskType, conceptType) {
    const settings = this.getSettings();
    const providerId = this.getProviderIdForTask(taskType);
    return validatePrerequisites(
      settings,
      taskType,
      providerId,
      this.deps.promptManager,
      this.logger,
      "AmendOrchestrator",
      conceptType
    );
  }
  /**
   * 获取任务对应的 Provider ID
   */
  getProviderIdForTask(taskType) {
    return resolveProviderIdForTask(this.getSettings(), taskType, this.logger, "AmendOrchestrator");
  }
  /**
   * 渲染内容为 Markdown
   */
  renderContentToMarkdown(context, standardName) {
    const settings = this.getSettings();
    const language = settings.language || "zh";
    const title = language === "en" ? context.standardizedData?.standardNames[context.type].english || standardName : standardName;
    return this.deps.contentRenderer.renderNoteMarkdown({
      title,
      type: context.type,
      content: context.generatedContent,
      language
    });
  }
  /**
   * 从 Frontmatter 构建嵌入文本
   */
  buildEmbeddingTextFromFrontmatter(frontmatter) {
    const parts = [];
    if (frontmatter.name) {
      parts.push(frontmatter.name);
    }
    if (frontmatter.aliases && frontmatter.aliases.length > 0) {
      parts.push(...frontmatter.aliases);
    }
    if (frontmatter.definition) {
      parts.push(frontmatter.definition);
    }
    parts.push(`\u7C7B\u578B: ${frontmatter.type}`);
    if (frontmatter.tags && frontmatter.tags.length > 0) {
      parts.push(`\u6807\u7B7E: ${frontmatter.tags.join(", ")}`);
    }
    return parts.join("\n");
  }
  /**
   * 追加验证报告到笔记末尾
   * 委托给 orchestrator-utils 共享的 buildVerificationReportMarkdown（DRY）
   */
  async appendVerificationReportToNote(filePath, result) {
    try {
      const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
      if (currentContent === null) {
        this.logger.warn("AmendOrchestrator", "\u6587\u4EF6\u4E0D\u5B58\u5728\uFF0C\u65E0\u6CD5\u8FFD\u52A0\u62A5\u544A", { filePath });
        return;
      }
      const report = buildVerificationReportMarkdown(result);
      const separator = currentContent.endsWith("\n") ? "\n" : "\n\n";
      const newContent = `${currentContent}${separator}${report}`;
      await this.deps.noteRepository.writeAtomic(filePath, newContent);
      this.logger.info("AmendOrchestrator", `\u9A8C\u8BC1\u62A5\u544A\u5DF2\u8FFD\u52A0: ${filePath}`);
    } catch (error) {
      this.logger.error("AmendOrchestrator", "\u8FFD\u52A0\u9A8C\u8BC1\u62A5\u544A\u5931\u8D25", error, { filePath });
    }
  }
  /**
   * 生成管线 ID
   */
  generatePipelineId() {
    return `pipeline-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * 发布事件
   */
  publishEvent(event2) {
    for (const listener of this.listeners) {
      try {
        listener(event2);
      } catch (error) {
        this.logger.error("AmendOrchestrator", "\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error);
      }
    }
  }
};

// src/core/merge-orchestrator.ts
var MergeOrchestrator = class {
  deps;
  logger;
  /** 活跃管线上下文 */
  pipelines = /* @__PURE__ */ new Map();
  /** 事件监听器 */
  listeners = [];
  /** taskId → pipelineId 映射 */
  taskToPipeline = /* @__PURE__ */ new Map();
  /** 队列事件取消订阅 */
  unsubscribeQueue;
  constructor(deps) {
    this.deps = deps;
    this.logger = deps.logger;
    this.subscribeToTaskQueue();
    this.logger.debug("MergeOrchestrator", "\u5408\u5E76\u7BA1\u7EBF\u7F16\u6392\u5668\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // ========================================================================
  // 公开方法
  // ========================================================================
  /**
   * 启动合并管线
   *
   * 流程：确定主/被合并笔记 → 读取内容 → 创建双快照 → 入队 Merge 任务
   *
   * @param pair 重复对
   * @param keepNodeId 保留的笔记 nodeId
   * @param finalFileName 合并后的文件名（不含扩展名）
   * @returns 管线 ID
   */
  startMergePipeline(pair, keepNodeId, finalFileName) {
    const isKeepA = keepNodeId === pair.nodeIdA;
    const keepId = isKeepA ? pair.nodeIdA : pair.nodeIdB;
    const deleteId = isKeepA ? pair.nodeIdB : pair.nodeIdA;
    const nameA = this.deps.cruidCache?.getName(pair.nodeIdA) || pair.nodeIdA;
    const nameB = this.deps.cruidCache?.getName(pair.nodeIdB) || pair.nodeIdB;
    const keepPath = this.deps.cruidCache?.getPath(keepId);
    const deletePath = this.deps.cruidCache?.getPath(deleteId);
    if (!keepPath || !deletePath) {
      return err("E301_FILE_NOT_FOUND", "\u65E0\u6CD5\u5B9A\u4F4D\u5408\u5E76\u7B14\u8BB0\u6587\u4EF6\uFF08\u53EF\u80FD\u5DF2\u88AB\u79FB\u52A8\u6216\u5220\u9664\uFF09", {
        keepNodeId: keepId,
        deleteNodeId: deleteId,
        keepPath: keepPath || null,
        deletePath: deletePath || null
      });
    }
    const keepNote = { nodeId: keepId, name: this.deps.cruidCache?.getName(keepId) || keepId, path: keepPath };
    const deleteNote = { nodeId: deleteId, name: this.deps.cruidCache?.getName(deleteId) || deleteId, path: deletePath };
    const prereqResult = this.validatePrerequisites("merge", pair.type);
    if (!prereqResult.ok) {
      return prereqResult;
    }
    const pipelineId = this.generatePipelineId();
    const now2 = formatCRTimestamp();
    const context = {
      kind: "merge",
      pipelineId,
      nodeId: keepNote.nodeId,
      type: pair.type,
      stage: "idle",
      userInput: `\u5408\u5E76 ${nameA} \u548C ${nameB}`,
      mergePairId: pair.id,
      deleteFilePath: deleteNote.path,
      deleteNoteName: deleteNote.name,
      deleteNodeId: deleteNote.nodeId,
      createdAt: now2,
      updatedAt: now2
    };
    this.pipelines.set(pipelineId, context);
    this.logger.info("MergeOrchestrator", `\u542F\u52A8\u5408\u5E76\u7BA1\u7EBF: ${pipelineId}`, {
      keepNodeId,
      deleteNodeId: deleteNote.nodeId,
      pairId: pair.id,
      finalFileName
    });
    void this.executeMergePipeline(context, pair, keepNote, deleteNote, finalFileName);
    return ok(pipelineId);
  }
  /**
   * 确认写入（用户在 Diff 预览后确认）
   *
   * 流程：冲突检测 → 写入文件 → Parents 引用重写 → 删除被合并笔记 → 清理索引 → 重算 Embedding → 去重
   *
   * @param pipelineId 管线 ID
   */
  async confirmWrite(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (context.stage !== "review_changes") {
      return err("E310_INVALID_STATE", `\u7BA1\u7EBF\u72B6\u6001\u4E0D\u6B63\u786E: ${context.stage}\uFF0C\u671F\u671B: review_changes`);
    }
    try {
      context.stage = "writing";
      context.updatedAt = formatCRTimestamp();
      this.logger.info("MergeOrchestrator", `\u7528\u6237\u786E\u8BA4\u5199\u5165: ${pipelineId}`);
      return await this.confirmMergeWrite(context);
    } catch (error) {
      this.logger.error("MergeOrchestrator", "\u786E\u8BA4\u5199\u5165\u5931\u8D25", error);
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: String(error) };
      return err("E500_INTERNAL_ERROR", "\u786E\u8BA4\u5199\u5165\u5931\u8D25", error);
    }
  }
  /**
   * 构建写入预览（供 DiffView 使用）
   */
  async buildWritePreview(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (!["review_changes", "saving"].includes(context.stage)) {
      return err("E310_INVALID_STATE", `\u5F53\u524D\u9636\u6BB5\u4E0D\u652F\u6301\u9884\u89C8: ${context.stage}`);
    }
    return this.composeWriteContent(context);
  }
  /**
   * 取消管线
   */
  cancelPipeline(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    for (const [taskId, pid] of this.taskToPipeline.entries()) {
      if (pid === pipelineId) {
        try {
          this.deps.taskQueue.cancel(taskId);
        } catch (error) {
          this.logger.warn("MergeOrchestrator", `\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25: ${taskId}`, {
            pipelineId,
            error: error instanceof Error ? error.message : String(error)
          });
        }
        this.taskToPipeline.delete(taskId);
      }
    }
    if (context.mergePairId) {
      void this.deps.duplicateManager.abortMerge(context.mergePairId);
    }
    context.stage = "failed";
    context.error = { code: "E310_INVALID_STATE", message: "\u7528\u6237\u53D6\u6D88" };
    context.updatedAt = formatCRTimestamp();
    void this.savePipelineState();
    this.logger.info("MergeOrchestrator", `\u7BA1\u7EBF\u5DF2\u53D6\u6D88: ${pipelineId}`);
    return ok(void 0);
  }
  /**
   * 获取管线上下文
   */
  getContext(pipelineId) {
    return this.pipelines.get(pipelineId);
  }
  /**
   * 获取所有活跃管线
   */
  getActivePipelines() {
    return Array.from(this.pipelines.values()).filter(
      (ctx) => ctx.stage !== "completed" && ctx.stage !== "failed"
    );
  }
  /**
   * 订阅管线事件
   */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /**
   * 恢复持久化的管线状态
   */
  restorePipelines(pipelines, taskToPipeline) {
    for (const [id, ctx] of pipelines) {
      if (ctx.kind === "merge") {
        this.pipelines.set(id, ctx);
      }
    }
    for (const [taskId, pipelineId] of taskToPipeline) {
      if (this.pipelines.has(pipelineId)) {
        this.taskToPipeline.set(taskId, pipelineId);
      }
    }
  }
  /**
   * 获取活跃管线和任务映射（用于持久化）
   */
  getActiveState() {
    const activePipelines = /* @__PURE__ */ new Map();
    for (const [id, ctx] of this.pipelines) {
      if (ctx.stage !== "completed" && ctx.stage !== "failed") {
        activePipelines.set(id, ctx);
      }
    }
    const activeTaskMap = /* @__PURE__ */ new Map();
    for (const [taskId, pipelineId] of this.taskToPipeline) {
      if (activePipelines.has(pipelineId)) {
        activeTaskMap.set(taskId, pipelineId);
      }
    }
    return { pipelines: activePipelines, taskToPipeline: activeTaskMap };
  }
  /**
   * 释放资源
   */
  dispose() {
    if (this.unsubscribeQueue) {
      this.unsubscribeQueue();
      this.unsubscribeQueue = void 0;
    }
  }
  // ========================================================================
  // 私有方法 — 任务队列事件处理
  // ========================================================================
  /**
   * 订阅任务队列事件
   */
  subscribeToTaskQueue() {
    this.unsubscribeQueue?.();
    this.unsubscribeQueue = this.deps.taskQueue.subscribe((event2) => {
      if (event2.type === "task-completed" && event2.taskId) {
        this.handleTaskCompleted(event2.taskId);
      } else if (event2.type === "task-failed" && event2.taskId) {
        this.handleTaskFailed(event2.taskId);
      }
    });
  }
  /**
   * 处理任务完成事件
   */
  async handleTaskCompleted(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    if (!task) return;
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    this.logger.debug("MergeOrchestrator", `\u4EFB\u52A1\u5B8C\u6210: ${taskId}`, {
      pipelineId,
      taskType: task.taskType
    });
    switch (task.taskType) {
      case "merge":
        await this.handleMergeCompleted(context, task);
        break;
      case "verify":
        await this.handleVerifyCompleted(context, task);
        break;
    }
  }
  /**
   * 处理任务失败事件
   */
  handleTaskFailed(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task?.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    context.stage = "failed";
    context.error = {
      code: task?.errors?.[0]?.code || "E500_INTERNAL_ERROR",
      message: task?.errors?.[0]?.message || "\u4EFB\u52A1\u6267\u884C\u5931\u8D25"
    };
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "pipeline_failed",
      pipelineId,
      stage: "failed",
      context,
      timestamp: context.updatedAt
    });
    this.logger.error("MergeOrchestrator", `\u7BA1\u7EBF\u5931\u8D25: ${pipelineId}`, void 0, {
      taskId,
      error: context.error
    });
  }
  // ========================================================================
  // 私有方法 — 各阶段任务完成处理
  // ========================================================================
  /**
   * Merge 任务完成：构建合并内容并进入 Diff 确认阶段
   */
  async handleMergeCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      context.stage = "failed";
      context.error = { code: "E310_INVALID_STATE", message: "Merge \u7ED3\u679C\u7F3A\u5931" };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    if (!context.previousContent) {
      context.stage = "failed";
      context.error = { code: "E310_INVALID_STATE", message: "\u7F3A\u5C11\u5408\u5E76\u524D\u5185\u5BB9" };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    context.generatedContent = result.content || result;
    const buildResult = this.buildMergedContent(
      result,
      context.previousContent,
      context.type,
      context.deleteNoteName || ""
    );
    if (!buildResult.ok) {
      context.stage = "failed";
      context.error = { code: buildResult.error.code, message: buildResult.error.message };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    context.newContent = buildResult.value;
    context.stage = "review_changes";
    context.updatedAt = formatCRTimestamp();
    void this.savePipelineState();
    this.publishEvent({
      type: "confirmation_required",
      pipelineId: context.pipelineId,
      stage: "review_changes",
      context,
      timestamp: context.updatedAt
    });
  }
  /**
   * Verify 任务完成：追加报告并完成管线
   */
  async handleVerifyCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      this.logger.warn("MergeOrchestrator", "Verify \u7ED3\u679C\u7F3A\u5931\uFF0C\u8DF3\u8FC7\u62A5\u544A\u8FFD\u52A0", {
        pipelineId: context.pipelineId
      });
      this.completePipeline(context);
      return;
    }
    context.verificationResult = result;
    if (context.filePath) {
      await this.appendVerificationReportToNote(context.filePath, result);
    }
    this.completePipeline(context);
  }
  // ========================================================================
  // 私有方法 — 管线核心逻辑
  // ========================================================================
  /**
   * 执行合并管线（异步）
   *
   * 流程：读取两篇笔记 → 创建双快照（需求 31.1） → 入队 Merge 任务
   */
  async executeMergePipeline(context, pair, keepNote, deleteNote, finalFileName) {
    try {
      const keepFile = this.deps.noteRepository.getFileByPath(keepNote.path);
      const deleteFile = this.deps.noteRepository.getFileByPath(deleteNote.path);
      if (!keepFile) {
        context.stage = "failed";
        context.error = { code: "E301_FILE_NOT_FOUND", message: `\u4E3B\u7B14\u8BB0\u4E0D\u5B58\u5728: ${keepNote.path}` };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      if (!deleteFile) {
        context.stage = "failed";
        context.error = { code: "E301_FILE_NOT_FOUND", message: `\u88AB\u5408\u5E76\u7B14\u8BB0\u4E0D\u5B58\u5728: ${deleteNote.path}` };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      const keepContent = await this.deps.noteRepository.readByPath(keepNote.path);
      const deleteContent = await this.deps.noteRepository.readByPath(deleteNote.path);
      context.previousContent = keepContent;
      context.deleteContent = deleteContent;
      context.filePath = keepNote.path;
      context.stage = "saving";
      context.updatedAt = formatCRTimestamp();
      const keepSnapshotResult = await this.deps.undoManager.createSnapshot(
        keepNote.path,
        keepContent,
        context.pipelineId,
        keepNote.nodeId
      );
      if (!keepSnapshotResult.ok) {
        context.stage = "failed";
        context.error = { code: keepSnapshotResult.error.code, message: keepSnapshotResult.error.message };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      context.snapshotId = keepSnapshotResult.value;
      const deleteSnapshotResult = await this.deps.undoManager.createSnapshot(
        deleteNote.path,
        deleteContent,
        `merge-delete-${context.pipelineId}`,
        deleteNote.nodeId
      );
      if (!deleteSnapshotResult.ok) {
        context.stage = "failed";
        context.error = { code: deleteSnapshotResult.error.code, message: deleteSnapshotResult.error.message };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      this.logger.info("MergeOrchestrator", "\u5408\u5E76\u5FEB\u7167\u5DF2\u521B\u5EFA", {
        pipelineId: context.pipelineId,
        keepSnapshotId: context.snapshotId
      });
      context.stage = "writing";
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "stage_changed",
        pipelineId: context.pipelineId,
        stage: "writing",
        context,
        timestamp: context.updatedAt
      });
      const settings = this.getSettings();
      let taskId;
      try {
        taskId = this.deps.taskQueue.enqueue(
          TaskFactory.create({
            nodeId: context.nodeId,
            taskType: "merge",
            maxAttempts: settings.maxRetryAttempts,
            providerRef: this.getProviderIdForTask("merge"),
            payload: {
              pipelineId: context.pipelineId,
              keepName: keepNote.name,
              deleteName: deleteNote.name,
              keepContent,
              deleteContent,
              conceptType: pair.type,
              finalFileName
            }
          })
        );
      } catch (error) {
        context.stage = "failed";
        if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
          const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
          context.error = { code: "E320_TASK_CONFLICT", message: msg };
        } else {
          context.error = { code: "E500_INTERNAL_ERROR", message: "\u521B\u5EFA\u5408\u5E76\u4EFB\u52A1\u5931\u8D25" };
        }
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      this.taskToPipeline.set(taskId, context.pipelineId);
    } catch (error) {
      this.logger.error("MergeOrchestrator", "\u5408\u5E76\u7BA1\u7EBF\u6267\u884C\u5931\u8D25", error, {
        pipelineId: context.pipelineId
      });
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: String(error) };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
    }
  }
  /**
   * 确认合并写入
   *
   * 流程：组合内容 → 冲突检测 → 写入 → Parents 引用重写 → 删除被合并笔记 → 清理索引 → 重算 Embedding → 去重 → 可选 Verify
   */
  async confirmMergeWrite(context) {
    const composed = await this.composeWriteContent(context);
    if (!composed.ok) {
      context.stage = "failed";
      context.error = { code: composed.error.code, message: composed.error.message };
      return composed;
    }
    const { targetPath, previousContent, newContent } = composed.value;
    context.filePath = targetPath;
    const currentKeep = await this.deps.noteRepository.readByPathIfExists(targetPath);
    if (currentKeep !== null && currentKeep !== previousContent) {
      const message = `\u68C0\u6D4B\u5230\u4E3B\u7B14\u8BB0\u5728\u786E\u8BA4\u5199\u5165\u524D\u5DF2\u88AB\u4FEE\u6539\uFF1A${targetPath}
\u8BF7\u91CD\u65B0\u751F\u6210\u9884\u89C8\uFF08Diff\uFF09\u540E\u518D\u786E\u8BA4\u5199\u5165\uFF0C\u4EE5\u907F\u514D\u8986\u76D6\u6539\u52A8\u3002`;
      context.stage = "failed";
      context.error = { code: "E320_TASK_CONFLICT", message };
      return err("E320_TASK_CONFLICT", message, { targetPath });
    }
    if (context.deleteFilePath && context.deleteContent) {
      const currentDelete = await this.deps.noteRepository.readByPathIfExists(context.deleteFilePath);
      if (currentDelete !== null && currentDelete !== context.deleteContent) {
        const message = `\u68C0\u6D4B\u5230\u88AB\u5408\u5E76\u7B14\u8BB0\u5728\u786E\u8BA4\u5199\u5165\u524D\u5DF2\u88AB\u4FEE\u6539\uFF1A${context.deleteFilePath}
\u8BF7\u91CD\u65B0\u751F\u6210\u9884\u89C8\uFF08Diff\uFF09\u540E\u518D\u786E\u8BA4\u5199\u5165\uFF0C\u4EE5\u907F\u514D\u8BEF\u5220\u6539\u52A8\u3002`;
        context.stage = "failed";
        context.error = { code: "E320_TASK_CONFLICT", message };
        return err("E320_TASK_CONFLICT", message, { deleteFilePath: context.deleteFilePath });
      }
    }
    if (!context.snapshotId) {
      const snapshotResult = await this.deps.undoManager.createSnapshot(
        targetPath,
        previousContent,
        context.pipelineId,
        context.nodeId
      );
      if (snapshotResult.ok) {
        context.snapshotId = snapshotResult.value;
      }
      if (context.deleteFilePath && context.deleteContent) {
        await this.deps.undoManager.createSnapshot(
          context.deleteFilePath,
          context.deleteContent,
          `merge-delete-${context.mergePairId ?? context.pipelineId}`,
          context.deleteNodeId
        );
      }
    }
    await this.deps.noteRepository.writeAtomic(targetPath, newContent);
    const keepTitle = this.getNoteTitleFromPath(targetPath);
    const deleteTitle = context.deleteFilePath ? this.getNoteTitleFromPath(context.deleteFilePath) : context.deleteNoteName?.trim() || "";
    if (deleteTitle && keepTitle && deleteTitle !== keepTitle) {
      const updateParentsResult = await this.rewriteParentsAcrossVault({
        pipelineId: context.pipelineId,
        fromTitle: deleteTitle,
        toTitle: keepTitle,
        skipPaths: [targetPath, context.deleteFilePath]
      });
      if (!updateParentsResult.ok) {
        if (context.mergePairId) {
          await this.deps.duplicateManager.abortMerge(context.mergePairId);
        }
        context.stage = "failed";
        context.error = { code: updateParentsResult.error.code, message: updateParentsResult.error.message };
        return updateParentsResult;
      }
    }
    if (context.deleteFilePath) {
      await this.deps.noteRepository.deleteByPathIfExists(context.deleteFilePath);
    }
    if (context.deleteNodeId) {
      await this.deps.vectorIndex.delete(context.deleteNodeId);
    }
    context.stage = "indexing";
    context.updatedAt = formatCRTimestamp();
    await this.refreshEmbeddingAndDuplicates(context, newContent);
    if (context.mergePairId) {
      await this.deps.duplicateManager.completeMerge(context.mergePairId, context.nodeId);
    }
    await this.maybeStartAutoVerifyOrComplete(context);
    return ok(void 0);
  }
  /**
   * 组合写入内容（Merge 管线专用）
   */
  async composeWriteContent(context) {
    if (!context.filePath) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6587\u4EF6\u8DEF\u5F84");
    }
    if (context.previousContent === void 0 || context.newContent === void 0) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u9884\u89C8\u5185\u5BB9");
    }
    await this.deps.noteRepository.ensureDirForPath(context.filePath);
    const normalized = extractFrontmatter(context.newContent);
    if (!normalized) {
      return err("E500_INTERNAL_ERROR", "\u65E0\u6CD5\u89E3\u6790\u751F\u6210\u7684 frontmatter");
    }
    const normalizedFrontmatter = {
      ...normalized.frontmatter,
      parents: normalized.frontmatter.parents ?? [],
      updated: formatCRTimestamp()
    };
    const normalizedContent = generateMarkdownContent(normalizedFrontmatter, normalized.body);
    return ok({
      targetPath: context.filePath,
      previousContent: context.previousContent,
      newContent: normalizedContent
    });
  }
  /**
   * 构建合并后的完整 Markdown 内容
   */
  buildMergedContent(mergeResult, previousContent, type, deleteNoteName) {
    const extracted = extractFrontmatter(previousContent);
    if (!extracted) {
      return err("E500_INTERNAL_ERROR", "\u65E0\u6CD5\u89E3\u6790\u539F\u59CB\u7B14\u8BB0\u7684 frontmatter");
    }
    const frontmatter = extracted.frontmatter;
    const mergedName = mergeResult.merged_name || {};
    const content = mergeResult.content;
    if (!content) {
      return err("E211_MODEL_SCHEMA_VIOLATION", "\u5408\u5E76\u7ED3\u679C\u7F3A\u5C11\u5185\u5BB9\u4FE1\u606F");
    }
    const updatedFrontmatter = {
      ...frontmatter,
      updated: formatCRTimestamp()
    };
    const nextDefinition = typeof content.definition === "string" ? content.definition.trim() : void 0;
    if (nextDefinition) {
      updatedFrontmatter.definition = nextDefinition;
    }
    if (deleteNoteName && deleteNoteName.trim()) {
      const nextAliases = new Set(updatedFrontmatter.aliases ?? []);
      nextAliases.add(deleteNoteName.trim());
      updatedFrontmatter.aliases = Array.from(nextAliases);
    }
    const body = this.buildMergeBody(mergedName, content, type, mergeResult);
    return ok(generateMarkdownContent(updatedFrontmatter, body));
  }
  /**
   * 构建合并正文 Markdown
   */
  buildMergeBody(mergedName, content, type, mergeResult) {
    const sections = [];
    const settings = this.getSettings();
    const language = settings.language || "zh";
    const cn = mergedName.chinese || "\u5408\u5E76\u540E\u7684\u6982\u5FF5";
    const en = mergedName.english || "";
    if (language === "zh") {
      sections.push(`# ${cn}`);
    } else {
      sections.push(`# ${en || cn}`);
    }
    sections.push("");
    const rationale = mergeResult.merge_rationale;
    if (rationale) {
      sections.push("## \u5408\u5E76\u8BF4\u660E");
      sections.push(rationale);
      sections.push("");
    }
    const structured = this.deps.contentRenderer.renderStructuredContentMarkdown({
      type,
      content,
      language
    });
    if (structured) {
      sections.push(structured);
      sections.push("");
    }
    const preservedA = mergeResult.preserved_from_a;
    const preservedB = mergeResult.preserved_from_b;
    if (preservedA && preservedA.length > 0 || preservedB && preservedB.length > 0) {
      sections.push("## \u6574\u5408\u7684\u89C1\u89E3");
      if (preservedA && preservedA.length > 0) {
        sections.push("### \u6765\u81EA\u6982\u5FF5 A");
        preservedA.forEach((insight) => sections.push(`- ${insight}`));
      }
      if (preservedB && preservedB.length > 0) {
        sections.push("### \u6765\u81EA\u6982\u5FF5 B");
        preservedB.forEach((insight) => sections.push(`- ${insight}`));
      }
      sections.push("");
    }
    return sections.join("\n");
  }
  /**
   * 重算 Embedding 并触发去重检测
   */
  async refreshEmbeddingAndDuplicates(context, newContent) {
    const extracted = extractFrontmatter(newContent);
    const embeddingText = extracted ? this.buildEmbeddingTextFromFrontmatter(extracted.frontmatter) : newContent;
    const settings = this.getSettings();
    const taskConfig = settings.taskModels["index"];
    const providerId = taskConfig?.providerId || this.getProviderIdForTask("index");
    const embeddingModel = this.deps.vectorIndex.getEmbeddingModel();
    const embeddingDimension = this.deps.vectorIndex.getEmbeddingDimension();
    const embedResult = await this.deps.providerManager.embed({
      providerId,
      model: embeddingModel,
      input: embeddingText,
      dimensions: embeddingDimension
    });
    if (!embedResult.ok) {
      this.logger.warn("MergeOrchestrator", "Embedding \u91CD\u7B97\u5931\u8D25\uFF0C\u5DF2\u79FB\u9664\u65E7\u5411\u91CF\u907F\u514D\u9648\u65E7\u7ED3\u679C", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: embedResult.error
      });
      const deleteResult = await this.deps.vectorIndex.delete(context.nodeId);
      if (!deleteResult.ok && deleteResult.error.code !== "E311_NOT_FOUND") {
        this.logger.warn("MergeOrchestrator", "\u79FB\u9664\u65E7\u5411\u91CF\u5931\u8D25", {
          pipelineId: context.pipelineId,
          nodeId: context.nodeId,
          error: deleteResult.error
        });
      }
      const clearResult2 = await this.deps.duplicateManager.clearPendingPairsByNodeId(context.nodeId);
      if (!clearResult2.ok) {
        this.logger.warn("MergeOrchestrator", "\u6E05\u7406\u65E7\u91CD\u590D\u5BF9\u5931\u8D25", {
          pipelineId: context.pipelineId,
          nodeId: context.nodeId,
          error: clearResult2.error
        });
      }
      context.embedding = void 0;
      return;
    }
    context.embedding = embedResult.value.embedding;
    context.updatedAt = formatCRTimestamp();
    const clearResult = await this.deps.duplicateManager.clearPendingPairsByNodeId(context.nodeId);
    if (!clearResult.ok) {
      this.logger.warn("MergeOrchestrator", "\u6E05\u7406\u65E7\u91CD\u590D\u5BF9\u5931\u8D25", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: clearResult.error
      });
    }
    const upsertResult = await this.deps.vectorIndex.upsert({
      uid: context.nodeId,
      type: context.type,
      embedding: context.embedding,
      updated: context.updatedAt
    });
    if (!upsertResult.ok) {
      this.logger.warn("MergeOrchestrator", "\u66F4\u65B0\u5411\u91CF\u7D22\u5F15\u5931\u8D25", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: upsertResult.error
      });
    }
    const detectResult = await this.deps.duplicateManager.detect(context.nodeId, context.type, context.embedding);
    if (!detectResult.ok) {
      this.logger.warn("MergeOrchestrator", "\u53BB\u91CD\u68C0\u6D4B\u5931\u8D25", {
        pipelineId: context.pipelineId,
        nodeId: context.nodeId,
        error: detectResult.error
      });
    }
  }
  /**
   * Parents 引用重写：将 Vault 中所有引用被合并笔记的 parents 链接重写为主笔记
   */
  async rewriteParentsAcrossVault(params) {
    const fromLink = `[[${params.fromTitle}]]`;
    const toLink = `[[${params.toTitle}]]`;
    const skip = new Set(params.skipPaths.filter((p) => typeof p === "string" && p.length > 0));
    const candidates = [];
    const files = this.deps.noteRepository.listMarkdownFiles();
    for (const file of files) {
      if (skip.has(file.path)) {
        continue;
      }
      let content;
      try {
        content = await this.deps.noteRepository.read(file);
      } catch (error) {
        this.logger.warn("MergeOrchestrator", "\u626B\u63CF parents \u5F15\u7528\u65F6\u8BFB\u53D6\u6587\u4EF6\u5931\u8D25", {
          path: file.path,
          error: error instanceof Error ? error.message : String(error)
        });
        continue;
      }
      const extracted = extractFrontmatter(content);
      if (!extracted) {
        continue;
      }
      const parents = extracted.frontmatter.parents ?? [];
      if (!parents.includes(fromLink)) {
        continue;
      }
      const nextParents = [];
      const seen = /* @__PURE__ */ new Set();
      for (const p of parents) {
        const next2 = p === fromLink ? toLink : p;
        if (!next2) continue;
        if (seen.has(next2)) continue;
        seen.add(next2);
        nextParents.push(next2);
      }
      const unchanged = nextParents.length === parents.length && nextParents.every((value, index2) => value === parents[index2]);
      if (unchanged) {
        continue;
      }
      const nextFrontmatter = {
        ...extracted.frontmatter,
        parents: nextParents,
        updated: formatCRTimestamp()
      };
      const nextContent = generateMarkdownContent(nextFrontmatter, extracted.body);
      candidates.push({
        file,
        nodeId: extracted.frontmatter.cruid,
        previousContent: content,
        nextContent
      });
    }
    if (candidates.length === 0) {
      return ok({ updatedCount: 0 });
    }
    for (const item of candidates) {
      const snapshotResult = await this.deps.undoManager.createSnapshot(
        item.file.path,
        item.previousContent,
        `merge-parents-${params.pipelineId}`,
        item.nodeId
      );
      if (!snapshotResult.ok) {
        return err(
          snapshotResult.error.code,
          `\u66F4\u65B0 parents \u5F15\u7528\u524D\u521B\u5EFA\u5FEB\u7167\u5931\u8D25: ${item.file.path}`,
          snapshotResult.error
        );
      }
    }
    let updatedCount = 0;
    for (const item of candidates) {
      try {
        await this.deps.noteRepository.writeAtomic(item.file.path, item.nextContent);
        updatedCount += 1;
      } catch (error) {
        this.logger.error("MergeOrchestrator", "\u66F4\u65B0 parents \u5F15\u7528\u5931\u8D25", error, {
          path: item.file.path,
          pipelineId: params.pipelineId
        });
        return err("E302_PERMISSION_DENIED", `\u66F4\u65B0 parents \u5F15\u7528\u5931\u8D25: ${item.file.path}`, error);
      }
    }
    this.logger.info("MergeOrchestrator", "\u5DF2\u5B8C\u6210 Merge \u7684 parents \u5F15\u7528\u91CD\u5199", {
      pipelineId: params.pipelineId,
      from: fromLink,
      to: toLink,
      updatedCount
    });
    return ok({ updatedCount });
  }
  /**
   * 根据设置决定是否自动 Verify 或直接完成
   */
  async maybeStartAutoVerifyOrComplete(context) {
    const settings = this.getSettings();
    if (!settings.enableAutoVerify) {
      this.completePipeline(context);
      return;
    }
    const prereqResult = this.validatePrerequisites("verify", context.type);
    if (!prereqResult.ok) {
      this.logger.warn("MergeOrchestrator", "Verify \u524D\u7F6E\u6821\u9A8C\u5931\u8D25\uFF0C\u8DF3\u8FC7\u81EA\u52A8\u6821\u9A8C\u5E76\u7ED3\u675F\u7BA1\u7EBF", {
        pipelineId: context.pipelineId,
        error: prereqResult.error
      });
      this.completePipeline(context);
      return;
    }
    const startResult = await this.startVerifyTask(context);
    if (!startResult.ok) {
      this.logger.warn("MergeOrchestrator", "\u542F\u52A8 Verify \u5931\u8D25\uFF0C\u8DF3\u8FC7\u81EA\u52A8\u6821\u9A8C\u5E76\u7ED3\u675F\u7BA1\u7EBF", {
        pipelineId: context.pipelineId,
        error: startResult.error
      });
      this.completePipeline(context);
    }
  }
  /**
   * 启动 Verify 任务
   */
  async startVerifyTask(context) {
    const filePath = context.filePath;
    if (!filePath) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6587\u4EF6\u8DEF\u5F84\uFF0C\u65E0\u6CD5\u6267\u884C Verify");
    }
    const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
    if (currentContent === null) {
      return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`, { filePath });
    }
    context.stage = "verifying";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "stage_changed",
      pipelineId: context.pipelineId,
      stage: "verifying",
      context,
      timestamp: context.updatedAt
    });
    this.logger.info("MergeOrchestrator", `\u542F\u52A8 Verify \u4EFB\u52A1: ${context.pipelineId}`, {
      filePath
    });
    const settings = this.getSettings();
    try {
      const taskId = this.deps.taskQueue.enqueue(
        TaskFactory.create({
          nodeId: context.nodeId,
          taskType: "verify",
          maxAttempts: settings.maxRetryAttempts,
          providerRef: this.getProviderIdForTask("verify"),
          payload: {
            pipelineId: context.pipelineId,
            filePath,
            currentContent,
            conceptType: context.type,
            standardizedData: context.standardizedData
          }
        })
      );
      this.taskToPipeline.set(taskId, context.pipelineId);
      return ok(void 0);
    } catch (error) {
      if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
        const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
        return err("E320_TASK_CONFLICT", msg);
      }
      return toErr(error, "E500_INTERNAL_ERROR", "Verify \u4EFB\u52A1\u521B\u5EFA\u5931\u8D25");
    }
  }
  /**
   * 完成管线
   */
  completePipeline(context) {
    context.stage = "completed";
    context.updatedAt = formatCRTimestamp();
    void this.savePipelineState();
    this.publishEvent({
      type: "pipeline_completed",
      pipelineId: context.pipelineId,
      stage: "completed",
      context,
      timestamp: context.updatedAt
    });
  }
  // ========================================================================
  // 私有方法 — 辅助工具
  // ========================================================================
  /**
   * 持久化管线状态到文件
   *
   * 收集当前 Orchestrator 的活跃管线状态并通过 PipelineStateStore 保存。
   * 仅保存处于 review_changes 阶段的管线（需求 33.1）。
   * 管线完成或取消后，因不再处于 review_changes，自动从文件中移除（需求 33.4）。
   */
  async savePipelineState() {
    try {
      await this.deps.pipelineStateStore.persistFromOrchestrators([this]);
    } catch (error) {
      this.logger.warn("MergeOrchestrator", "\u6301\u4E45\u5316\u7BA1\u7EBF\u72B6\u6001\u5931\u8D25", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  /**
   * 获取设置
   */
  getSettings() {
    return this.deps.settingsStore.getSettings();
  }
  /**
   * 前置校验：检查 Provider 和模板是否可用
   */
  validatePrerequisites(taskType, conceptType) {
    const settings = this.getSettings();
    const providerId = this.getProviderIdForTask(taskType);
    return validatePrerequisites(
      settings,
      taskType,
      providerId,
      this.deps.promptManager,
      this.logger,
      "MergeOrchestrator",
      conceptType
    );
  }
  /**
   * 获取任务对应的 Provider ID
   */
  getProviderIdForTask(taskType) {
    return resolveProviderIdForTask(this.getSettings(), taskType, this.logger, "MergeOrchestrator");
  }
  /**
   * 从路径提取笔记标题（不含 .md 扩展名）
   */
  getNoteTitleFromPath(path) {
    const fileName = path.split("/").pop() || path;
    return fileName.endsWith(".md") ? fileName.slice(0, -".md".length) : fileName;
  }
  /**
   * 从 Frontmatter 构建嵌入文本
   */
  buildEmbeddingTextFromFrontmatter(frontmatter) {
    const parts = [];
    if (frontmatter.name) {
      parts.push(frontmatter.name);
    }
    if (frontmatter.aliases && frontmatter.aliases.length > 0) {
      parts.push(...frontmatter.aliases);
    }
    if (frontmatter.definition) {
      parts.push(frontmatter.definition);
    }
    parts.push(`\u7C7B\u578B: ${frontmatter.type}`);
    if (frontmatter.tags && frontmatter.tags.length > 0) {
      parts.push(`\u6807\u7B7E: ${frontmatter.tags.join(", ")}`);
    }
    return parts.join("\n");
  }
  /**
   * 追加验证报告到笔记末尾
   * 委托给 orchestrator-utils 共享的 buildVerificationReportMarkdown（DRY）
   */
  async appendVerificationReportToNote(filePath, result) {
    try {
      const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
      if (currentContent === null) {
        this.logger.warn("MergeOrchestrator", "\u6587\u4EF6\u4E0D\u5B58\u5728\uFF0C\u65E0\u6CD5\u8FFD\u52A0\u62A5\u544A", { filePath });
        return;
      }
      const report = buildVerificationReportMarkdown(result);
      const separator = currentContent.endsWith("\n") ? "\n" : "\n\n";
      const newContent = `${currentContent}${separator}${report}`;
      await this.deps.noteRepository.writeAtomic(filePath, newContent);
      this.logger.info("MergeOrchestrator", `\u9A8C\u8BC1\u62A5\u544A\u5DF2\u8FFD\u52A0: ${filePath}`);
    } catch (error) {
      this.logger.error("MergeOrchestrator", "\u8FFD\u52A0\u9A8C\u8BC1\u62A5\u544A\u5931\u8D25", error, { filePath });
    }
  }
  /**
   * 生成管线 ID
   */
  generatePipelineId() {
    return `pipeline-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * 发布事件
   */
  publishEvent(event2) {
    for (const listener of this.listeners) {
      try {
        listener(event2);
      } catch (error) {
        this.logger.error("MergeOrchestrator", "\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error);
      }
    }
  }
};

// src/core/verify-orchestrator.ts
var VerifyOrchestrator = class {
  deps;
  logger;
  /** 活跃管线上下文 */
  pipelines = /* @__PURE__ */ new Map();
  /** 事件监听器 */
  listeners = [];
  /** taskId → pipelineId 映射 */
  taskToPipeline = /* @__PURE__ */ new Map();
  /** 队列事件取消订阅 */
  unsubscribeQueue;
  constructor(deps) {
    this.deps = deps;
    this.logger = deps.logger;
    this.subscribeToTaskQueue();
    this.logger.debug("VerifyOrchestrator", "\u6838\u67E5\u7BA1\u7EBF\u7F16\u6392\u5668\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // ========================================================================
  // 公开方法
  // ========================================================================
  /**
   * 启动核查管线（手动触发）
   *
   * 流程：读取笔记 → 创建快照 → 入队 Verify 任务 → 追加报告
   *
   * @param filePath 目标笔记路径
   * @returns 管线 ID
   */
  startVerifyPipeline(filePath) {
    const prereqResult = this.validatePrerequisites("verify");
    if (!prereqResult.ok) {
      return prereqResult;
    }
    const file = this.deps.noteRepository.getFileByPath(filePath);
    if (!file) {
      return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`);
    }
    const pipelineId = this.generatePipelineId();
    const now2 = formatCRTimestamp();
    const context = {
      kind: "verify",
      pipelineId,
      nodeId: generateUUID(),
      // 临时 ID，后续从 frontmatter 读取
      type: "Entity",
      // 临时类型，后续从 frontmatter 读取
      stage: "idle",
      userInput: file.basename,
      filePath,
      createdAt: now2,
      updatedAt: now2
    };
    this.pipelines.set(pipelineId, context);
    this.logger.info("VerifyOrchestrator", `\u542F\u52A8 Verify \u7BA1\u7EBF: ${pipelineId}`, { filePath });
    void this.executeVerifyPipeline(context, file);
    return ok(pipelineId);
  }
  /**
   * 取消管线
   */
  cancelPipeline(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E311_NOT_FOUND", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    for (const [taskId, pid] of this.taskToPipeline.entries()) {
      if (pid === pipelineId) {
        try {
          this.deps.taskQueue.cancel(taskId);
        } catch (error) {
          this.logger.warn("VerifyOrchestrator", `\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25: ${taskId}`, {
            pipelineId,
            error: error instanceof Error ? error.message : String(error)
          });
        }
        this.taskToPipeline.delete(taskId);
      }
    }
    context.stage = "failed";
    context.error = { code: "E310_INVALID_STATE", message: "\u7528\u6237\u53D6\u6D88" };
    context.updatedAt = formatCRTimestamp();
    this.logger.info("VerifyOrchestrator", `\u7BA1\u7EBF\u5DF2\u53D6\u6D88: ${pipelineId}`);
    return ok(void 0);
  }
  /**
   * 获取管线上下文
   */
  getContext(pipelineId) {
    return this.pipelines.get(pipelineId);
  }
  /**
   * 获取所有活跃管线
   */
  getActivePipelines() {
    return Array.from(this.pipelines.values()).filter(
      (ctx) => ctx.stage !== "completed" && ctx.stage !== "failed"
    );
  }
  /**
   * 订阅管线事件
   */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const index2 = this.listeners.indexOf(listener);
      if (index2 > -1) {
        this.listeners.splice(index2, 1);
      }
    };
  }
  /**
   * 恢复持久化的管线状态
   */
  restorePipelines(pipelines, taskToPipeline) {
    for (const [id, ctx] of pipelines) {
      if (ctx.kind === "verify") {
        this.pipelines.set(id, ctx);
      }
    }
    for (const [taskId, pipelineId] of taskToPipeline) {
      if (this.pipelines.has(pipelineId)) {
        this.taskToPipeline.set(taskId, pipelineId);
      }
    }
  }
  /**
   * 获取活跃管线和任务映射（用于持久化）
   */
  getActiveState() {
    const activePipelines = /* @__PURE__ */ new Map();
    for (const [id, ctx] of this.pipelines) {
      if (ctx.stage !== "completed" && ctx.stage !== "failed") {
        activePipelines.set(id, ctx);
      }
    }
    const activeTaskMap = /* @__PURE__ */ new Map();
    for (const [taskId, pipelineId] of this.taskToPipeline) {
      if (activePipelines.has(pipelineId)) {
        activeTaskMap.set(taskId, pipelineId);
      }
    }
    return { pipelines: activePipelines, taskToPipeline: activeTaskMap };
  }
  /**
   * 释放资源
   */
  dispose() {
    if (this.unsubscribeQueue) {
      this.unsubscribeQueue();
      this.unsubscribeQueue = void 0;
    }
  }
  // ========================================================================
  // 私有方法 — 任务队列事件处理
  // ========================================================================
  /**
   * 订阅任务队列事件
   */
  subscribeToTaskQueue() {
    this.unsubscribeQueue?.();
    this.unsubscribeQueue = this.deps.taskQueue.subscribe((event2) => {
      if (event2.type === "task-completed" && event2.taskId) {
        void this.handleTaskCompleted(event2.taskId);
      } else if (event2.type === "task-failed" && event2.taskId) {
        this.handleTaskFailed(event2.taskId);
      }
    });
  }
  /**
   * 处理任务完成事件
   */
  async handleTaskCompleted(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    if (!task) return;
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    this.logger.debug("VerifyOrchestrator", `\u4EFB\u52A1\u5B8C\u6210: ${taskId}`, {
      pipelineId,
      taskType: task.taskType
    });
    if (task.taskType === "verify") {
      await this.handleVerifyCompleted(context, task);
    }
  }
  /**
   * 处理任务失败事件
   */
  handleTaskFailed(taskId) {
    const task = this.deps.taskQueue.getTask(taskId);
    const pipelineId = this.taskToPipeline.get(taskId) || (typeof task?.payload?.pipelineId === "string" ? task.payload.pipelineId : void 0);
    if (!pipelineId) return;
    if (!this.taskToPipeline.has(taskId)) {
      this.taskToPipeline.set(taskId, pipelineId);
    }
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    context.stage = "failed";
    context.error = {
      code: task?.errors?.[0]?.code || "E500_INTERNAL_ERROR",
      message: task?.errors?.[0]?.message || "\u4EFB\u52A1\u6267\u884C\u5931\u8D25"
    };
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "pipeline_failed",
      pipelineId,
      stage: "failed",
      context,
      timestamp: context.updatedAt
    });
    this.logger.error("VerifyOrchestrator", `\u7BA1\u7EBF\u5931\u8D25: ${pipelineId}`, void 0, {
      taskId,
      error: context.error
    });
  }
  // ========================================================================
  // 私有方法 — Verify 任务完成处理
  // ========================================================================
  /**
   * Verify 任务完成：追加报告到笔记末尾并完成管线
   *
   * 遵循需求 27.3：调用 LLM 进行事实核查并将报告追加到笔记末尾
   */
  async handleVerifyCompleted(context, task) {
    const result = task.result || task.payload?.result;
    if (!result) {
      context.stage = "failed";
      context.error = { code: "E310_INVALID_STATE", message: "Verify \u7ED3\u679C\u7F3A\u5931" };
      context.updatedAt = formatCRTimestamp();
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: context.updatedAt
      });
      return;
    }
    context.verificationResult = result;
    this.logger.info("VerifyOrchestrator", `Verify \u5B8C\u6210: ${context.pipelineId}`, {
      overall_assessment: result.overall_assessment,
      issueCount: Array.isArray(result.issues) ? result.issues.length : 0
    });
    const filePath = context.filePath;
    if (filePath) {
      const appendResult = await this.appendVerificationReportToNote(
        filePath,
        result,
        task.id,
        context.nodeId
      );
      if (!appendResult.ok) {
        context.stage = "failed";
        context.error = { code: appendResult.error.code, message: appendResult.error.message };
        context.updatedAt = formatCRTimestamp();
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: context.updatedAt
        });
        return;
      }
    }
    this.completePipeline(context);
  }
  // ========================================================================
  // 私有方法 — 管线核心逻辑
  // ========================================================================
  /**
   * 执行核查管线（异步）
   *
   * 流程：读取笔记 → 解析 frontmatter → 创建快照 → 入队 Verify 任务
   */
  async executeVerifyPipeline(context, file) {
    try {
      const content = await this.deps.noteRepository.readByPath(file.path);
      const extracted = extractFrontmatter(content);
      if (!extracted) {
        context.stage = "failed";
        context.error = { code: "E500_INTERNAL_ERROR", message: "\u65E0\u6CD5\u89E3\u6790\u76EE\u6807\u7B14\u8BB0\u7684 frontmatter" };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      context.nodeId = extracted.frontmatter.cruid;
      context.type = extracted.frontmatter.type;
      const snapshotResult = await this.deps.undoManager.createSnapshot(
        context.filePath,
        content,
        context.pipelineId,
        context.nodeId
      );
      if (snapshotResult.ok) {
        context.snapshotId = snapshotResult.value;
      }
      const prereqResult = this.validatePrerequisites("verify", context.type);
      if (!prereqResult.ok) {
        context.stage = "failed";
        context.error = { code: prereqResult.error.code, message: prereqResult.error.message };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
      const startResult = await this.startVerifyTask(context);
      if (!startResult.ok) {
        context.stage = "failed";
        context.error = { code: startResult.error.code, message: startResult.error.message };
        this.publishEvent({
          type: "pipeline_failed",
          pipelineId: context.pipelineId,
          stage: "failed",
          context,
          timestamp: formatCRTimestamp()
        });
        return;
      }
    } catch (error) {
      this.logger.error("VerifyOrchestrator", "Verify \u7BA1\u7EBF\u6267\u884C\u5931\u8D25", error, {
        pipelineId: context.pipelineId
      });
      context.stage = "failed";
      context.error = { code: "E500_INTERNAL_ERROR", message: String(error) };
      this.publishEvent({
        type: "pipeline_failed",
        pipelineId: context.pipelineId,
        stage: "failed",
        context,
        timestamp: formatCRTimestamp()
      });
    }
  }
  /**
   * 入队 Verify 任务
   */
  async startVerifyTask(context) {
    const filePath = context.filePath;
    if (!filePath) {
      return err("E310_INVALID_STATE", "\u7F3A\u5C11\u6587\u4EF6\u8DEF\u5F84\uFF0C\u65E0\u6CD5\u6267\u884C Verify");
    }
    const currentContent = await this.deps.noteRepository.readByPathIfExists(filePath);
    if (currentContent === null) {
      return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`, { filePath });
    }
    context.stage = "verifying";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "stage_changed",
      pipelineId: context.pipelineId,
      stage: "verifying",
      context,
      timestamp: context.updatedAt
    });
    this.logger.info("VerifyOrchestrator", `\u542F\u52A8 Verify \u4EFB\u52A1: ${context.pipelineId}`, {
      filePath
    });
    const settings = this.getSettings();
    try {
      const taskId = this.deps.taskQueue.enqueue(
        TaskFactory.create({
          nodeId: context.nodeId,
          taskType: "verify",
          maxAttempts: settings.maxRetryAttempts,
          providerRef: this.getProviderIdForTask("verify"),
          payload: {
            pipelineId: context.pipelineId,
            filePath,
            currentContent,
            conceptType: context.type,
            standardizedData: context.standardizedData
          }
        })
      );
      this.taskToPipeline.set(taskId, context.pipelineId);
      return ok(void 0);
    } catch (error) {
      if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
        const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
        return err("E320_TASK_CONFLICT", msg);
      }
      return toErr(error, "E500_INTERNAL_ERROR", "Verify \u4EFB\u52A1\u521B\u5EFA\u5931\u8D25");
    }
  }
  /**
   * 完成管线
   */
  completePipeline(context) {
    context.stage = "completed";
    context.updatedAt = formatCRTimestamp();
    this.publishEvent({
      type: "pipeline_completed",
      pipelineId: context.pipelineId,
      stage: "completed",
      context,
      timestamp: context.updatedAt
    });
  }
  // ========================================================================
  // 私有方法 — 辅助工具
  // ========================================================================
  /**
   * 获取设置
   */
  getSettings() {
    return this.deps.settingsStore.getSettings();
  }
  /**
   * 前置校验：检查 Provider 和模板是否可用
   */
  validatePrerequisites(taskType, conceptType) {
    const settings = this.getSettings();
    const providerId = this.getProviderIdForTask(taskType);
    return validatePrerequisites(
      settings,
      taskType,
      providerId,
      this.deps.promptManager,
      this.logger,
      "VerifyOrchestrator",
      conceptType
    );
  }
  /**
   * 获取任务对应的 Provider ID
   */
  getProviderIdForTask(taskType) {
    return resolveProviderIdForTask(this.getSettings(), taskType, this.logger, "VerifyOrchestrator");
  }
  /**
   * 追加验证报告到笔记末尾
   * 委托给 orchestrator-utils 共享的 buildVerificationReportMarkdown（DRY）
   */
  async appendVerificationReportToNote(filePath, result, snapshotTaskId, nodeId) {
    try {
      const existing = await this.deps.noteRepository.readByPathIfExists(filePath);
      if (existing === null) {
        return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${filePath}`, { filePath });
      }
      const snapshotResult = await this.deps.undoManager.createSnapshot(
        filePath,
        existing,
        snapshotTaskId,
        nodeId
      );
      if (!snapshotResult.ok) {
        return err(snapshotResult.error.code, snapshotResult.error.message, snapshotResult.error.details);
      }
      const report = buildVerificationReportMarkdown(result);
      const separator = existing.endsWith("\n") ? "\n" : "\n\n";
      const next2 = `${existing}${separator}${report}
`;
      await this.deps.noteRepository.writeAtomic(filePath, next2);
      this.logger.info("VerifyOrchestrator", `\u9A8C\u8BC1\u62A5\u544A\u5DF2\u8FFD\u52A0: ${filePath}`);
      return ok(void 0);
    } catch (error) {
      return toErr(error, "E302_PERMISSION_DENIED", "\u8FFD\u52A0 Verify \u62A5\u544A\u5931\u8D25");
    }
  }
  /**
   * 生成管线 ID
   */
  generatePipelineId() {
    return `pipeline-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  /**
   * 发布事件
   */
  publishEvent(event2) {
    for (const listener of this.listeners) {
      try {
        listener(event2);
      } catch (error) {
        this.logger.error("VerifyOrchestrator", "\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error);
      }
    }
  }
};

// src/core/expand-orchestrator.ts
var import_obsidian8 = require("obsidian");
var HIERARCHICAL_FIELD_MAP = {
  Domain: [
    { field: "sub_domains", target: "Domain" },
    { field: "issues", target: "Issue" }
  ],
  Issue: [
    { field: "sub_issues", target: "Issue" },
    { field: "theories", target: "Theory" }
  ],
  Theory: [
    { field: "sub_theories", target: "Theory" },
    { field: "entities", target: "Entity" },
    { field: "mechanisms", target: "Mechanism" }
  ],
  Entity: [],
  Mechanism: []
};
var MAX_CREATABLE = 200;
var ExpandOrchestrator = class {
  deps;
  logger;
  createOrchestrator;
  fileStorage;
  constructor(deps, extra) {
    this.deps = deps;
    this.logger = deps.logger;
    this.createOrchestrator = extra.createOrchestrator;
    this.fileStorage = extra.fileStorage;
  }
  /**
   * 准备拓展计划：根据当前笔记类型选择层级或抽象模式
   */
  async prepare(file) {
    try {
      const content = await this.deps.app.vault.cachedRead(file);
      const extracted = extractFrontmatter(content);
      if (!extracted) {
        return err("E310_INVALID_STATE", "\u5F53\u524D\u7B14\u8BB0\u7F3A\u5C11 frontmatter\uFF0C\u65E0\u6CD5\u6267\u884C\u62D3\u5C55");
      }
      const { frontmatter, body } = extracted;
      const noteType = frontmatter.type;
      const parentTitle = frontmatter.name || file.basename;
      if (!noteType || !HIERARCHICAL_FIELD_MAP[noteType]) {
        return err("E310_INVALID_STATE", "\u5F53\u524D\u7B14\u8BB0\u7C7B\u578B\u4E0D\u652F\u6301\u62D3\u5C55");
      }
      if (noteType === "Domain" || noteType === "Issue" || noteType === "Theory") {
        const plan = this.buildHierarchicalPlan({
          parentTitle,
          currentPath: file.path,
          currentType: noteType,
          body
        });
        if (plan.candidates.length === 0) {
          return err("E310_INVALID_STATE", "\u672A\u627E\u5230\u53EF\u521B\u5EFA\u7684\u5019\u9009\u9879\uFF0C\u8BF7\u68C0\u67E5\u6B63\u6587\u7ED3\u6784");
        }
        return ok(plan);
      }
      if (noteType === "Entity" || noteType === "Mechanism") {
        const planResult = await this.buildAbstractPlan({
          currentTitle: parentTitle,
          currentUid: frontmatter.cruid,
          currentPath: file.path,
          currentType: noteType
        });
        return planResult;
      }
      return err("E310_INVALID_STATE", "\u5F53\u524D\u7B14\u8BB0\u7C7B\u578B\u4E0D\u652F\u6301\u62D3\u5C55");
    } catch (error) {
      this.logger.error("ExpandOrchestrator", "\u51C6\u5907\u62D3\u5C55\u8BA1\u5212\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u51C6\u5907\u62D3\u5C55\u8BA1\u5212\u5931\u8D25", error);
    }
  }
  /**
   * 批量启动层级拓展的创建管线
   */
  async createFromHierarchical(plan, selected) {
    const failures = [];
    let started = 0;
    for (const candidate of selected) {
      if (candidate.status !== "creatable") continue;
      const sc = this.buildStandardizedConcept(candidate.name, candidate.targetType, candidate.description);
      const parentLink = this.wrapAsWikilink(plan.parentTitle);
      const options = {
        parents: [parentLink],
        targetPathOverride: candidate.targetPath
      };
      const result = this.createOrchestrator.startCreatePipelineWithPreset(
        sc,
        candidate.targetType,
        options
      );
      if (result.ok) {
        started += 1;
      } else {
        failures.push({ name: candidate.name, message: result.error.message });
      }
    }
    if (started === 0) {
      return err("E310_INVALID_STATE", "\u672A\u80FD\u542F\u52A8\u4EFB\u4F55\u521B\u5EFA\u4EFB\u52A1", { failures });
    }
    return ok({ started, failed: failures });
  }
  /**
   * 启动抽象拓展（生成 1 个同类型更抽象概念）
   */
  async createFromAbstract(plan, selected) {
    if (selected.length === 0) {
      return err("E101_INVALID_INPUT", "\u8BF7\u81F3\u5C11\u9009\u62E9\u4E00\u4E2A\u76F8\u4F3C\u6982\u5FF5");
    }
    try {
      const sourceTitles = [];
      const sourceSections = [];
      const currentFile = this.deps.app.vault.getAbstractFileByPath(plan.currentPath);
      if (!(currentFile instanceof import_obsidian8.TFile)) {
        return err("E311_NOT_FOUND", "\u5F53\u524D\u7B14\u8BB0\u4E0D\u5B58\u5728\u6216\u5DF2\u88AB\u79FB\u52A8");
      }
      const currentContent = await this.deps.app.vault.cachedRead(currentFile);
      sourceTitles.push(plan.currentTitle);
      sourceSections.push(this.wrapSource(plan.currentTitle, currentFile.path, currentContent));
      for (const item of selected) {
        const file = this.deps.app.vault.getAbstractFileByPath(item.path);
        if (!(file instanceof import_obsidian8.TFile)) {
          this.logger.warn("ExpandOrchestrator", "\u76F8\u4F3C\u6982\u5FF5\u6587\u4EF6\u672A\u627E\u5230\uFF0C\u5DF2\u8DF3\u8FC7", { path: item.path });
          continue;
        }
        const content = await this.deps.app.vault.cachedRead(file);
        const extracted = extractFrontmatter(content);
        const title = extracted?.frontmatter.name || item.name;
        sourceTitles.push(title);
        sourceSections.push(this.wrapSource(title, file.path, content));
      }
      const sources = sourceSections.join("\n\n---\n\n");
      const abstractInput = `\u62BD\u8C61\u4EE5\u4E0B${plan.currentType}\uFF1A${sourceTitles.join("\u3001")}\uFF0C\u751F\u6210\u4E00\u4E2A\u66F4\u9AD8\u5C42\u7684 ${plan.currentType} \u6982\u5FF5\u3002`;
      const standardizeResult = await this.createOrchestrator.defineDirect(abstractInput);
      if (!standardizeResult.ok) {
        return err(standardizeResult.error.code, standardizeResult.error.message);
      }
      const standardized = {
        ...standardizeResult.value,
        primaryType: plan.currentType,
        typeConfidences: {
          ...standardizeResult.value.typeConfidences,
          [plan.currentType]: 1
        }
      };
      const targetName = standardized.standardNames[plan.currentType]?.chinese;
      if (!targetName) {
        return err("E310_INVALID_STATE", "\u6807\u51C6\u5316\u7ED3\u679C\u7F3A\u5C11\u76EE\u6807\u540D\u79F0");
      }
      const settings = this.deps.settingsStore.getSettings();
      const targetPath = generateFilePath(
        targetName,
        settings.directoryScheme,
        plan.currentType
      );
      const parentLinks = sourceTitles.map((t) => this.wrapAsWikilink(t));
      const startResult = this.createOrchestrator.startCreatePipelineWithPreset(
        standardized,
        plan.currentType,
        {
          parents: parentLinks,
          targetPathOverride: targetPath,
          sources
        }
      );
      if (!startResult.ok) {
        return err(startResult.error.code, startResult.error.message);
      }
      const context = this.createOrchestrator.getContext(startResult.value);
      if (context) {
        context.sources = sources;
      }
      return ok(startResult.value);
    } catch (error) {
      this.logger.error("ExpandOrchestrator", "\u62BD\u8C61\u62D3\u5C55\u542F\u52A8\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u62BD\u8C61\u62D3\u5C55\u542F\u52A8\u5931\u8D25", error);
    }
  }
  buildHierarchicalPlan(input) {
    const candidates = [];
    const mappings = HIERARCHICAL_FIELD_MAP[input.currentType];
    const descriptors = schemaRegistry.getFieldDescriptions(input.currentType);
    const headingMap = /* @__PURE__ */ new Map();
    for (const { field } of mappings) {
      const desc = descriptors.find((d) => d.name === field);
      if (desc?.description) {
        headingMap.set(desc.description.toLowerCase(), field);
      }
      headingMap.set(field.toLowerCase(), field);
    }
    const lines = input.body.split(/\r?\n/);
    let currentField = null;
    const rawCandidates = [];
    const fieldTargets = new Map(mappings.map((m) => [m.field, m.target]));
    let looseStructure = false;
    for (const line of lines) {
      const headingMatch = line.match(/^#{1,6}\s*(.+?)\s*$/);
      if (headingMatch) {
        const key2 = headingMatch[1].trim().toLowerCase();
        currentField = headingMap.get(key2) || null;
        continue;
      }
      if (!currentField) continue;
      const targetType = fieldTargets.get(currentField);
      if (!targetType) continue;
      const parsed = this.parseLineForField(currentField, line);
      if (parsed) {
        rawCandidates.push({ ...parsed, targetType });
      }
    }
    if (rawCandidates.length === 0) {
      looseStructure = true;
      const fallbackTarget = mappings[0]?.target;
      if (fallbackTarget) {
        for (const line of lines) {
          const parsed = this.parseLineForField("fallback", line);
          if (parsed) {
            rawCandidates.push({ ...parsed, targetType: fallbackTarget });
          }
        }
      }
    }
    const seen = /* @__PURE__ */ new Set();
    let creatableCount = 0;
    const settings = this.deps.settingsStore.getSettings();
    for (const item of rawCandidates) {
      const normalizedName = this.normalizeLinkName(item.name);
      const key2 = `${item.targetType}::${normalizedName.toLowerCase()}`;
      if (!normalizedName || seen.has(key2)) continue;
      seen.add(key2);
      let status = "creatable";
      let reason;
      const sanitized = sanitizeFileName(normalizedName);
      if (!sanitized) {
        status = "invalid";
        reason = "\u540D\u79F0\u5305\u542B\u975E\u6CD5\u5B57\u7B26";
      } else if (normalizedName.length > 256) {
        status = "invalid";
        reason = "\u540D\u79F0\u8FC7\u957F";
      }
      const targetPath = generateFilePath(
        normalizedName,
        settings.directoryScheme,
        item.targetType
      );
      if (status === "creatable") {
        const exists = !!this.deps.app.vault.getAbstractFileByPath(targetPath);
        if (exists) {
          status = "existing";
          reason = "\u5DF2\u5B58\u5728";
        } else if (creatableCount >= MAX_CREATABLE) {
          status = "invalid";
          reason = "\u8D85\u8FC7\u6279\u91CF\u521B\u5EFA\u4E0A\u9650\uFF08200\uFF09\uFF0C\u8BF7\u5206\u6279\u6267\u884C";
        } else {
          creatableCount += 1;
        }
      }
      candidates.push({
        name: normalizedName,
        description: item.description,
        targetType: item.targetType,
        targetPath,
        status,
        reason
      });
    }
    return {
      mode: "hierarchical",
      parentTitle: input.parentTitle,
      currentPath: input.currentPath,
      currentType: input.currentType,
      candidates,
      looseStructure
    };
  }
  async buildAbstractPlan(input) {
    if (!input.currentUid) {
      return err("E310_INVALID_STATE", "\u5F53\u524D\u7B14\u8BB0\u7F3A\u5C11 cruid\uFF0C\u65E0\u6CD5\u68C0\u7D22\u76F8\u4F3C\u6982\u5FF5");
    }
    try {
      const vectorResult = await this.fileStorage.readVectorFile(input.currentType, input.currentUid);
      if (!vectorResult.ok) {
        return err("E310_INVALID_STATE", "\u5F53\u524D\u7B14\u8BB0\u5C1A\u672A\u751F\u6210\u5411\u91CF\u5D4C\u5165\uFF0C\u8BF7\u5148\u5B8C\u6210\u521B\u5EFA\u6216\u91CD\u5EFA\u7D22\u5F15");
      }
      const vector = vectorResult.value;
      if (!vector.embedding || vector.embedding.length === 0) {
        return err("E310_INVALID_STATE", "\u5F53\u524D\u7B14\u8BB0\u5D4C\u5165\u4E3A\u7A7A\uFF0C\u65E0\u6CD5\u6267\u884C\u76F8\u4F3C\u68C0\u7D22");
      }
      const searchResult = await this.deps.vectorIndex.search(
        input.currentType,
        vector.embedding,
        15
      );
      if (!searchResult.ok) {
        return err(searchResult.error.code, searchResult.error.message);
      }
      const candidates = searchResult.value.filter((item) => item.uid !== input.currentUid && item.path).map((item) => ({
        uid: item.uid,
        name: item.name,
        path: item.path,
        similarity: item.similarity
      }));
      if (candidates.length === 0) {
        return err("E310_INVALID_STATE", "\u672A\u627E\u5230\u53EF\u7528\u7684\u76F8\u4F3C\u6982\u5FF5\uFF0C\u65E0\u6CD5\u6267\u884C\u62BD\u8C61\u62D3\u5C55");
      }
      return ok({
        mode: "abstract",
        currentTitle: input.currentTitle,
        currentUid: input.currentUid,
        currentPath: input.currentPath,
        currentType: input.currentType,
        candidates
      });
    } catch (error) {
      this.logger.error("ExpandOrchestrator", "\u6784\u5EFA\u62BD\u8C61\u62D3\u5C55\u8BA1\u5212\u5931\u8D25", error);
      return err("E500_INTERNAL_ERROR", "\u6784\u5EFA\u62BD\u8C61\u62D3\u5C55\u8BA1\u5212\u5931\u8D25", error);
    }
  }
  parseLineForField(field, line) {
    const basicMatch = line.match(/^\s*[-*]\s+\[\[([^\]]+)\]\]\s*[：:]\s*(.+)?$/);
    if (basicMatch && (field.startsWith("sub_") || field === "issues")) {
      return { name: basicMatch[1].trim(), description: basicMatch[2]?.trim() };
    }
    const theoryMatch = line.match(/^\s*[-*]\s+\[\[([^\]]+)\]\]\s*(?:\(([^)]+)\))?\s*[：:]\s*(.+)?$/);
    if (theoryMatch && (field === "theories" || field === "fallback")) {
      const descParts = [theoryMatch[2], theoryMatch[3]].filter(Boolean).join(" / ");
      return { name: theoryMatch[1].trim(), description: descParts || void 0 };
    }
    const entityMatch = line.match(/^\s*[-*]\s+\[\[([^\]]+)\]\]/);
    if (entityMatch && (field === "entities" || field === "mechanisms" || field === "fallback")) {
      return { name: entityMatch[1].trim() };
    }
    if (field === "fallback") {
      const genericMatch = line.match(/^\s*[-*]\s+\[\[([^\]]+)\]\]/);
      if (genericMatch) {
        return { name: genericMatch[1].trim() };
      }
    }
    return null;
  }
  normalizeLinkName(raw) {
    const name = raw.split("|")[0]?.trim() || "";
    return name;
  }
  buildStandardizedConcept(name, targetType, description) {
    const build = (n) => ({ chinese: n, english: "" });
    return {
      standardNames: {
        Domain: build(name),
        Issue: build(name),
        Theory: build(name),
        Entity: build(name),
        Mechanism: build(name)
      },
      typeConfidences: {
        Domain: targetType === "Domain" ? 1 : 0,
        Issue: targetType === "Issue" ? 1 : 0,
        Theory: targetType === "Theory" ? 1 : 0,
        Entity: targetType === "Entity" ? 1 : 0,
        Mechanism: targetType === "Mechanism" ? 1 : 0
      },
      primaryType: targetType,
      coreDefinition: description
    };
  }
  wrapSource(title, path, content) {
    return `# \u6765\u6E90\uFF1A${title}
\u8DEF\u5F84: ${path}

${content}`;
  }
  wrapAsWikilink(title) {
    const trimmed = title.trim();
    if (/^\[\[.*\]\]$/.test(trimmed)) return trimmed;
    return `[[${trimmed}]]`;
  }
};

// src/core/image-insert-orchestrator.ts
var ImageInsertOrchestrator = class {
  deps;
  logger;
  /** 活跃管线上下文 */
  pipelines = /* @__PURE__ */ new Map();
  /** 事件监听器 */
  listeners = [];
  /** taskId → pipelineId 映射 */
  taskToPipeline = /* @__PURE__ */ new Map();
  /** 队列事件取消订阅 */
  unsubscribeQueue;
  constructor(deps) {
    this.deps = deps;
    this.logger = deps.logger;
    this.subscribeToTaskQueue();
    this.logger.debug("ImageInsertOrchestrator", "\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u7F16\u6392\u5668\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // ========================================================================
  // 公开方法
  // ========================================================================
  /**
   * 启动图片插入管线
   *
   * 流程：前置校验 → 构建 payload → 入队 image-generate 任务
   * TaskRunner 执行时完成：生成图片描述 → 调用图像 API → 保存附件 → 插入链接
   *
   * @param options 管线选项
   * @returns 管线 ID
   */
  startImagePipeline(options) {
    try {
      const settings = this.getSettings();
      if (!settings.imageGeneration?.enabled) {
        return err("E310_INVALID_STATE", "\u56FE\u7247\u751F\u6210\u529F\u80FD\u672A\u542F\u7528");
      }
      const file = this.deps.noteRepository.getFileByPath(options.filePath);
      if (!file) {
        return err("E301_FILE_NOT_FOUND", `\u6587\u4EF6\u4E0D\u5B58\u5728: ${options.filePath}`);
      }
      const pipelineId = this.generatePipelineId();
      const now2 = formatCRTimestamp();
      const payload = {
        filePath: options.filePath,
        cursorPosition: options.cursorPosition,
        userPrompt: options.userPrompt,
        contextBefore: options.contextBefore,
        contextAfter: options.contextAfter,
        frontmatter: options.frontmatter ?? {
          cruid: "",
          type: "Entity",
          name: file.basename,
          status: "Draft"
        }
      };
      const taskId = this.deps.taskQueue.enqueue(
        TaskFactory.create({
          nodeId: options.frontmatter?.cruid || options.filePath,
          taskType: "image-generate",
          payload,
          providerRef: this.getProviderIdForTask(),
          maxAttempts: settings.maxRetryAttempts ?? 3
        })
      );
      const context = {
        pipelineId,
        filePath: options.filePath,
        cursorPosition: options.cursorPosition,
        userDescription: options.userPrompt,
        stage: "enqueued",
        taskId,
        createdAt: now2,
        updatedAt: now2
      };
      this.pipelines.set(pipelineId, context);
      this.taskToPipeline.set(taskId, pipelineId);
      this.logger.info("ImageInsertOrchestrator", "\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u5DF2\u542F\u52A8", {
        pipelineId,
        taskId,
        filePath: options.filePath
      });
      this.publishEvent({
        type: "stage_changed",
        pipelineId,
        stage: "enqueued",
        context,
        timestamp: now2
      });
      return ok(pipelineId);
    } catch (error) {
      this.logger.error("ImageInsertOrchestrator", "\u542F\u52A8\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u5931\u8D25", error);
      if (error instanceof CognitiveRazorError && error.code === "E320_TASK_CONFLICT") {
        const msg = this.deps.i18n.t("workbench.notifications.conceptLocked");
        return err("E320_TASK_CONFLICT", msg);
      }
      return toErr(error, "E500_INTERNAL_ERROR", "\u542F\u52A8\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u5931\u8D25");
    }
  }
  /**
   * 兼容旧接口：直接入队图片生成任务
   *
   * @param payload 图片生成载荷
   * @returns 任务 ID
   */
  execute(payload) {
    const result = this.startImagePipeline({
      filePath: payload.filePath,
      cursorPosition: payload.cursorPosition,
      userPrompt: payload.userPrompt,
      contextBefore: payload.contextBefore ?? "",
      contextAfter: payload.contextAfter ?? "",
      frontmatter: payload.frontmatter
    });
    if (!result.ok) {
      return result;
    }
    const context = this.pipelines.get(result.value);
    return ok(context?.taskId ?? result.value);
  }
  /**
   * 取消管线
   */
  cancelPipeline(pipelineId) {
    const context = this.pipelines.get(pipelineId);
    if (!context) {
      return err("E310_INVALID_STATE", `\u7BA1\u7EBF\u4E0D\u5B58\u5728: ${pipelineId}`);
    }
    if (context.taskId) {
      this.deps.taskRunner.abort(context.taskId);
      this.taskToPipeline.delete(context.taskId);
    }
    this.pipelines.delete(pipelineId);
    this.logger.info("ImageInsertOrchestrator", "\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u5DF2\u53D6\u6D88", { pipelineId });
    return ok(void 0);
  }
  /**
   * 获取管线上下文
   */
  getContext(pipelineId) {
    return this.pipelines.get(pipelineId);
  }
  /**
   * 获取所有活跃管线
   */
  getActivePipelines() {
    return Array.from(this.pipelines.values()).filter(
      (ctx) => ctx.stage !== "completed" && ctx.stage !== "failed"
    );
  }
  /**
   * 订阅管线事件
   */
  subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      const idx = this.listeners.indexOf(listener);
      if (idx >= 0) this.listeners.splice(idx, 1);
    };
  }
  /**
   * 释放资源
   */
  dispose() {
    this.unsubscribeQueue?.();
    this.pipelines.clear();
    this.taskToPipeline.clear();
    this.listeners.length = 0;
    this.logger.debug("ImageInsertOrchestrator", "\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u7F16\u6392\u5668\u5DF2\u91CA\u653E");
  }
  // ========================================================================
  // 私有方法
  // ========================================================================
  /**
   * 订阅任务队列事件
   */
  subscribeToTaskQueue() {
    this.unsubscribeQueue = this.deps.taskQueue.subscribe((event2) => {
      const taskId = event2.taskId;
      if (!taskId) return;
      if (event2.type === "task-completed") {
        this.handleTaskCompleted(taskId);
      } else if (event2.type === "task-failed") {
        this.handleTaskFailed(taskId);
      } else if (event2.type === "task-started") {
        this.handleTaskStarted(taskId);
      }
    });
  }
  /**
   * 处理任务开始执行
   */
  handleTaskStarted(taskId) {
    const pipelineId = this.taskToPipeline.get(taskId);
    if (!pipelineId) return;
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    const now2 = formatCRTimestamp();
    context.stage = "generating";
    context.updatedAt = now2;
    this.publishEvent({
      type: "stage_changed",
      pipelineId,
      stage: "generating",
      context,
      timestamp: now2
    });
  }
  /**
   * 处理任务完成
   */
  handleTaskCompleted(taskId) {
    const pipelineId = this.taskToPipeline.get(taskId);
    if (!pipelineId) return;
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    const now2 = formatCRTimestamp();
    const task = this.deps.taskQueue.getTask(taskId);
    if (task?.result) {
      const result = task.result;
      context.result = {
        localPath: result.localPath ?? "",
        altText: result.altText ?? ""
      };
    }
    context.stage = "completed";
    context.updatedAt = now2;
    this.logger.info("ImageInsertOrchestrator", "\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u5B8C\u6210", {
      pipelineId,
      taskId,
      localPath: context.result?.localPath
    });
    this.publishEvent({
      type: "pipeline_completed",
      pipelineId,
      stage: "completed",
      context,
      timestamp: now2
    });
    this.taskToPipeline.delete(taskId);
  }
  /**
   * 处理任务失败
   */
  handleTaskFailed(taskId) {
    const pipelineId = this.taskToPipeline.get(taskId);
    if (!pipelineId) return;
    const context = this.pipelines.get(pipelineId);
    if (!context) return;
    const now2 = formatCRTimestamp();
    const task = this.deps.taskQueue.getTask(taskId);
    const lastError = task?.errors?.[task.errors.length - 1];
    context.stage = "failed";
    context.updatedAt = now2;
    context.error = {
      code: lastError?.code ?? "E500_INTERNAL_ERROR",
      message: lastError?.message ?? "\u56FE\u7247\u751F\u6210\u4EFB\u52A1\u5931\u8D25"
    };
    this.logger.error("ImageInsertOrchestrator", "\u56FE\u7247\u63D2\u5165\u7BA1\u7EBF\u5931\u8D25", void 0, {
      pipelineId,
      taskId,
      error: context.error
    });
    this.publishEvent({
      type: "pipeline_failed",
      pipelineId,
      stage: "failed",
      context,
      timestamp: now2
    });
    this.taskToPipeline.delete(taskId);
  }
  /**
   * 获取设置
   */
  getSettings() {
    return this.deps.settingsStore.getSettings();
  }
  /**
   * 获取图片生成任务的 Provider ID
   */
  getProviderIdForTask() {
    const settings = this.getSettings();
    const taskConfig = settings.taskModels?.["image-generate"];
    return taskConfig?.providerId || settings.defaultProviderId || "";
  }
  /**
   * 生成管线 ID
   */
  generatePipelineId() {
    return `img-${generateUUID().slice(0, 8)}`;
  }
  /**
   * 发布管线事件
   */
  publishEvent(event2) {
    for (const listener of this.listeners) {
      try {
        listener(event2);
      } catch (error) {
        this.logger.error("ImageInsertOrchestrator", "\u4E8B\u4EF6\u76D1\u542C\u5668\u6267\u884C\u5931\u8D25", error);
      }
    }
  }
};

// src/core/service-container.ts
var LAYER_ORDER = {
  data: 0,
  core: 1,
  ui: 2
};
var ServiceContainer = class {
  /** 服务注册表 */
  registry = /* @__PURE__ */ new Map();
  /** 按注册顺序记录的 token 列表（用于保持层内顺序） */
  registrationOrder = [];
  /** 容器是否已释放 */
  disposed = false;
  /**
   * 注册单例服务（工厂函数形式，延迟实例化）
   *
   * @param token  服务标识符（symbol）
   * @param factory 工厂函数，首次 resolve 时调用
   * @param layer  所属层级
   */
  registerFactory(token, factory, layer) {
    this.ensureNotDisposed();
    if (this.registry.has(token)) {
      throw new Error(`\u670D\u52A1\u5DF2\u6CE8\u518C: ${token.toString()}`);
    }
    this.registry.set(token, { factory, instance: null, layer });
    this.registrationOrder.push(token);
  }
  /**
   * 注册单例服务（已有实例形式）
   *
   * @param token    服务标识符（symbol）
   * @param instance 已创建的实例
   * @param layer    所属层级
   */
  registerInstance(token, instance, layer) {
    this.ensureNotDisposed();
    if (this.registry.has(token)) {
      throw new Error(`\u670D\u52A1\u5DF2\u6CE8\u518C: ${token.toString()}`);
    }
    this.registry.set(token, { factory: null, instance, layer });
    this.registrationOrder.push(token);
  }
  /**
   * 解析服务实例
   *
   * 如果服务通过工厂注册且尚未实例化，则立即调用工厂函数创建实例。
   *
   * @param token 服务标识符
   * @returns 服务实例
   * @throws 服务未注册时抛出错误
   */
  resolve(token) {
    this.ensureNotDisposed();
    const entry = this.registry.get(token);
    if (!entry) {
      throw new Error(`\u670D\u52A1\u672A\u6CE8\u518C: ${token.toString()}`);
    }
    if (entry.instance === null && entry.factory !== null) {
      entry.instance = entry.factory();
    }
    return entry.instance;
  }
  /**
   * 检查服务是否已注册
   */
  has(token) {
    return this.registry.has(token);
  }
  /**
   * 按 Data → Core → UI 顺序初始化所有服务
   *
   * 对于通过工厂注册的服务，此方法确保它们按层级顺序被实例化。
   * 如果服务实例实现了 `init()` 异步方法，将依次调用。
   *
   * @see 需求 1.2
   */
  async initializeAll() {
    this.ensureNotDisposed();
    const sorted = this.getSortedTokens("asc");
    for (const token of sorted) {
      const entry = this.registry.get(token);
      if (entry.instance === null && entry.factory !== null) {
        entry.instance = entry.factory();
      }
      const instance = entry.instance;
      if (instance && typeof instance["init"] === "function") {
        await instance["init"]();
      }
    }
  }
  /**
   * 按 UI → Core → Data 逆序释放所有服务资源
   *
   * 对实现了 Disposable 接口的服务调用 dispose()。
   * 释放后容器不可再使用。
   *
   * @see 需求 1.3
   */
  disposeAll() {
    if (this.disposed) return;
    const sorted = this.getSortedTokens("desc");
    for (const token of sorted) {
      const entry = this.registry.get(token);
      const instance = entry.instance;
      if (instance && typeof instance.dispose === "function") {
        try {
          instance.dispose();
        } catch {
        }
      }
    }
    this.registry.clear();
    this.registrationOrder.length = 0;
    this.disposed = true;
  }
  // ========================================================================
  // 内部方法
  // ========================================================================
  /**
   * 按层级排序 token 列表
   * @param direction "asc" = Data→Core→UI, "desc" = UI→Core→Data
   */
  getSortedTokens(direction) {
    const tokens = [...this.registrationOrder];
    const multiplier = direction === "asc" ? 1 : -1;
    tokens.sort((a, b) => {
      const entryA = this.registry.get(a);
      const entryB = this.registry.get(b);
      const layerDiff = LAYER_ORDER[entryA.layer] - LAYER_ORDER[entryB.layer];
      if (layerDiff !== 0) return layerDiff * multiplier;
      const orderA = this.registrationOrder.indexOf(a);
      const orderB = this.registrationOrder.indexOf(b);
      return (orderA - orderB) * multiplier;
    });
    return tokens;
  }
  /** 确保容器未被释放 */
  ensureNotDisposed() {
    if (this.disposed) {
      throw new Error("ServiceContainer \u5DF2\u91CA\u653E\uFF0C\u4E0D\u53EF\u7EE7\u7EED\u4F7F\u7528");
    }
  }
};

// src/core/content-renderer.ts
var ContentRenderer = class {
  renderNoteMarkdown(options) {
    const lines = [`# ${options.title}`, ""];
    const structured = this.renderStructuredContentMarkdown({
      type: options.type,
      content: options.content,
      language: options.language
    });
    if (structured) {
      lines.push(structured);
    }
    return lines.join("\n");
  }
  renderStructuredContentMarkdown(options) {
    let content = options.content;
    if (typeof content === "string") {
      try {
        content = JSON.parse(content);
      } catch {
      }
    }
    const lines = [];
    if (content && typeof content === "object") {
      const descriptors = schemaRegistry.getFieldDescriptions(options.type);
      for (const desc of descriptors) {
        const value = content[desc.name];
        if (value === void 0) continue;
        lines.push(`## ${this.getFieldHeading(desc, options.language)}`);
        lines.push(this.renderValue(value, desc.name));
        lines.push("");
      }
    } else if (typeof content === "string") {
      lines.push(content);
    }
    return lines.join("\n").trimEnd();
  }
  getFieldHeading(desc, language) {
    if (language === "zh") {
      return desc.description || desc.name;
    }
    return desc.name;
  }
  renderValue(value, fieldName) {
    if (Array.isArray(value)) {
      if (value.length > 0 && typeof value[0] === "object" && value[0] !== null) {
        return this.renderObjectArray(value, fieldName);
      }
      return value.map((v) => `- ${String(v)}`).join("\n");
    }
    if (typeof value === "object" && value !== null) {
      return this.renderObject(value, fieldName);
    }
    return String(value);
  }
  renderObjectArray(items, fieldName) {
    if (items.length === 0) return "";
    switch (fieldName) {
      case "sub_domains":
      case "issues":
        return this.renderNameDescriptionArray(items, true);
      case "sub_issues":
        return this.renderNameDescriptionArray(items, true);
      case "stakeholder_perspectives":
        return this.renderStakeholderPerspectives(items);
      case "theories":
        return this.renderTheories(items);
      case "axioms":
        return this.renderAxioms(items);
      case "sub_theories":
        return this.renderNameDescriptionArray(items, true);
      case "entities":
        return this.renderTheoryEntities(items);
      case "mechanisms":
        return this.renderTheoryMechanisms(items);
      case "properties":
        return this.renderEntityProperties(items);
      case "states":
        return this.renderNameDescriptionArray(items, false);
      case "operates_on":
        return this.renderOperatesOn(items);
      case "causal_chain":
        return this.renderCausalChain(items);
      case "modulation":
        return this.renderModulation(items);
    }
    return this.renderObjectArrayByStructure(items);
  }
  renderNameDescriptionArray(items, withLink) {
    return items.map((item) => {
      const name = String(item.name || "");
      const description = String(item.description || "");
      return withLink ? `- [[${name}]]\uFF1A${description}` : `- **${name}**\uFF1A${description}`;
    }).join("\n");
  }
  renderStakeholderPerspectives(items) {
    return items.map((item) => {
      const stakeholder = String(item.stakeholder || "");
      const perspective = String(item.perspective || "");
      return `- **${stakeholder}**\uFF1A${perspective}`;
    }).join("\n");
  }
  renderTheories(items) {
    return items.map((item) => {
      const name = String(item.name || "");
      const status = String(item.status || "");
      const brief = String(item.brief || "");
      const statusLabel = this.getTheoryStatusLabel(status);
      return `- [[${name}]] (${statusLabel})\uFF1A${brief}`;
    }).join("\n");
  }
  renderAxioms(items) {
    return items.map((item, index2) => {
      const statement = String(item.statement || "");
      const justification = String(item.justification || "");
      return `### \u516C\u7406 ${index2 + 1}\uFF1A${statement}
- **\u7406\u7531**\uFF1A${justification}`;
    }).join("\n\n");
  }
  renderTheoryEntities(items) {
    return items.map((item) => {
      const name = String(item.name || "");
      const role = String(item.role || "");
      const attributes = String(item.attributes || "");
      return `- [[${name}]]
  - **\u89D2\u8272**\uFF1A${role}
  - **\u5C5E\u6027**\uFF1A${attributes}`;
    }).join("\n");
  }
  renderTheoryMechanisms(items) {
    return items.map((item) => {
      const name = String(item.name || "");
      const process = String(item.process || "");
      const func = String(item.function || "");
      return `- [[${name}]]
  - **\u8FC7\u7A0B**\uFF1A${process}
  - **\u529F\u80FD**\uFF1A${func}`;
    }).join("\n");
  }
  renderEntityProperties(items) {
    return items.map((item) => {
      const name = String(item.name || "");
      const type = String(item.type || "");
      const description = String(item.description || "");
      return `- **${name}** (${type})\uFF1A${description}`;
    }).join("\n");
  }
  renderOperatesOn(items) {
    return items.map((item) => {
      const entity = String(item.entity || "");
      const role = String(item.role || "");
      return `- ${role}\uFF1A${entity}`;
    }).join("\n");
  }
  renderCausalChain(items) {
    return items.map((item) => {
      const step = item.step;
      const description = String(item.description || "");
      const interaction = String(item.interaction || "");
      return `### \u6B65\u9AA4 ${step}\uFF1A${interaction}
- ${description}`;
    }).join("\n\n");
  }
  renderModulation(items) {
    return items.map((item) => {
      const factor = String(item.factor || "");
      const effect2 = String(item.effect || "");
      const mechanism = String(item.mechanism || "");
      const effectLabel = this.getModulationEffectLabel(effect2);
      return `- **${factor}** (${effectLabel})\uFF1A${mechanism}`;
    }).join("\n");
  }
  renderObjectArrayByStructure(items) {
    const firstItem = items[0];
    if ("name" in firstItem && "type" in firstItem && "description" in firstItem) {
      return this.renderEntityProperties(items);
    }
    if ("statement" in firstItem && "justification" in firstItem) {
      return this.renderAxioms(items);
    }
    if ("name" in firstItem && "role" in firstItem && "attributes" in firstItem) {
      return this.renderTheoryEntities(items);
    }
    if ("name" in firstItem && "process" in firstItem && "function" in firstItem) {
      return this.renderTheoryMechanisms(items);
    }
    if ("name" in firstItem && "status" in firstItem && "brief" in firstItem) {
      return this.renderTheories(items);
    }
    if ("stakeholder" in firstItem && "perspective" in firstItem) {
      return this.renderStakeholderPerspectives(items);
    }
    if ("entity" in firstItem && "role" in firstItem) {
      return this.renderOperatesOn(items);
    }
    if ("step" in firstItem && "description" in firstItem && "interaction" in firstItem) {
      return this.renderCausalChain(items);
    }
    if ("factor" in firstItem && "effect" in firstItem && "mechanism" in firstItem) {
      return this.renderModulation(items);
    }
    if ("name" in firstItem && "description" in firstItem) {
      return this.renderNameDescriptionArray(items, true);
    }
    return items.map((item, index2) => {
      const entries = Object.entries(item).map(([k, v]) => `  - **${k}**\uFF1A${String(v)}`).join("\n");
      return `- \u9879\u76EE ${index2 + 1}
${entries}`;
    }).join("\n");
  }
  renderObject(obj, _fieldName) {
    if ("has_parts" in obj && "part_of" in obj) {
      const hasParts = obj.has_parts;
      const partOf = String(obj.part_of || "");
      const partsStr = Array.isArray(hasParts) && hasParts.length > 0 ? hasParts.join("\u3001") : "\u65E0";
      return `- **\u7EC4\u6210\u90E8\u5206**\uFF1A${partsStr}
- **\u6240\u5C5E\u7CFB\u7EDF**\uFF1A${partOf || "\u65E0"}`;
    }
    if ("genus" in obj && "differentia" in obj) {
      const genus = String(obj.genus || "");
      const differentia = String(obj.differentia || "");
      return `- **\u5C5E**\uFF1A${genus}
- **\u79CD\u5DEE**\uFF1A${differentia}`;
    }
    return Object.entries(obj).map(([k, v]) => `- **${k}**\uFF1A${String(v)}`).join("\n");
  }
  getTheoryStatusLabel(status) {
    const labels = {
      mainstream: "\u4E3B\u6D41",
      marginal: "\u8FB9\u7F18",
      falsified: "\u5DF2\u8BC1\u4F2A"
    };
    return labels[status] || status;
  }
  getModulationEffectLabel(effect2) {
    const labels = {
      promotes: "\u4FC3\u8FDB",
      inhibits: "\u6291\u5236",
      regulates: "\u8C03\u8282"
    };
    return labels[effect2] || effect2;
  }
};

// node_modules/svelte/src/version.js
var VERSION = "5.51.3";
var PUBLIC_VERSION = "5";

// node_modules/svelte/src/internal/disclose-version.js
if (typeof window !== "undefined") {
  ((window.__svelte ??= {}).v ??= /* @__PURE__ */ new Set()).add(PUBLIC_VERSION);
}

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_IN = 1;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var TEMPLATE_USE_SVG = 1 << 2;
var TEMPLATE_USE_MATHML = 1 << 3;
var HYDRATION_START = "[";
var HYDRATION_START_ELSE = "[!";
var HYDRATION_END = "]";
var HYDRATION_ERROR = {};
var ELEMENT_IS_NAMESPACED = 1;
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var ELEMENT_IS_INPUT = 1 << 2;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");
var NAMESPACE_HTML = "http://www.w3.org/1999/xhtml";
var NAMESPACE_SVG = "http://www.w3.org/2000/svg";
var NAMESPACE_MATHML = "http://www.w3.org/1998/Math/MathML";
var IGNORABLE_RUNTIME_WARNINGS = (
  /** @type {const} */
  [
    "await_waterfall",
    "await_reactivity_loss",
    "state_snapshot_uncloneable",
    "binding_property_non_reactive",
    "hydration_attribute_changed",
    "hydration_html_changed",
    "ownership_invalid_binding",
    "ownership_invalid_mutation"
  ]
);
var ELEMENTS_WITHOUT_TEXT = ["audio", "datalist", "dl", "optgroup", "select", "video"];
var ATTACHMENT_KEY = "@attach";

// node_modules/esm-env/true.js
var true_default = true;

// node_modules/esm-env/dev-fallback.js
var node_env = globalThis.process?.env?.NODE_ENV;
var dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");

// node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var index_of = Array.prototype.indexOf;
var includes = Array.prototype.includes;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var get_descriptors = Object.getOwnPropertyDescriptors;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var is_extensible = Object.isExtensible;
function is_function(thing) {
  return typeof thing === "function";
}
var noop = () => {
};
function is_promise(value) {
  return typeof value?.then === "function";
}
function run(fn) {
  return fn();
}
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}
function deferred() {
  var resolve;
  var reject;
  var promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function fallback(value, fallback2, lazy = false) {
  return value === void 0 ? lazy ? (
    /** @type {() => V} */
    fallback2()
  ) : (
    /** @type {V} */
    fallback2
  ) : value;
}
function to_array(value, n) {
  if (Array.isArray(value)) {
    return value;
  }
  if (n === void 0 || !(Symbol.iterator in value)) {
    return Array.from(value);
  }
  const array = [];
  for (const element2 of value) {
    array.push(element2);
    if (array.length === n) break;
  }
  return array;
}

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var MANAGED_EFFECT = 1 << 24;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var CONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var REACTION_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var EAGER_EFFECT = 1 << 17;
var HEAD_EFFECT = 1 << 18;
var EFFECT_PRESERVED = 1 << 19;
var USER_EFFECT = 1 << 20;
var EFFECT_OFFSCREEN = 1 << 25;
var WAS_MARKED = 1 << 16;
var REACTION_IS_UPDATING = 1 << 21;
var ASYNC = 1 << 22;
var ERROR_VALUE = 1 << 23;
var STATE_SYMBOL = Symbol("$state");
var LEGACY_PROPS = Symbol("legacy props");
var LOADING_ATTR_SYMBOL = Symbol("");
var PROXY_PATH_SYMBOL = Symbol("proxy path");
var STALE_REACTION = new class StaleReactionError extends Error {
  name = "StaleReactionError";
  message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
}();
var IS_XHTML = (
  // We gotta write it like this because after downleveling the pure comment may end up in the wrong location
  !!globalThis.document?.contentType && /* @__PURE__ */ globalThis.document.contentType.includes("xml")
);
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_FRAGMENT_NODE = 11;

// node_modules/svelte/src/internal/shared/errors.js
function experimental_async_required(name) {
  if (dev_fallback_default) {
    const error = new Error(`experimental_async_required
Cannot use \`${name}(...)\` unless the \`experimental.async\` compiler option is \`true\`
https://svelte.dev/e/experimental_async_required`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/experimental_async_required`);
  }
}
function invalid_default_snippet() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_default_snippet
Cannot use \`{@render children(...)}\` if the parent component uses \`let:\` directives. Consider using a named snippet instead
https://svelte.dev/e/invalid_default_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_default_snippet`);
  }
}
function invalid_snippet_arguments() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_snippet_arguments
A snippet function was passed invalid arguments. Snippets should only be instantiated via \`{@render ...}\`
https://svelte.dev/e/invalid_snippet_arguments`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet_arguments`);
  }
}
function lifecycle_outside_component(name) {
  if (dev_fallback_default) {
    const error = new Error(`lifecycle_outside_component
\`${name}(...)\` can only be used during component initialisation
https://svelte.dev/e/lifecycle_outside_component`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function missing_context() {
  if (dev_fallback_default) {
    const error = new Error(`missing_context
Context was not set in a parent component
https://svelte.dev/e/missing_context`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/missing_context`);
  }
}
function snippet_without_render_tag() {
  if (dev_fallback_default) {
    const error = new Error(`snippet_without_render_tag
Attempted to render a snippet without a \`{@render}\` block. This would cause the snippet code to be stringified instead of its content being rendered to the DOM. To fix this, change \`{snippet}\` to \`{@render snippet()}\`.
https://svelte.dev/e/snippet_without_render_tag`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/snippet_without_render_tag`);
  }
}
function store_invalid_shape(name) {
  if (dev_fallback_default) {
    const error = new Error(`store_invalid_shape
\`${name}\` is not a store with a \`subscribe\` method
https://svelte.dev/e/store_invalid_shape`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/store_invalid_shape`);
  }
}
function svelte_element_invalid_this_value() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_element_invalid_this_value
The \`this\` prop on \`<svelte:element>\` must be a string, if defined
https://svelte.dev/e/svelte_element_invalid_this_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);
  }
}

// node_modules/svelte/src/internal/client/errors.js
function async_derived_orphan() {
  if (dev_fallback_default) {
    const error = new Error(`async_derived_orphan
Cannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree
https://svelte.dev/e/async_derived_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/async_derived_orphan`);
  }
}
function bind_invalid_checkbox_value() {
  if (dev_fallback_default) {
    const error = new Error(`bind_invalid_checkbox_value
Using \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead
https://svelte.dev/e/bind_invalid_checkbox_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
  }
}
function bind_invalid_export(component2, key2, name) {
  if (dev_fallback_default) {
    const error = new Error(`bind_invalid_export
Component ${component2} has an export named \`${key2}\` that a consumer component is trying to access using \`bind:${key2}\`, which is disallowed. Instead, use \`bind:this\` (e.g. \`<${name} bind:this={component} />\`) and then access the property on the bound component instance (e.g. \`component.${key2}\`)
https://svelte.dev/e/bind_invalid_export`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_invalid_export`);
  }
}
function bind_not_bindable(key2, component2, name) {
  if (dev_fallback_default) {
    const error = new Error(`bind_not_bindable
A component is attempting to bind to a non-bindable property \`${key2}\` belonging to ${component2} (i.e. \`<${name} bind:${key2}={...}>\`). To mark a property as bindable: \`let { ${key2} = $bindable() } = $props()\`
https://svelte.dev/e/bind_not_bindable`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/bind_not_bindable`);
  }
}
function component_api_changed(method, component2) {
  if (dev_fallback_default) {
    const error = new Error(`component_api_changed
Calling \`${method}\` on a component instance (of ${component2}) is no longer valid in Svelte 5
https://svelte.dev/e/component_api_changed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_changed`);
  }
}
function component_api_invalid_new(component2, name) {
  if (dev_fallback_default) {
    const error = new Error(`component_api_invalid_new
Attempted to instantiate ${component2} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.
https://svelte.dev/e/component_api_invalid_new`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
  }
}
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function each_key_duplicate(a, b, value) {
  if (dev_fallback_default) {
    const error = new Error(`each_key_duplicate
${value ? `Keyed each block has duplicate key \`${value}\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}
https://svelte.dev/e/each_key_duplicate`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/each_key_duplicate`);
  }
}
function effect_in_teardown(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_teardown
\`${rune}\` cannot be used inside an effect cleanup function
https://svelte.dev/e/effect_in_teardown`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_teardown`);
  }
}
function effect_in_unowned_derived() {
  if (dev_fallback_default) {
    const error = new Error(`effect_in_unowned_derived
Effect cannot be created inside a \`$derived\` value that was not itself created inside an effect
https://svelte.dev/e/effect_in_unowned_derived`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
  }
}
function effect_orphan(rune) {
  if (dev_fallback_default) {
    const error = new Error(`effect_orphan
\`${rune}\` can only be used inside an effect (e.g. during component initialisation)
https://svelte.dev/e/effect_orphan`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_orphan`);
  }
}
function effect_pending_outside_reaction() {
  if (dev_fallback_default) {
    const error = new Error(`effect_pending_outside_reaction
\`$effect.pending()\` can only be called inside an effect or derived
https://svelte.dev/e/effect_pending_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_pending_outside_reaction`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function flush_sync_in_effect() {
  if (dev_fallback_default) {
    const error = new Error(`flush_sync_in_effect
Cannot use \`flushSync\` inside an effect
https://svelte.dev/e/flush_sync_in_effect`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/flush_sync_in_effect`);
  }
}
function fork_discarded() {
  if (dev_fallback_default) {
    const error = new Error(`fork_discarded
Cannot commit a fork that was already discarded
https://svelte.dev/e/fork_discarded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/fork_discarded`);
  }
}
function fork_timing() {
  if (dev_fallback_default) {
    const error = new Error(`fork_timing
Cannot create a fork inside an effect or when state changes are pending
https://svelte.dev/e/fork_timing`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/fork_timing`);
  }
}
function get_abort_signal_outside_reaction() {
  if (dev_fallback_default) {
    const error = new Error(`get_abort_signal_outside_reaction
\`getAbortSignal()\` can only be called inside an effect or derived
https://svelte.dev/e/get_abort_signal_outside_reaction`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/get_abort_signal_outside_reaction`);
  }
}
function hydratable_missing_but_required(key2) {
  if (dev_fallback_default) {
    const error = new Error(`hydratable_missing_but_required
Expected to find a hydratable with key \`${key2}\` during hydration, but did not.
https://svelte.dev/e/hydratable_missing_but_required`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydratable_missing_but_required`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function invalid_snippet() {
  if (dev_fallback_default) {
    const error = new Error(`invalid_snippet
Could not \`{@render}\` snippet due to the expression being \`null\` or \`undefined\`. Consider using optional chaining \`{@render snippet?.()}\`
https://svelte.dev/e/invalid_snippet`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/invalid_snippet`);
  }
}
function lifecycle_legacy_only(name) {
  if (dev_fallback_default) {
    const error = new Error(`lifecycle_legacy_only
\`${name}(...)\` cannot be used in runes mode
https://svelte.dev/e/lifecycle_legacy_only`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/lifecycle_legacy_only`);
  }
}
function props_invalid_value(key2) {
  if (dev_fallback_default) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key2}={undefined}\` when \`${key2}\` has a fallback value
https://svelte.dev/e/props_invalid_value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_invalid_value`);
  }
}
function props_rest_readonly(property) {
  if (dev_fallback_default) {
    const error = new Error(`props_rest_readonly
Rest element properties of \`$props()\` such as \`${property}\` are readonly
https://svelte.dev/e/props_rest_readonly`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/props_rest_readonly`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function set_context_after_init() {
  if (dev_fallback_default) {
    const error = new Error(`set_context_after_init
\`setContext\` must be called when a component first initializes, not in a subsequent effect or after an \`await\` expression
https://svelte.dev/e/set_context_after_init`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/set_context_after_init`);
  }
}
function state_descriptors_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_descriptors_fixed
Property descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.
https://svelte.dev/e/state_descriptors_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
function state_prototype_fixed() {
  if (dev_fallback_default) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object
https://svelte.dev/e/state_prototype_fixed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
function svelte_boundary_reset_onerror() {
  if (dev_fallback_default) {
    const error = new Error(`svelte_boundary_reset_onerror
A \`<svelte:boundary>\` \`reset\` function cannot be called while an error is still being handled
https://svelte.dev/e/svelte_boundary_reset_onerror`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}

// node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function assignment_value_stale(property, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] assignment_value_stale
%cAssignment to \`${property}\` property (${location}) will evaluate to the right-hand side, not the value of \`${property}\` following the assignment. This may result in unexpected behaviour.
https://svelte.dev/e/assignment_value_stale`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/assignment_value_stale`);
  }
}
function await_reactivity_loss(name) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_reactivity_loss
%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`
https://svelte.dev/e/await_reactivity_loss`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_reactivity_loss`);
  }
}
function await_waterfall(name, location) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] await_waterfall
%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
https://svelte.dev/e/await_waterfall`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/await_waterfall`);
  }
}
function binding_property_non_reactive(binding, location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] binding_property_non_reactive
%c${location ? `\`${binding}\` (${location}) is binding to a non-reactive property` : `\`${binding}\` is binding to a non-reactive property`}
https://svelte.dev/e/binding_property_non_reactive`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/binding_property_non_reactive`);
  }
}
function console_log_state(method) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] console_log_state
%cYour \`console.${method}\` contained \`$state\` proxies. Consider using \`$inspect(...)\` or \`$state.snapshot(...)\` instead
https://svelte.dev/e/console_log_state`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/console_log_state`);
  }
}
function event_handler_invalid(handler, suggestion) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] event_handler_invalid
%c${handler} should be a function. Did you mean to ${suggestion}?
https://svelte.dev/e/event_handler_invalid`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/event_handler_invalid`);
  }
}
function hydratable_missing_but_expected(key2) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydratable_missing_but_expected
%cExpected to find a hydratable with key \`${key2}\` during hydration, but did not.
https://svelte.dev/e/hydratable_missing_but_expected`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydratable_missing_but_expected`);
  }
}
function hydration_attribute_changed(attribute, html2, value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value
https://svelte.dev/e/hydration_attribute_changed`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_attribute_changed`);
  }
}
function hydration_html_changed(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_html_changed
%c${location ? `The value of an \`{@html ...}\` block ${location} changed between server and client renders. The client value will be ignored in favour of the server value` : "The value of an `{@html ...}` block changed between server and client renders. The client value will be ignored in favour of the server value"}
https://svelte.dev/e/hydration_html_changed`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_html_changed`);
  }
}
function hydration_mismatch(location) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`,
      bold,
      normal
    );
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function invalid_raw_snippet_render() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] invalid_raw_snippet_render
%cThe \`render\` function passed to \`createRawSnippet\` should return HTML for a single element
https://svelte.dev/e/invalid_raw_snippet_render`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/invalid_raw_snippet_render`);
  }
}
function legacy_recursive_reactive_block(filename) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] legacy_recursive_reactive_block
%cDetected a migrated \`$:\` reactive block in \`${filename}\` that both accesses and updates the same reactive value. This may cause recursive updates when converted to an \`$effect\`.
https://svelte.dev/e/legacy_recursive_reactive_block`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/legacy_recursive_reactive_block`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function ownership_invalid_binding(parent, prop2, child2, owner) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] ownership_invalid_binding
%c${parent} passed property \`${prop2}\` to ${child2} with \`bind:\`, but its parent component ${owner} did not declare \`${prop2}\` as a binding. Consider creating a binding between ${owner} and ${parent} (e.g. \`bind:${prop2}={...}\` instead of \`${prop2}={...}\`)
https://svelte.dev/e/ownership_invalid_binding`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_binding`);
  }
}
function ownership_invalid_mutation(name, location, prop2, parent) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%cMutating unbound props (\`${name}\`, at ${location}) is strongly discouraged. Consider using \`bind:${prop2}={...}\` in ${parent} (or using a callback) instead
https://svelte.dev/e/ownership_invalid_mutation`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/ownership_invalid_mutation`);
  }
}
function select_multiple_invalid_value() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] select_multiple_invalid_value
%cThe \`value\` property of a \`<select multiple>\` element should be an array, but it received a non-array value. The selection will be kept as is.
https://svelte.dev/e/select_multiple_invalid_value`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/select_multiple_invalid_value`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}
function state_proxy_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_unmount
%cTried to unmount a state proxy, rather than a component
https://svelte.dev/e/state_proxy_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_unmount`);
  }
}
function svelte_boundary_reset_noop() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] svelte_boundary_reset_noop
%cA \`<svelte:boundary>\` \`reset\` function only resets the boundary the first time it is called
https://svelte.dev/e/svelte_boundary_reset_noop`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
function transition_slide_display(value) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] transition_slide_display
%cThe \`slide\` transition does not work correctly for elements with \`display: ${value}\`
https://svelte.dev/e/transition_slide_display`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/transition_slide_display`);
  }
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(get_next_sibling(hydrate_node));
}
function reset(node) {
  if (!hydrating) return;
  if (get_next_sibling(hydrate_node) !== null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  hydrate_node = node;
}
function hydrate_template(template) {
  if (hydrating) {
    hydrate_node = template.content;
  }
}
function next(count = 1) {
  if (hydrating) {
    var i = count;
    var node = hydrate_node;
    while (i--) {
      node = /** @type {TemplateNode} */
      get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE || // "[1", "[2", etc. for if blocks
      data[0] === "[" && !isNaN(Number(data.slice(1)))) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
function read_hydration_instruction(node) {
  if (!node || node.nodeType !== COMMENT_NODE) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return (
    /** @type {Comment} */
    node.data
  );
}

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function not_equal(a, b) {
  return a !== b;
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/internal/flags/index.js
var async_mode_flag = false;
var legacy_mode_flag = false;
var tracing_mode_flag = false;
function enable_async_mode_flag() {
  async_mode_flag = true;
}
function disable_async_mode_flag() {
  async_mode_flag = false;
}
function enable_legacy_mode_flag() {
  legacy_mode_flag = true;
}
function enable_tracing_mode_flag() {
  tracing_mode_flag = true;
}

// node_modules/svelte/src/internal/shared/warnings.js
var bold2 = "font-weight: bold";
var normal2 = "font-weight: normal";
function dynamic_void_element_content(tag2) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag2}">\` is a void element \u2014 it cannot have content
https://svelte.dev/e/dynamic_void_element_content`, bold2, normal2);
  } else {
    console.warn(`https://svelte.dev/e/dynamic_void_element_content`);
  }
}
function state_snapshot_uncloneable(properties) {
  if (dev_fallback_default) {
    console.warn(
      `%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` \u2014 the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` \u2014 the original value was returned"}
https://svelte.dev/e/state_snapshot_uncloneable`,
      bold2,
      normal2
    );
  } else {
    console.warn(`https://svelte.dev/e/state_snapshot_uncloneable`);
  }
}

// node_modules/svelte/src/internal/shared/clone.js
var empty = [];
function snapshot(value, skip_warning = false, no_tojson = false) {
  if (dev_fallback_default && !skip_warning) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths, null, no_tojson);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty, null, no_tojson);
}
function clone(value, cloned, path, paths, original = null, no_tojson = false) {
  if (typeof value === "object" && value !== null) {
    var unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (value instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value)
    );
    if (value instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value)
    );
    if (is_array(value)) {
      var copy = (
        /** @type {Snapshot<any>} */
        Array(value.length)
      );
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var i = 0; i < value.length; i += 1) {
        var element2 = value[i];
        if (i in value) {
          copy[i] = clone(element2, cloned, dev_fallback_default ? `${path}[${i}]` : path, paths, null, no_tojson);
        }
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      copy = {};
      cloned.set(value, copy);
      if (original !== null) {
        cloned.set(original, copy);
      }
      for (var key2 in value) {
        copy[key2] = clone(
          // @ts-expect-error
          value[key2],
          cloned,
          dev_fallback_default ? `${path}.${key2}` : path,
          paths,
          null,
          no_tojson
        );
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function" && !no_tojson) {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        dev_fallback_default ? `${path}.toJSON()` : path,
        paths,
        // Associate the instance with the toJSON clone
        value
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (dev_fallback_default) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}

// node_modules/svelte/src/internal/client/dev/tracing.js
var tracing_expressions = null;
function log_entry(signal, entry) {
  const value = signal.v;
  if (value === UNINITIALIZED) {
    return;
  }
  const type = get_type(signal);
  const current_reaction = (
    /** @type {Reaction} */
    active_reaction
  );
  const dirty = signal.wv > current_reaction.wv || current_reaction.wv === 0;
  const style = dirty ? "color: CornflowerBlue; font-weight: bold" : "color: grey; font-weight: normal";
  console.groupCollapsed(
    signal.label ? `%c${type}%c ${signal.label}` : `%c${type}%c`,
    style,
    dirty ? "font-weight: normal" : style,
    typeof value === "object" && value !== null && STATE_SYMBOL in value ? snapshot(value, true) : value
  );
  if (type === "$derived") {
    const deps = new Set(
      /** @type {Derived} */
      signal.deps
    );
    for (const dep of deps) {
      log_entry(dep);
    }
  }
  if (signal.created) {
    console.log(signal.created);
  }
  if (dirty && signal.updated) {
    for (const updated of signal.updated.values()) {
      if (updated.error) {
        console.log(updated.error);
      }
    }
  }
  if (entry) {
    for (var trace2 of entry.traces) {
      console.log(trace2);
    }
  }
  console.groupEnd();
}
function get_type(signal) {
  if ((signal.f & (DERIVED | ASYNC)) !== 0) return "$derived";
  return signal.label?.startsWith("$") ? "store" : "$state";
}
function trace(label2, fn) {
  var previously_tracing_expressions = tracing_expressions;
  try {
    tracing_expressions = { entries: /* @__PURE__ */ new Map(), reaction: active_reaction };
    var start = performance.now();
    var value = fn();
    var time = (performance.now() - start).toFixed(2);
    var prefix = untrack(label2);
    if (!effect_tracking()) {
      console.log(`${prefix} %cran outside of an effect (${time}ms)`, "color: grey");
    } else if (tracing_expressions.entries.size === 0) {
      console.log(`${prefix} %cno reactive dependencies (${time}ms)`, "color: grey");
    } else {
      console.group(`${prefix} %c(${time}ms)`, "color: grey");
      var entries = tracing_expressions.entries;
      untrack(() => {
        for (const [signal, traces] of entries) {
          log_entry(signal, traces);
        }
      });
      tracing_expressions = null;
      console.groupEnd();
    }
    return value;
  } finally {
    tracing_expressions = previously_tracing_expressions;
  }
}
function tag(source2, label2) {
  source2.label = label2;
  tag_proxy(source2.v, label2);
  return source2;
}
function tag_proxy(value, label2) {
  value?.[PROXY_PATH_SYMBOL]?.(label2);
  return value;
}
function label(value) {
  if (typeof value === "symbol") return `Symbol(${value.description})`;
  if (typeof value === "function") return "<function>";
  if (typeof value === "object" && value) return "<object>";
  return String(value);
}

// node_modules/svelte/src/internal/shared/dev.js
function get_error(label2) {
  const error = new Error();
  const stack2 = get_stack();
  if (stack2.length === 0) {
    return null;
  }
  stack2.unshift("\n");
  define_property(error, "stack", {
    value: stack2.join("\n")
  });
  define_property(error, "name", {
    value: label2
  });
  return (
    /** @type {Error & { stack: string }} */
    error
  );
}
function get_stack() {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = Infinity;
  const stack2 = new Error().stack;
  Error.stackTraceLimit = limit;
  if (!stack2) return [];
  const lines = stack2.split("\n");
  const new_lines = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const posixified = line.replaceAll("\\", "/");
    if (line.trim() === "Error") {
      continue;
    }
    if (line.includes("validate_each_keys")) {
      return [];
    }
    if (posixified.includes("svelte/src/internal") || posixified.includes("node_modules/.vite")) {
      continue;
    }
    new_lines.push(line);
  }
  return new_lines;
}

// node_modules/svelte/src/internal/client/context.js
var component_context = null;
function set_component_context(context) {
  component_context = context;
}
var dev_stack = null;
function set_dev_stack(stack2) {
  dev_stack = stack2;
}
function add_svelte_meta(callback, type, component2, line, column, additional) {
  const parent = dev_stack;
  dev_stack = {
    type,
    file: component2[FILENAME],
    line,
    column,
    parent,
    ...additional
  };
  try {
    return callback();
  } finally {
    dev_stack = parent;
  }
}
var dev_current_component_function = null;
function set_dev_current_component_function(fn) {
  dev_current_component_function = fn;
}
function createContext() {
  const key2 = {};
  return [
    () => {
      if (!hasContext(key2)) {
        missing_context();
      }
      return getContext(key2);
    },
    (context) => setContext(key2, context)
  ];
}
function getContext(key2) {
  const context_map = get_or_init_context_map("getContext");
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext(key2, context) {
  const context_map = get_or_init_context_map("setContext");
  if (async_mode_flag) {
    var flags2 = (
      /** @type {Effect} */
      active_effect.f
    );
    var valid = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && // pop() runs synchronously, so this indicates we're setting context after an await
    !/** @type {ComponentContext} */
    component_context.i;
    if (!valid) {
      set_context_after_init();
    }
  }
  context_map.set(key2, context);
  return context;
}
function hasContext(key2) {
  const context_map = get_or_init_context_map("hasContext");
  return context_map.has(key2);
}
function getAllContexts() {
  const context_map = get_or_init_context_map("getAllContexts");
  return (
    /** @type {T} */
    context_map
  );
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
  };
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var context = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context.e;
  if (effects !== null) {
    context.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  if (component2 !== void 0) {
    context.x = component2;
  }
  context.i = true;
  component_context = context.p;
  if (dev_fallback_default) {
    dev_current_component_function = component_context?.function ?? null;
  }
  return component2 ?? /** @type {T} */
  {};
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
function get_or_init_context_map(name) {
  if (component_context === null) {
    lifecycle_outside_component(name);
  }
  return component_context.c ??= new Map(get_parent_context(component_context) || void 0);
}
function get_parent_context(component_context2) {
  let parent = component_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}

// node_modules/svelte/src/internal/client/dom/task.js
var micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}

// node_modules/svelte/src/internal/client/error-handling.js
var adjustments = /* @__PURE__ */ new WeakMap();
function handle_error(error) {
  var effect2 = active_effect;
  if (effect2 === null) {
    active_reaction.f |= ERROR_VALUE;
    return error;
  }
  if (dev_fallback_default && error instanceof Error && !adjustments.has(error)) {
    adjustments.set(error, get_adjustments(error, effect2));
  }
  if ((effect2.f & REACTION_RAN) === 0 && (effect2.f & EFFECT) === 0) {
    if (dev_fallback_default && !effect2.parent && error instanceof Error) {
      apply_adjustments(error);
    }
    throw error;
  }
  invoke_error_boundary(error, effect2);
}
function invoke_error_boundary(error, effect2) {
  while (effect2 !== null) {
    if ((effect2.f & BOUNDARY_EFFECT) !== 0) {
      if ((effect2.f & REACTION_RAN) === 0) {
        throw error;
      }
      try {
        effect2.b.error(error);
        return;
      } catch (e) {
        error = e;
      }
    }
    effect2 = effect2.parent;
  }
  if (dev_fallback_default && error instanceof Error) {
    apply_adjustments(error);
  }
  throw error;
}
function get_adjustments(error, effect2) {
  const message_descriptor = get_descriptor(error, "message");
  if (message_descriptor && !message_descriptor.configurable) return;
  var indent = is_firefox ? "  " : "	";
  var component_stack = `
${indent}in ${effect2.fn?.name || "<unknown>"}`;
  var context = effect2.ctx;
  while (context !== null) {
    component_stack += `
${indent}in ${context.function?.[FILENAME].split("/").pop()}`;
    context = context.p;
  }
  return {
    message: error.message + `
${component_stack}
`,
    stack: error.stack?.split("\n").filter((line) => !line.includes("svelte/src/internal")).join("\n")
  };
}
function apply_adjustments(error) {
  const adjusted = adjustments.get(error);
  if (adjusted) {
    define_property(error, "message", {
      value: adjusted.message
    });
    define_property(error, "stack", {
      value: adjusted.stack
    });
  }
}

// node_modules/svelte/src/internal/client/reactivity/status.js
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function update_derived_status(derived3) {
  if ((derived3.f & CONNECTED) !== 0 || derived3.deps === null) {
    set_signal_status(derived3, CLEAN);
  } else {
    set_signal_status(derived3, MAYBE_DIRTY);
  }
}

// node_modules/svelte/src/internal/client/reactivity/utils.js
function clear_marked(deps) {
  if (deps === null) return;
  for (const dep of deps) {
    if ((dep.f & DERIVED) === 0 || (dep.f & WAS_MARKED) === 0) {
      continue;
    }
    dep.f ^= WAS_MARKED;
    clear_marked(
      /** @type {Derived} */
      dep.deps
    );
  }
}
function defer_effect(effect2, dirty_effects, maybe_dirty_effects) {
  if ((effect2.f & DIRTY) !== 0) {
    dirty_effects.add(effect2);
  } else if ((effect2.f & MAYBE_DIRTY) !== 0) {
    maybe_dirty_effects.add(effect2);
  }
  clear_marked(effect2.deps);
  set_signal_status(effect2, CLEAN);
}

// node_modules/svelte/src/internal/client/reactivity/batch.js
var batches = /* @__PURE__ */ new Set();
var current_batch = null;
var previous_batch = null;
var batch_values = null;
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;
var Batch = class _Batch {
  committed = false;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #commit_callbacks = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #discard_callbacks = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #pending = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #blocking_pending = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #deferred = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Set<Effect>}
   */
  #dirty_effects = /* @__PURE__ */ new Set();
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Set<Effect>}
   */
  #maybe_dirty_effects = /* @__PURE__ */ new Set();
  /**
   * A map of branches that still exist, but will be destroyed when this batch
   * is committed — we skip over these during `process`.
   * The value contains child effects that were dirty/maybe_dirty before being reset,
   * so they can be rescheduled if the branch survives.
   * @type {Map<Effect, { d: Effect[], m: Effect[] }>}
   */
  #skipped_branches = /* @__PURE__ */ new Map();
  is_fork = false;
  #decrement_queued = false;
  is_deferred() {
    return this.is_fork || this.#blocking_pending > 0;
  }
  /**
   * Add an effect to the #skipped_branches map and reset its children
   * @param {Effect} effect
   */
  skip_effect(effect2) {
    if (!this.#skipped_branches.has(effect2)) {
      this.#skipped_branches.set(effect2, { d: [], m: [] });
    }
  }
  /**
   * Remove an effect from the #skipped_branches map and reschedule
   * any tracked dirty/maybe_dirty child effects
   * @param {Effect} effect
   */
  unskip_effect(effect2) {
    var tracked = this.#skipped_branches.get(effect2);
    if (tracked) {
      this.#skipped_branches.delete(effect2);
      for (var e of tracked.d) {
        set_signal_status(e, DIRTY);
        schedule_effect(e);
      }
      for (e of tracked.m) {
        set_signal_status(e, MAYBE_DIRTY);
        schedule_effect(e);
      }
    }
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    queued_root_effects = [];
    this.apply();
    var effects = [];
    var render_effects = [];
    for (const root5 of root_effects) {
      this.#traverse_effect_tree(root5, effects, render_effects);
    }
    if (this.is_deferred()) {
      this.#defer_effects(render_effects);
      this.#defer_effects(effects);
      for (const [e, t] of this.#skipped_branches) {
        reset_branch(e, t);
      }
    } else {
      for (const fn of this.#commit_callbacks) fn();
      this.#commit_callbacks.clear();
      if (this.#pending === 0) {
        this.#commit();
      }
      previous_batch = this;
      current_batch = null;
      flush_queued_effects(render_effects);
      flush_queued_effects(effects);
      previous_batch = null;
      this.#deferred?.resolve();
    }
    batch_values = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {Effect[]} effects
   * @param {Effect[]} render_effects
   */
  #traverse_effect_tree(root5, effects, render_effects) {
    root5.f ^= CLEAN;
    var effect2 = root5.first;
    var pending_boundary = null;
    while (effect2 !== null) {
      var flags2 = effect2.f;
      var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
      var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
      var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.#skipped_branches.has(effect2);
      if (async_mode_flag && pending_boundary === null && (flags2 & BOUNDARY_EFFECT) !== 0 && effect2.b?.is_pending) {
        pending_boundary = effect2;
      }
      if (!skip && effect2.fn !== null) {
        if (is_branch) {
          effect2.f ^= CLEAN;
        } else if (pending_boundary !== null && (flags2 & (EFFECT | RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
          pending_boundary.b.defer_effect(effect2);
        } else if ((flags2 & EFFECT) !== 0) {
          effects.push(effect2);
        } else if (async_mode_flag && (flags2 & (RENDER_EFFECT | MANAGED_EFFECT)) !== 0) {
          render_effects.push(effect2);
        } else if (is_dirty(effect2)) {
          if ((flags2 & BLOCK_EFFECT) !== 0) this.#maybe_dirty_effects.add(effect2);
          update_effect(effect2);
        }
        var child2 = effect2.first;
        if (child2 !== null) {
          effect2 = child2;
          continue;
        }
      }
      while (effect2 !== null) {
        if (effect2 === pending_boundary) {
          pending_boundary = null;
        }
        var next2 = effect2.next;
        if (next2 !== null) {
          effect2 = next2;
          break;
        }
        effect2 = effect2.parent;
      }
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #defer_effects(effects) {
    for (var i = 0; i < effects.length; i += 1) {
      defer_effect(effects[i], this.#dirty_effects, this.#maybe_dirty_effects);
    }
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (value !== UNINITIALIZED && !this.previous.has(source2)) {
      this.previous.set(source2, value);
    }
    if ((source2.f & ERROR_VALUE) === 0) {
      this.current.set(source2, source2.v);
      batch_values?.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    if (current_batch !== this) return;
    current_batch = null;
    batch_values = null;
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (this.#pending === 0) {
      this.process([]);
    }
    this.deactivate();
  }
  discard() {
    for (const fn of this.#discard_callbacks) fn(this);
    this.#discard_callbacks.clear();
  }
  #commit() {
    if (batches.size > 1) {
      this.previous.clear();
      var previous_batch_values = batch_values;
      var is_earlier = true;
      for (const batch of batches) {
        if (batch === this) {
          is_earlier = false;
          continue;
        }
        const sources = [];
        for (const [source2, value] of this.current) {
          if (batch.current.has(source2)) {
            if (is_earlier && value !== batch.current.get(source2)) {
              batch.current.set(source2, value);
            } else {
              continue;
            }
          }
          sources.push(source2);
        }
        if (sources.length === 0) {
          continue;
        }
        const others = [...batch.current.keys()].filter((s) => !this.current.has(s));
        if (others.length > 0) {
          var prev_queued_root_effects = queued_root_effects;
          queued_root_effects = [];
          const marked = /* @__PURE__ */ new Set();
          const checked = /* @__PURE__ */ new Map();
          for (const source2 of sources) {
            mark_effects(source2, others, marked, checked);
          }
          if (queued_root_effects.length > 0) {
            current_batch = batch;
            batch.apply();
            for (const root5 of queued_root_effects) {
              batch.#traverse_effect_tree(root5, [], []);
            }
            batch.deactivate();
          }
          queued_root_effects = prev_queued_root_effects;
        }
      }
      current_batch = null;
      batch_values = previous_batch_values;
    }
    this.committed = true;
    batches.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(blocking) {
    this.#pending += 1;
    if (blocking) this.#blocking_pending += 1;
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(blocking) {
    this.#pending -= 1;
    if (blocking) this.#blocking_pending -= 1;
    if (this.#decrement_queued) return;
    this.#decrement_queued = true;
    queue_micro_task(() => {
      this.#decrement_queued = false;
      if (!this.is_deferred()) {
        this.revive();
      } else if (queued_root_effects.length > 0) {
        this.flush();
      }
    });
  }
  revive() {
    for (const e of this.#dirty_effects) {
      this.#maybe_dirty_effects.delete(e);
      set_signal_status(e, DIRTY);
      schedule_effect(e);
    }
    for (const e of this.#maybe_dirty_effects) {
      set_signal_status(e, MAYBE_DIRTY);
      schedule_effect(e);
    }
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(fn) {
    this.#commit_callbacks.add(fn);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(fn) {
    this.#discard_callbacks.add(fn);
  }
  settled() {
    return (this.#deferred ??= deferred()).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        queue_micro_task(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  apply() {
    if (!async_mode_flag || !this.is_fork && batches.size === 1) return;
    batch_values = new Map(this.current);
    for (const batch of batches) {
      if (batch === this) continue;
      for (const [source2, previous] of batch.previous) {
        if (!batch_values.has(source2)) {
          batch_values.set(source2, previous);
        }
      }
    }
  }
};
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) {
      if (current_batch !== null) {
        flush_effects();
      }
      result = fn();
    }
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
function flush_effects() {
  is_flushing = true;
  var source_stacks = dev_fallback_default ? /* @__PURE__ */ new Set() : null;
  try {
    var flush_count = 0;
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        if (dev_fallback_default) {
          var updates = /* @__PURE__ */ new Map();
          for (const source2 of batch.current.keys()) {
            for (const [stack2, update2] of source2.updated ?? []) {
              var entry = updates.get(stack2);
              if (!entry) {
                entry = { error: update2.error, count: 0 };
                updates.set(stack2, entry);
              }
              entry.count += update2.count;
            }
          }
          for (const update2 of updates.values()) {
            if (update2.error) {
              console.error(update2.error);
            }
          }
        }
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
      if (dev_fallback_default) {
        for (const source2 of batch.current.keys()) {
          source_stacks.add(source2);
        }
      }
    }
  } finally {
    queued_root_effects = [];
    is_flushing = false;
    last_scheduled_effect = null;
    if (dev_fallback_default) {
      for (
        const source2 of
        /** @type {Set<Source>} */
        source_stacks
      ) {
        source2.updated = null;
      }
    }
  }
}
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error) {
    if (dev_fallback_default) {
      define_property(error, "stack", { value: "" });
    }
    invoke_error_boundary(error, last_scheduled_effect);
  }
}
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i = 0;
  while (i < length) {
    var effect2 = effects[i++];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && is_dirty(effect2)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.nodes === null && effect2.teardown === null && effect2.ac === null) {
        unlink_effect(effect2);
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e of eager_block_effects) {
          if ((e.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e];
          let ancestor = e.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e2 = ordered_effects[j];
            if ((e2.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e2);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
function mark_effects(value, sources, marked, checked) {
  if (marked.has(value)) return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && depends_on(reaction, sources, checked)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
function mark_eager_effects(value, effects) {
  if (value.reactions === null) return;
  for (const reaction of value.reactions) {
    const flags2 = reaction.f;
    if ((flags2 & DERIVED) !== 0) {
      mark_eager_effects(
        /** @type {Derived} */
        reaction,
        effects
      );
    } else if ((flags2 & EAGER_EFFECT) !== 0) {
      set_signal_status(reaction, DIRTY);
      effects.add(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function depends_on(reaction, sources, checked) {
  const depends = checked.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (includes.call(sources, dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked
      )) {
        checked.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked.set(reaction, false);
  return false;
}
function schedule_effect(signal) {
  var effect2 = last_scheduled_effect = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags2 = effect2.f;
    if (is_flushing && effect2 === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
var eager_versions = [];
function eager_flush() {
  try {
    flushSync(() => {
      for (const version of eager_versions) {
        update(version);
      }
    });
  } finally {
    eager_versions = [];
  }
}
function eager(fn) {
  var version = source(0);
  var initial = true;
  var value = (
    /** @type {T} */
    void 0
  );
  get(version);
  eager_effect(() => {
    if (initial) {
      var previous_batch_values = batch_values;
      try {
        batch_values = null;
        value = fn();
      } finally {
        batch_values = previous_batch_values;
      }
      return;
    }
    if (eager_versions.length === 0) {
      queue_micro_task(eager_flush);
    }
    eager_versions.push(version);
  });
  initial = false;
  return value;
}
function reset_branch(effect2, tracked) {
  if ((effect2.f & BRANCH_EFFECT) !== 0 && (effect2.f & CLEAN) !== 0) {
    return;
  }
  if ((effect2.f & DIRTY) !== 0) {
    tracked.d.push(effect2);
  } else if ((effect2.f & MAYBE_DIRTY) !== 0) {
    tracked.m.push(effect2);
  }
  set_signal_status(effect2, CLEAN);
  var e = effect2.first;
  while (e !== null) {
    reset_branch(e, tracked);
    e = e.next;
  }
}
function fork(fn) {
  if (!async_mode_flag) {
    experimental_async_required("fork");
  }
  if (current_batch !== null) {
    fork_timing();
  }
  var batch = Batch.ensure();
  batch.is_fork = true;
  batch_values = /* @__PURE__ */ new Map();
  var committed = false;
  var settled2 = batch.settled();
  flushSync(fn);
  for (var [source2, value] of batch.previous) {
    source2.v = value;
  }
  for (source2 of batch.current.keys()) {
    if ((source2.f & DERIVED) !== 0) {
      set_signal_status(source2, DIRTY);
    }
  }
  return {
    commit: async () => {
      if (committed) {
        await settled2;
        return;
      }
      if (!batches.has(batch)) {
        fork_discarded();
      }
      committed = true;
      batch.is_fork = false;
      for (var [source3, value2] of batch.current) {
        source3.v = value2;
        source3.wv = increment_write_version();
      }
      flushSync(() => {
        var eager_effects2 = /* @__PURE__ */ new Set();
        for (var source4 of batch.current.keys()) {
          mark_eager_effects(source4, eager_effects2);
        }
        set_eager_effects(eager_effects2);
        flush_eager_effects();
      });
      batch.revive();
      await settled2;
    },
    discard: () => {
      for (var source3 of batch.current.keys()) {
        source3.wv = increment_write_version();
      }
      if (!committed && batches.has(batch)) {
        batches.delete(batch);
        batch.discard();
      }
    }
  };
}
function clear() {
  batches.clear();
}

// node_modules/svelte/src/reactivity/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let version = source(0);
  let stop;
  if (dev_fallback_default) {
    tag(version, "createSubscriber version");
  }
  return () => {
    if (effect_tracking()) {
      get(version);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version);
            }
          });
        };
      });
    }
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/boundary.js
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
var Boundary = class {
  /** @type {Boundary | null} */
  parent;
  is_pending = false;
  /** @type {TemplateNode} */
  #anchor;
  /** @type {TemplateNode | null} */
  #hydrate_open = hydrating ? hydrate_node : null;
  /** @type {BoundaryProps} */
  #props;
  /** @type {((anchor: Node) => void)} */
  #children;
  /** @type {Effect} */
  #effect;
  /** @type {Effect | null} */
  #main_effect = null;
  /** @type {Effect | null} */
  #pending_effect = null;
  /** @type {Effect | null} */
  #failed_effect = null;
  /** @type {DocumentFragment | null} */
  #offscreen_fragment = null;
  #local_pending_count = 0;
  #pending_count = 0;
  #pending_count_update_queued = false;
  /** @type {Set<Effect>} */
  #dirty_effects = /* @__PURE__ */ new Set();
  /** @type {Set<Effect>} */
  #maybe_dirty_effects = /* @__PURE__ */ new Set();
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #effect_pending = null;
  #effect_pending_subscriber = createSubscriber(() => {
    this.#effect_pending = source(this.#local_pending_count);
    if (dev_fallback_default) {
      tag(this.#effect_pending, "$effect.pending()");
    }
    return () => {
      this.#effect_pending = null;
    };
  });
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    this.#anchor = node;
    this.#props = props;
    this.#children = (anchor) => {
      var effect2 = (
        /** @type {Effect} */
        active_effect
      );
      effect2.b = this;
      effect2.f |= BOUNDARY_EFFECT;
      children(anchor);
    };
    this.parent = /** @type {Effect} */
    active_effect.b;
    this.#effect = block(() => {
      if (hydrating) {
        const comment2 = (
          /** @type {Comment} */
          this.#hydrate_open
        );
        hydrate_next();
        if (comment2.data === HYDRATION_START_ELSE) {
          this.#hydrate_pending_content();
        } else {
          this.#hydrate_resolved_content();
        }
      } else {
        this.#render();
      }
    }, flags);
    if (hydrating) {
      this.#anchor = hydrate_node;
    }
  }
  #hydrate_resolved_content() {
    try {
      this.#main_effect = branch(() => this.#children(this.#anchor));
    } catch (error) {
      this.error(error);
    }
  }
  #hydrate_pending_content() {
    const pending3 = this.#props.pending;
    if (!pending3) return;
    this.is_pending = true;
    this.#pending_effect = branch(() => pending3(this.#anchor));
    queue_micro_task(() => {
      var fragment = this.#offscreen_fragment = document.createDocumentFragment();
      var anchor = create_text();
      fragment.append(anchor);
      this.#main_effect = this.#run(() => {
        Batch.ensure();
        return branch(() => this.#children(anchor));
      });
      if (this.#pending_count === 0) {
        this.#anchor.before(fragment);
        this.#offscreen_fragment = null;
        pause_effect(
          /** @type {Effect} */
          this.#pending_effect,
          () => {
            this.#pending_effect = null;
          }
        );
        this.is_pending = false;
      }
    });
  }
  #render() {
    try {
      this.is_pending = this.has_pending_snippet();
      this.#pending_count = 0;
      this.#local_pending_count = 0;
      this.#main_effect = branch(() => {
        this.#children(this.#anchor);
      });
      if (this.#pending_count > 0) {
        var fragment = this.#offscreen_fragment = document.createDocumentFragment();
        move_effect(this.#main_effect, fragment);
        const pending3 = (
          /** @type {(anchor: Node) => void} */
          this.#props.pending
        );
        this.#pending_effect = branch(() => pending3(this.#anchor));
      } else {
        this.is_pending = false;
      }
    } catch (error) {
      this.error(error);
    }
  }
  /**
   * Defer an effect inside a pending boundary until the boundary resolves
   * @param {Effect} effect
   */
  defer_effect(effect2) {
    defer_effect(effect2, this.#dirty_effects, this.#maybe_dirty_effects);
  }
  /**
   * Returns `false` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_rendered() {
    return !this.is_pending && (!this.parent || this.parent.is_rendered());
  }
  has_pending_snippet() {
    return !!this.#props.pending;
  }
  /**
   * @template T
   * @param {() => T} fn
   */
  #run(fn) {
    var previous_effect = active_effect;
    var previous_reaction = active_reaction;
    var previous_ctx = component_context;
    set_active_effect(this.#effect);
    set_active_reaction(this.#effect);
    set_component_context(this.#effect.ctx);
    try {
      return fn();
    } catch (e) {
      handle_error(e);
      return null;
    } finally {
      set_active_effect(previous_effect);
      set_active_reaction(previous_reaction);
      set_component_context(previous_ctx);
    }
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #update_pending_count(d) {
    if (!this.has_pending_snippet()) {
      if (this.parent) {
        this.parent.#update_pending_count(d);
      }
      return;
    }
    this.#pending_count += d;
    if (this.#pending_count === 0) {
      this.is_pending = false;
      for (const e of this.#dirty_effects) {
        set_signal_status(e, DIRTY);
        schedule_effect(e);
      }
      for (const e of this.#maybe_dirty_effects) {
        set_signal_status(e, MAYBE_DIRTY);
        schedule_effect(e);
      }
      this.#dirty_effects.clear();
      this.#maybe_dirty_effects.clear();
      if (this.#pending_effect) {
        pause_effect(this.#pending_effect, () => {
          this.#pending_effect = null;
        });
      }
      if (this.#offscreen_fragment) {
        this.#anchor.before(this.#offscreen_fragment);
        this.#offscreen_fragment = null;
      }
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    this.#update_pending_count(d);
    this.#local_pending_count += d;
    if (!this.#effect_pending || this.#pending_count_update_queued) return;
    this.#pending_count_update_queued = true;
    queue_micro_task(() => {
      this.#pending_count_update_queued = false;
      if (this.#effect_pending) {
        internal_set(this.#effect_pending, this.#local_pending_count);
      }
    });
  }
  get_effect_pending() {
    this.#effect_pending_subscriber();
    return get(
      /** @type {Source<number>} */
      this.#effect_pending
    );
  }
  /** @param {unknown} error */
  error(error) {
    var onerror = this.#props.onerror;
    let failed = this.#props.failed;
    if (!onerror && !failed) {
      throw error;
    }
    if (this.#main_effect) {
      destroy_effect(this.#main_effect);
      this.#main_effect = null;
    }
    if (this.#pending_effect) {
      destroy_effect(this.#pending_effect);
      this.#pending_effect = null;
    }
    if (this.#failed_effect) {
      destroy_effect(this.#failed_effect);
      this.#failed_effect = null;
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        this.#hydrate_open
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = () => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      if (this.#failed_effect !== null) {
        pause_effect(this.#failed_effect, () => {
          this.#failed_effect = null;
        });
      }
      this.#run(() => {
        Batch.ensure();
        this.#render();
      });
    };
    queue_micro_task(() => {
      try {
        calling_on_error = true;
        onerror?.(error, reset2);
        calling_on_error = false;
      } catch (error2) {
        invoke_error_boundary(error2, this.#effect && this.#effect.parent);
      }
      if (failed) {
        this.#failed_effect = this.#run(() => {
          Batch.ensure();
          try {
            return branch(() => {
              var effect2 = (
                /** @type {Effect} */
                active_effect
              );
              effect2.b = this;
              effect2.f |= BOUNDARY_EFFECT;
              failed(
                this.#anchor,
                () => error,
                () => reset2
              );
            });
          } catch (error2) {
            invoke_error_boundary(
              error2,
              /** @type {Effect} */
              this.#effect.parent
            );
            return null;
          }
        });
      }
    });
  }
};
function get_boundary() {
  return (
    /** @type {Boundary} */
    /** @type {Effect} */
    active_effect.b
  );
}
function pending() {
  if (active_effect === null) {
    effect_pending_outside_reaction();
  }
  var boundary2 = active_effect.b;
  if (boundary2 === null) {
    return 0;
  }
  return boundary2.get_effect_pending();
}

// node_modules/svelte/src/internal/client/reactivity/async.js
function flatten(blockers, sync, async2, fn) {
  const d = is_runes() ? derived : derived_safe_equal;
  var pending3 = blockers.filter((b) => !b.settled);
  if (async2.length === 0 && pending3.length === 0) {
    fn(sync.map(d));
    return;
  }
  var batch = current_batch;
  var parent = (
    /** @type {Effect} */
    active_effect
  );
  var restore = capture();
  var blocker_promise = pending3.length === 1 ? pending3[0].promise : pending3.length > 1 ? Promise.all(pending3.map((b) => b.promise)) : null;
  function finish(values) {
    restore();
    try {
      fn(values);
    } catch (error) {
      if ((parent.f & DESTROYED) === 0) {
        invoke_error_boundary(error, parent);
      }
    }
    batch?.deactivate();
    unset_context();
  }
  if (async2.length === 0) {
    blocker_promise.then(() => finish(sync.map(d)));
    return;
  }
  function run4() {
    restore();
    Promise.all(async2.map((expression) => async_derived(expression))).then((result) => finish([...sync.map(d), ...result])).catch((error) => invoke_error_boundary(error, parent));
  }
  if (blocker_promise) {
    blocker_promise.then(run4);
  } else {
    run4();
  }
}
function run_after_blockers(blockers, fn) {
  flatten(blockers, [], [], fn);
}
function capture() {
  var previous_effect = active_effect;
  var previous_reaction = active_reaction;
  var previous_component_context = component_context;
  var previous_batch2 = current_batch;
  if (dev_fallback_default) {
    var previous_dev_stack = dev_stack;
  }
  return function restore(activate_batch = true) {
    set_active_effect(previous_effect);
    set_active_reaction(previous_reaction);
    set_component_context(previous_component_context);
    if (activate_batch) previous_batch2?.activate();
    if (dev_fallback_default) {
      set_from_async_derived(null);
      set_dev_stack(previous_dev_stack);
    }
  };
}
async function save(promise) {
  var restore = capture();
  var value = await promise;
  return () => {
    restore();
    return value;
  };
}
async function track_reactivity_loss(promise) {
  var previous_async_effect = current_async_effect;
  var value = await promise;
  return () => {
    set_from_async_derived(previous_async_effect);
    return value;
  };
}
async function* for_await_track_reactivity_loss(iterable) {
  const iterator = iterable[Symbol.asyncIterator]?.() ?? iterable[Symbol.iterator]?.();
  if (iterator === void 0) {
    throw new TypeError("value is not async iterable");
  }
  let normal_completion = false;
  try {
    while (true) {
      const { done, value } = (await track_reactivity_loss(iterator.next()))();
      if (done) {
        normal_completion = true;
        break;
      }
      yield value;
    }
  } finally {
    if (normal_completion && iterator.return !== void 0) {
      return (
        /** @type {TReturn} */
        (await track_reactivity_loss(iterator.return()))().value
      );
    }
  }
}
function unset_context() {
  set_active_effect(null);
  set_active_reaction(null);
  set_component_context(null);
  if (dev_fallback_default) {
    set_from_async_derived(null);
    set_dev_stack(null);
  }
}
function run2(thunks) {
  const restore = capture();
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = boundary2.is_rendered();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  var active = (
    /** @type {Effect} */
    active_effect
  );
  var errored = null;
  const handle_error2 = (error) => {
    errored = { error };
    if (!aborted(active)) {
      invoke_error_boundary(error, active);
    }
  };
  var promise = Promise.resolve(thunks[0]()).catch(handle_error2);
  var blocker = { promise, settled: false };
  var blockers = [blocker];
  promise.finally(() => {
    blocker.settled = true;
  });
  for (const fn of thunks.slice(1)) {
    promise = promise.then(() => {
      if (errored) {
        throw errored.error;
      }
      if (aborted(active)) {
        throw STALE_REACTION;
      }
      restore();
      return fn();
    }).catch(handle_error2);
    const blocker2 = { promise, settled: false };
    blockers.push(blocker2);
    promise.finally(() => {
      blocker2.settled = true;
      unset_context();
      current_batch?.deactivate();
    });
  }
  promise.then(() => Promise.resolve()).finally(() => {
    boundary2.update_pending_count(-1);
    batch.decrement(blocking);
  });
  return blockers;
}
function wait(blockers) {
  return Promise.all(blockers.map((b) => b.promise));
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var current_async_effect = null;
function set_from_async_derived(v) {
  current_async_effect = v;
}
var recent_async_deriveds = /* @__PURE__ */ new Set();
// @__NO_SIDE_EFFECTS__
function derived(fn) {
  var flags2 = DERIVED | DIRTY;
  var parent_derived = active_reaction !== null && (active_reaction.f & DERIVED) !== 0 ? (
    /** @type {Derived} */
    active_reaction
  ) : null;
  if (active_effect !== null) {
    active_effect.f |= EFFECT_PRESERVED;
  }
  const signal = {
    ctx: component_context,
    deps: null,
    effects: null,
    equals,
    f: flags2,
    fn,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      UNINITIALIZED
    ),
    wv: 0,
    parent: parent_derived ?? active_effect,
    ac: null
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = get_error("created at");
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function async_derived(fn, label2, location) {
  let parent = (
    /** @type {Effect | null} */
    active_effect
  );
  if (parent === null) {
    async_derived_orphan();
  }
  var boundary2 = (
    /** @type {Boundary} */
    parent.b
  );
  var promise = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  );
  var signal = source(
    /** @type {V} */
    UNINITIALIZED
  );
  if (dev_fallback_default) signal.label = label2;
  var should_suspend = !active_reaction;
  var deferreds = /* @__PURE__ */ new Map();
  async_effect(() => {
    if (dev_fallback_default) current_async_effect = active_effect;
    var d = deferred();
    promise = d.promise;
    try {
      Promise.resolve(fn()).then(d.resolve, d.reject).then(() => {
        if (batch === current_batch && batch.committed) {
          batch.deactivate();
        }
        unset_context();
      });
    } catch (error) {
      d.reject(error);
      unset_context();
    }
    if (dev_fallback_default) current_async_effect = null;
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    if (should_suspend) {
      var blocking = boundary2.is_rendered();
      boundary2.update_pending_count(1);
      batch.increment(blocking);
      deferreds.get(batch)?.reject(STALE_REACTION);
      deferreds.delete(batch);
      deferreds.set(batch, d);
    }
    const handler = (value, error = void 0) => {
      current_async_effect = null;
      batch.activate();
      if (error) {
        if (error !== STALE_REACTION) {
          signal.f |= ERROR_VALUE;
          internal_set(signal, error);
        }
      } else {
        if ((signal.f & ERROR_VALUE) !== 0) {
          signal.f ^= ERROR_VALUE;
        }
        internal_set(signal, value);
        for (const [b, d2] of deferreds) {
          deferreds.delete(b);
          if (b === batch) break;
          d2.reject(STALE_REACTION);
        }
        if (dev_fallback_default && location !== void 0) {
          recent_async_deriveds.add(signal);
          setTimeout(() => {
            if (recent_async_deriveds.has(signal)) {
              await_waterfall(
                /** @type {string} */
                signal.label,
                location
              );
              recent_async_deriveds.delete(signal);
            }
          });
        }
      }
      if (should_suspend) {
        boundary2.update_pending_count(-1);
        batch.decrement(blocking);
      }
    };
    d.promise.then(handler, (e) => handler(null, e || "unknown"));
  });
  teardown(() => {
    for (const d of deferreds.values()) {
      d.reject(STALE_REACTION);
    }
  });
  if (dev_fallback_default) {
    signal.f |= ASYNC;
  }
  return new Promise((fulfil) => {
    function next2(p) {
      function go() {
        if (p === promise) {
          fulfil(signal);
        } else {
          next2(promise);
        }
      }
      p.then(go, go);
    }
    next2(promise);
  });
}
// @__NO_SIDE_EFFECTS__
function user_derived(fn) {
  const d = /* @__PURE__ */ derived(fn);
  if (!async_mode_flag) push_reaction_value(d);
  return d;
}
// @__NO_SIDE_EFFECTS__
function derived_safe_equal(fn) {
  const signal = /* @__PURE__ */ derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_effects(derived3) {
  var effects = derived3.effects;
  if (effects !== null) {
    derived3.effects = null;
    for (var i = 0; i < effects.length; i += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i]
      );
    }
  }
}
var stack = [];
function get_derived_parent_effect(derived3) {
  var parent = derived3.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (parent.f & DESTROYED) === 0 ? (
        /** @type {Effect} */
        parent
      ) : null;
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived3) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived3));
  if (dev_fallback_default) {
    let prev_eager_effects = eager_effects;
    set_eager_effects(/* @__PURE__ */ new Set());
    try {
      if (includes.call(stack, derived3)) {
        derived_references_self();
      }
      stack.push(derived3);
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
      set_eager_effects(prev_eager_effects);
      stack.pop();
    }
  } else {
    try {
      derived3.f &= ~WAS_MARKED;
      destroy_derived_effects(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived3) {
  var value = execute_derived(derived3);
  if (!derived3.equals(value)) {
    derived3.wv = increment_write_version();
    if (!current_batch?.is_fork || derived3.deps === null) {
      derived3.v = value;
      if (derived3.deps === null) {
        set_signal_status(derived3, CLEAN);
        return;
      }
    }
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking() || current_batch?.is_fork) {
      batch_values.set(derived3, value);
    }
  } else {
    update_derived_status(derived3);
  }
}
function freeze_derived_effects(derived3) {
  if (derived3.effects === null) return;
  for (const e of derived3.effects) {
    if (e.teardown || e.ac) {
      e.teardown?.();
      e.ac?.abort(STALE_REACTION);
      e.teardown = noop;
      e.ac = null;
      remove_reactions(e, 0);
      destroy_effect_children(e);
    }
  }
}
function unfreeze_derived_effects(derived3) {
  if (derived3.effects === null) return;
  for (const e of derived3.effects) {
    if (e.teardown) {
      update_effect(e);
    }
  }
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
var eager_effects = /* @__PURE__ */ new Set();
var old_values = /* @__PURE__ */ new Map();
function set_eager_effects(v) {
  eager_effects = v;
}
var eager_effects_deferred = false;
function set_eager_effects_deferred() {
  eager_effects_deferred = true;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_error("created at");
    signal.updated = null;
    signal.set_during_effect = false;
    signal.trace = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function state(v, stack2) {
  const s = source(v, stack2);
  push_reaction_value(s);
  return s;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false, trackable = true) {
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s);
  }
  return s;
}
function mutate(source2, value) {
  set2(
    source2,
    untrack(() => get(source2))
  );
  return value;
}
function set2(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && (current_sources === null || !includes.call(current_sources, source2))) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  if (dev_fallback_default) {
    tag_proxy(
      new_value,
      /** @type {string} */
      source2.label
    );
  }
  return internal_set(source2, new_value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if (dev_fallback_default) {
      if (tracing_mode_flag || active_effect !== null) {
        source2.updated ??= /* @__PURE__ */ new Map();
        const count = (source2.updated.get("")?.count ?? 0) + 1;
        source2.updated.set("", { error: (
          /** @type {any} */
          null
        ), count });
        if (tracing_mode_flag || count > 5) {
          const error = get_error("updated at");
          if (error !== null) {
            let entry = source2.updated.get(error.stack);
            if (!entry) {
              entry = { error, count: 0 };
              source2.updated.set(error.stack, entry);
            }
            entry.count++;
          }
        }
      }
      if (active_effect !== null) {
        source2.set_during_effect = true;
      }
    }
    if ((source2.f & DERIVED) !== 0) {
      const derived3 = (
        /** @type {Derived} */
        source2
      );
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(derived3);
      }
      update_derived_status(derived3);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
function flush_eager_effects() {
  eager_effects_deferred = false;
  for (const effect2 of eager_effects) {
    if ((effect2.f & CLEAN) !== 0) {
      set_signal_status(effect2, MAYBE_DIRTY);
    }
    if (is_dirty(effect2)) {
      update_effect(effect2);
    }
  }
  eager_effects.clear();
}
function update(source2, d = 1) {
  var value = get(source2);
  var result = d === 1 ? value++ : value--;
  set2(source2, value);
  return result;
}
function update_pre(source2, d = 1) {
  var value = get(source2);
  return set2(source2, d === 1 ? ++value : --value);
}
function increment(source2) {
  set2(source2, source2.v + 1);
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags2 = reaction.f;
    if (!runes && reaction === active_effect) continue;
    if (dev_fallback_default && (flags2 & EAGER_EFFECT) !== 0) {
      eager_effects.add(reaction);
      continue;
    }
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived3 = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived3);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived3, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0 && eager_block_effects !== null) {
        eager_block_effects.add(
          /** @type {Effect} */
          reaction
        );
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}

// node_modules/svelte/src/internal/client/proxy.js
var regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version = state(0);
  var stack2 = dev_fallback_default && tracing_mode_flag ? get_error("created at") : null;
  var parent_version = update_version;
  var with_parent = (fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version2 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version2);
    return result;
  };
  if (is_proxied_array) {
    sources.set("length", state(
      /** @type {any[]} */
      value.length,
      stack2
    ));
    if (dev_fallback_default) {
      value = /** @type {any} */
      inspectable_array(
        /** @type {any[]} */
        value
      );
    }
  }
  var path = "";
  let updating = false;
  function update_path(new_path) {
    if (updating) return;
    updating = true;
    path = new_path;
    tag(version, `${path} version`);
    for (const [prop2, source2] of sources) {
      tag(source2, get_label(path, prop2));
    }
    updating = false;
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_, prop2, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s = sources.get(prop2);
        if (s === void 0) {
          with_parent(() => {
            var s2 = state(descriptor.value, stack2);
            sources.set(prop2, s2);
            if (dev_fallback_default && typeof prop2 === "string") {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
        } else {
          set2(s, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop2) {
        var s = sources.get(prop2);
        if (s === void 0) {
          if (prop2 in target) {
            const s2 = with_parent(() => state(UNINITIALIZED, stack2));
            sources.set(prop2, s2);
            increment(version);
            if (dev_fallback_default) {
              tag(s2, get_label(path, prop2));
            }
          }
        } else {
          set2(s, UNINITIALIZED);
          increment(version);
        }
        return true;
      },
      get(target, prop2, receiver) {
        if (prop2 === STATE_SYMBOL) {
          return value;
        }
        if (dev_fallback_default && prop2 === PROXY_PATH_SYMBOL) {
          return update_path;
        }
        var s = sources.get(prop2);
        var exists = prop2 in target;
        if (s === void 0 && (!exists || get_descriptor(target, prop2)?.writable)) {
          s = with_parent(() => {
            var p = proxy(exists ? target[prop2] : UNINITIALIZED);
            var s2 = state(p, stack2);
            if (dev_fallback_default) {
              tag(s2, get_label(path, prop2));
            }
            return s2;
          });
          sources.set(prop2, s);
        }
        if (s !== void 0) {
          var v = get(s);
          return v === UNINITIALIZED ? void 0 : v;
        }
        return Reflect.get(target, prop2, receiver);
      },
      getOwnPropertyDescriptor(target, prop2) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor && "value" in descriptor) {
          var s = sources.get(prop2);
          if (s) descriptor.value = get(s);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop2);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop2) {
        if (prop2 === STATE_SYMBOL) {
          return true;
        }
        var s = sources.get(prop2);
        var has = s !== void 0 && s.v !== UNINITIALIZED || Reflect.has(target, prop2);
        if (s !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop2)?.writable)) {
          if (s === void 0) {
            s = with_parent(() => {
              var p = has ? proxy(target[prop2]) : UNINITIALIZED;
              var s2 = state(p, stack2);
              if (dev_fallback_default) {
                tag(s2, get_label(path, prop2));
              }
              return s2;
            });
            sources.set(prop2, s);
          }
          var value2 = get(s);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop2, value2, receiver) {
        var s = sources.get(prop2);
        var has = prop2 in target;
        if (is_proxied_array && prop2 === "length") {
          for (var i = value2; i < /** @type {Source<number>} */
          s.v; i += 1) {
            var other_s = sources.get(i + "");
            if (other_s !== void 0) {
              set2(other_s, UNINITIALIZED);
            } else if (i in target) {
              other_s = with_parent(() => state(UNINITIALIZED, stack2));
              sources.set(i + "", other_s);
              if (dev_fallback_default) {
                tag(other_s, get_label(path, i));
              }
            }
          }
        }
        if (s === void 0) {
          if (!has || get_descriptor(target, prop2)?.writable) {
            s = with_parent(() => state(void 0, stack2));
            if (dev_fallback_default) {
              tag(s, get_label(path, prop2));
            }
            set2(s, proxy(value2));
            sources.set(prop2, s);
          }
        } else {
          has = s.v !== UNINITIALIZED;
          var p = with_parent(() => proxy(value2));
          set2(s, p);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop2 === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n = Number(prop2);
            if (Number.isInteger(n) && n >= ls.v) {
              set2(ls, n + 1);
            }
          }
          increment(version);
        }
        return true;
      },
      ownKeys(target) {
        get(version);
        var own_keys = Reflect.ownKeys(target).filter((key3) => {
          var source3 = sources.get(key3);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
function get_label(path, prop2) {
  if (typeof prop2 === "symbol") return `${path}[Symbol(${prop2.description ?? ""})]`;
  if (regex_is_valid_identifier.test(prop2)) return `${path}.${prop2}`;
  return /^\d+$/.test(prop2) ? `${path}[${prop2}]` : `${path}['${prop2}']`;
}
function get_proxied_value(value) {
  try {
    if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
      return value[STATE_SYMBOL];
    }
  } catch {
  }
  return value;
}
function is(a, b) {
  return Object.is(get_proxied_value(a), get_proxied_value(b));
}
var ARRAY_MUTATING_METHODS = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
function inspectable_array(array) {
  return new Proxy(array, {
    get(target, prop2, receiver) {
      var value = Reflect.get(target, prop2, receiver);
      if (!ARRAY_MUTATING_METHODS.has(
        /** @type {string} */
        prop2
      )) {
        return value;
      }
      return function(...args) {
        set_eager_effects_deferred();
        var result = value.apply(this, args);
        flush_eager_effects();
        return result;
      };
    }
  });
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes: includes2 } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i = from_index ?? 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i = 0; i <= (from_index ?? this.length - 1); i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes2.call(this, item, from_index);
    if (!has) {
      for (let i = 0; i < this.length; i += 1) {
        if (get_proxied_value(this[i]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes2;
  };
}
function strict_equals(a, b, equal = true) {
  try {
    if (a === b !== (get_proxied_value(a) === get_proxied_value(b))) {
      state_proxy_equality_mismatch(equal ? "===" : "!==");
    }
  } catch {
  }
  return a === b === equal;
}
function equals2(a, b, equal = true) {
  if (a == b !== (get_proxied_value(a) == get_proxied_value(b))) {
    state_proxy_equality_mismatch(equal ? "==" : "!=");
  }
  return a == b === equal;
}

// node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
var is_firefox;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  is_firefox = /Firefox/.test(navigator.userAgent);
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return (
    /** @type {TemplateNode | null} */
    first_child_getter.call(node)
  );
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return (
    /** @type {TemplateNode | null} */
    next_sibling_getter.call(node)
  );
}
function child(node, is_text) {
  if (!hydrating) {
    return /* @__PURE__ */ get_first_child(node);
  }
  var child2 = /* @__PURE__ */ get_first_child(hydrate_node);
  if (child2 === null) {
    child2 = hydrate_node.appendChild(create_text());
  } else if (is_text && child2.nodeType !== TEXT_NODE) {
    var text2 = create_text();
    child2?.before(text2);
    set_hydrate_node(text2);
    return text2;
  }
  if (is_text) {
    merge_text_nodes(
      /** @type {Text} */
      child2
    );
  }
  set_hydrate_node(child2);
  return child2;
}
function first_child(node, is_text = false) {
  if (!hydrating) {
    var first = /* @__PURE__ */ get_first_child(node);
    if (first instanceof Comment && first.data === "") return /* @__PURE__ */ get_next_sibling(first);
    return first;
  }
  if (is_text) {
    if (hydrate_node?.nodeType !== TEXT_NODE) {
      var text2 = create_text();
      hydrate_node?.before(text2);
      set_hydrate_node(text2);
      return text2;
    }
    merge_text_nodes(
      /** @type {Text} */
      hydrate_node
    );
  }
  return hydrate_node;
}
function sibling(node, count = 1, is_text = false) {
  let next_sibling = hydrating ? hydrate_node : node;
  var last_sibling;
  while (count--) {
    last_sibling = next_sibling;
    next_sibling = /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(next_sibling);
  }
  if (!hydrating) {
    return next_sibling;
  }
  if (is_text) {
    if (next_sibling?.nodeType !== TEXT_NODE) {
      var text2 = create_text();
      if (next_sibling === null) {
        last_sibling?.after(text2);
      } else {
        next_sibling.before(text2);
      }
      set_hydrate_node(text2);
      return text2;
    }
    merge_text_nodes(
      /** @type {Text} */
      next_sibling
    );
  }
  set_hydrate_node(next_sibling);
  return next_sibling;
}
function clear_text_content(node) {
  node.textContent = "";
}
function should_defer_append() {
  if (!async_mode_flag) return false;
  if (eager_block_effects !== null) return false;
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  return (flags2 & REACTION_RAN) !== 0;
}
function create_element(tag2, namespace, is2) {
  let options = is2 ? { is: is2 } : void 0;
  return (
    /** @type {T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T] : Element} */
    document.createElementNS(namespace ?? NAMESPACE_HTML, tag2, options)
  );
}
function create_fragment() {
  return document.createDocumentFragment();
}
function create_comment(data = "") {
  return document.createComment(data);
}
function set_attribute(element2, key2, value = "") {
  if (key2.startsWith("xlink:")) {
    element2.setAttributeNS("http://www.w3.org/1999/xlink", key2, value);
    return;
  }
  return element2.setAttribute(key2, value);
}
function merge_text_nodes(text2) {
  if (
    /** @type {string} */
    text2.nodeValue.length < 65536
  ) {
    return;
  }
  let next2 = text2.nextSibling;
  while (next2 !== null && next2.nodeType === TEXT_NODE) {
    next2.remove();
    text2.nodeValue += /** @type {string} */
    next2.nodeValue;
    next2 = text2.nextSibling;
  }
}

// node_modules/svelte/src/internal/client/dom/elements/misc.js
function autofocus(dom, value) {
  if (value) {
    const body = document.body;
    dom.autofocus = true;
    queue_micro_task(() => {
      if (document.activeElement === body) {
        dom.focus();
      }
    });
  }
}
function remove_textarea_child(dom) {
  if (hydrating && get_first_child(dom) !== null) {
    clear_text_content(dom);
  }
}
var listening_to_form_reset = false;
function add_form_reset_listener() {
  if (!listening_to_form_reset) {
    listening_to_form_reset = true;
    document.addEventListener(
      "reset",
      (evt) => {
        Promise.resolve().then(() => {
          if (!evt.defaultPrevented) {
            for (
              const e of
              /**@type {HTMLFormElement} */
              evt.target.elements
            ) {
              e.__on_r?.();
            }
          }
        });
      },
      // In the capture phase to guarantee we get noticed of it (no possibility of stopPropagation)
      { capture: true }
    );
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js
function listen(target, events, handler, call_handler_immediately = true) {
  if (call_handler_immediately) {
    handler();
  }
  for (var name of events) {
    target.addEventListener(name, handler);
  }
  teardown(() => {
    for (var name2 of events) {
      target.removeEventListener(name2, handler);
    }
  });
}
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function listen_to_event_and_reset_event(element2, event2, handler, on_reset = handler) {
  element2.addEventListener(event2, () => without_reactive_context(handler));
  const prev = element2.__on_r;
  if (prev) {
    element2.__on_r = () => {
      prev();
      on_reset(true);
    };
  } else {
    element2.__on_r = () => on_reset(true);
  }
  add_form_reset_listener();
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function validate_effect(rune) {
  if (active_effect === null) {
    if (active_reaction === null) {
      effect_orphan(rune);
    }
    effect_in_unowned_derived();
  }
  if (is_destroying_effect) {
    effect_in_teardown(rune);
  }
}
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync) {
  var parent = active_effect;
  if (dev_fallback_default) {
    while (parent !== null && (parent.f & EAGER_EFFECT) !== 0) {
      parent = parent.parent;
    }
  }
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    nodes: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    wv: 0,
    ac: null
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    try {
      update_effect(effect2);
    } catch (e2) {
      destroy_effect(effect2);
      throw e2;
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var e = effect2;
  if (sync && e.deps === null && e.teardown === null && e.nodes === null && e.first === e.last && // either `null`, or a singular child
  (e.f & EFFECT_PRESERVED) === 0) {
    e = e.first;
    if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e !== null) {
      e.f |= EFFECT_TRANSPARENT;
    }
  }
  if (e !== null) {
    e.parent = parent;
    if (parent !== null) {
      push_effect(e, parent);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
      var derived3 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived3.effects ??= []).push(e);
    }
  }
  return effect2;
}
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
function teardown(fn) {
  const effect2 = create_effect(RENDER_EFFECT, null, false);
  set_signal_status(effect2, CLEAN);
  effect2.teardown = fn;
  return effect2;
}
function user_effect(fn) {
  validate_effect("$effect");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect"
    });
  }
  var flags2 = (
    /** @type {Effect} */
    active_effect.f
  );
  var defer = !active_reaction && (flags2 & BRANCH_EFFECT) !== 0 && (flags2 & REACTION_RAN) === 0;
  if (defer) {
    var context = (
      /** @type {ComponentContext} */
      component_context
    );
    (context.e ??= []).push(fn);
  } else {
    return create_user_effect(fn);
  }
}
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
function user_pre_effect(fn) {
  validate_effect("$effect.pre");
  if (dev_fallback_default) {
    define_property(fn, "name", {
      value: "$effect.pre"
    });
  }
  return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
}
function eager_effect(fn) {
  return create_effect(EAGER_EFFECT, fn, true);
}
function effect_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  Batch.ensure();
  const effect2 = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function legacy_pre_effect(deps, fn) {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  var token = { effect: null, ran: false, deps };
  context.l.$.push(token);
  token.effect = render_effect(() => {
    deps();
    if (token.ran) return;
    token.ran = true;
    untrack(fn);
  });
}
function legacy_pre_effect_reset() {
  var context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  render_effect(() => {
    for (var token of context.l.$) {
      token.deps();
      var effect2 = token.effect;
      if ((effect2.f & CLEAN) !== 0 && effect2.deps !== null) {
        set_signal_status(effect2, MAYBE_DIRTY);
      }
      if (is_dirty(effect2)) {
        update_effect(effect2);
      }
      token.ran = false;
    }
  });
}
function async_effect(fn) {
  return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
}
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
function template_effect(fn, sync = [], async2 = [], blockers = []) {
  flatten(blockers, sync, async2, (values) => {
    create_effect(RENDER_EFFECT, () => fn(...values.map(get)), true);
  });
}
function deferred_template_effect(fn, sync = [], async2 = [], blockers = []) {
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var is_async = async2.length > 0 || blockers.length > 0;
  if (is_async) batch.increment(true);
  flatten(blockers, sync, async2, (values) => {
    create_effect(EFFECT, () => fn(...values.map(get)), false);
    if (is_async) batch.decrement(true);
  });
}
function block(fn, flags2 = 0) {
  var effect2 = create_effect(BLOCK_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function managed(fn, flags2 = 0) {
  var effect2 = create_effect(MANAGED_EFFECT | flags2, fn, true);
  if (dev_fallback_default) {
    effect2.dev_stack = dev_stack;
  }
  return effect2;
}
function branch(fn) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    const controller = effect2.ac;
    if (controller !== null) {
      without_reactive_context(() => {
        controller.abort(STALE_REACTION);
      });
    }
    var next2 = effect2.next;
    if ((effect2.f & ROOT_EFFECT) !== 0) {
      effect2.parent = null;
    } else {
      destroy_effect(effect2, remove_dom);
    }
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes !== null && effect2.nodes.end !== null) {
    remove_effect_dom(
      effect2.nodes.start,
      /** @type {TemplateNode} */
      effect2.nodes.end
    );
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.nodes && effect2.nodes.t;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes = effect2.ac = null;
}
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : get_next_sibling(node);
    node.remove();
    node = next2;
  }
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback, destroy = true) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  var fn = () => {
    if (destroy) destroy_effect(effect2);
    if (callback) callback();
  };
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child2.f & BRANCH_EFFECT) !== 0 && (effect2.f & BLOCK_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0) return;
  effect2.f ^= INERT;
  if ((effect2.f & CLEAN) === 0) {
    set_signal_status(effect2, DIRTY);
    schedule_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  var t = effect2.nodes && effect2.nodes.t;
  if (t !== null) {
    for (const transition2 of t) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}
function aborted(effect2 = (
  /** @type {Effect} */
  active_effect
)) {
  return (effect2.f & DESTROYED) !== 0;
}
function move_effect(effect2, fragment) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  while (node !== null) {
    var next2 = node === end ? null : get_next_sibling(node);
    fragment.append(node);
    node = next2;
  }
}

// node_modules/svelte/src/internal/client/legacy.js
var captured_signals = null;
function capture_signals(fn) {
  var previous_captured_signals = captured_signals;
  try {
    captured_signals = /* @__PURE__ */ new Set();
    untrack(fn);
    if (previous_captured_signals !== null) {
      for (var signal of captured_signals) {
        previous_captured_signals.add(signal);
      }
    }
    return captured_signals;
  } finally {
    captured_signals = previous_captured_signals;
  }
}
function invalidate_inner_signals(fn) {
  for (var signal of capture_signals(fn)) {
    internal_set(signal, signal.v);
  }
}

// node_modules/svelte/src/internal/client/runtime.js
var is_updating_effect = false;
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
var active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && (!async_mode_flag || (active_reaction.f & DERIVED) !== 0)) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
function increment_write_version() {
  return ++write_version;
}
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = (
      /** @type {Value[]} */
      reaction.deps
    );
    var length = dependencies.length;
    for (var i = 0; i < length; i++) {
      var dependency = dependencies[i];
      if (is_dirty(
        /** @type {Derived} */
        dependency
      )) {
        update_derived(
          /** @type {Derived} */
          dependency
        );
      }
      if (dependency.wv > reaction.wv) {
        return true;
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function schedule_possible_effect_self_invalidation(signal, effect2, root5 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (!async_mode_flag && current_sources !== null && includes.call(current_sources, signal)) {
    return;
  }
  for (var i = 0; i < reactions.length; i++) {
    var reaction = reactions[i];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect2,
        false
      );
    } else if (effect2 === reaction) {
      if (root5) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    reaction.f |= REACTION_RAN;
    var deps = reaction.deps;
    var is_fork = current_batch?.is_fork;
    if (new_deps !== null) {
      var i;
      if (!is_fork) {
        remove_reactions(reaction, skipped_deps);
      }
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i = 0; i < new_deps.length; i++) {
          deps[skipped_deps + i] = new_deps[i];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i = skipped_deps; i < deps.length; i++) {
          (deps[i].reactions ??= []).push(reaction);
        }
      }
    } else if (!is_fork && deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i = 0; i < /** @type {Source[]} */
      untracked_writes.length; i++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (previous_reaction.deps !== null) {
        for (let i2 = 0; i2 < previous_skipped_deps; i2 += 1) {
          previous_reaction.deps[i2].rv = read_version;
        }
      }
      if (previous_deps !== null) {
        for (const dep of previous_deps) {
          dep.rv = read_version;
        }
      }
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error) {
    return handle_error(error);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = index_of.call(reactions, signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !includes.call(new_deps, dependency))) {
    var derived3 = (
      /** @type {Derived} */
      dependency
    );
    if ((derived3.f & CONNECTED) !== 0) {
      derived3.f ^= CONNECTED;
      derived3.f &= ~WAS_MARKED;
    }
    update_derived_status(derived3);
    freeze_derived_effects(derived3);
    remove_reactions(derived3, 0);
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i = start_index; i < dependencies.length; i++) {
    remove_reaction(signal, dependencies[i]);
  }
}
function update_effect(effect2) {
  var flags2 = effect2.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect2;
  is_updating_effect = true;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    set_dev_current_component_function(effect2.component_function);
    var previous_stack = (
      /** @type {any} */
      dev_stack
    );
    set_dev_stack(effect2.dev_stack ?? dev_stack);
  }
  try {
    if ((flags2 & (BLOCK_EFFECT | MANAGED_EFFECT)) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.wv = write_version;
    if (dev_fallback_default && tracing_mode_flag && (effect2.f & DIRTY) !== 0 && effect2.deps !== null) {
      for (var dep of effect2.deps) {
        if (dep.set_during_effect) {
          dep.wv = increment_write_version();
          dep.set_during_effect = false;
        }
      }
    }
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
    if (dev_fallback_default) {
      set_dev_current_component_function(previous_component_fn);
      set_dev_stack(previous_stack);
    }
  }
}
async function tick() {
  if (async_mode_flag) {
    return new Promise((f) => {
      requestAnimationFrame(() => f());
      setTimeout(() => f());
    });
  }
  await Promise.resolve();
  flushSync();
}
function settled() {
  return Batch.ensure().settled();
}
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  captured_signals?.add(signal);
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && (current_sources === null || !includes.call(current_sources, signal))) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!includes.call(reactions, active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (dev_fallback_default) {
    recent_async_deriveds.delete(signal);
    if (tracing_mode_flag && !untracking && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
      if (signal.trace) {
        signal.trace();
      } else {
        var trace2 = get_error("traced at");
        if (trace2) {
          var entry = tracing_expressions.entries.get(signal);
          if (entry === void 0) {
            entry = { traces: [] };
            tracing_expressions.entries.set(signal, entry);
          }
          var last = entry.traces[entry.traces.length - 1];
          if (trace2.stack !== last?.stack) {
            entry.traces.push(trace2);
          }
        }
      }
    }
  }
  if (is_destroying_effect && old_values.has(signal)) {
    return old_values.get(signal);
  }
  if (is_derived) {
    var derived3 = (
      /** @type {Derived} */
      signal
    );
    if (is_destroying_effect) {
      var value = derived3.v;
      if ((derived3.f & CLEAN) === 0 && derived3.reactions !== null || depends_on_old_values(derived3)) {
        value = execute_derived(derived3);
      }
      old_values.set(derived3, value);
      return value;
    }
    var should_connect = (derived3.f & CONNECTED) === 0 && !untracking && active_reaction !== null && (is_updating_effect || (active_reaction.f & CONNECTED) !== 0);
    var is_new = (derived3.f & REACTION_RAN) === 0;
    if (is_dirty(derived3)) {
      if (should_connect) {
        derived3.f |= CONNECTED;
      }
      update_derived(derived3);
    }
    if (should_connect && !is_new) {
      unfreeze_derived_effects(derived3);
      reconnect(derived3);
    }
  }
  if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
function reconnect(derived3) {
  derived3.f |= CONNECTED;
  if (derived3.deps === null) return;
  for (const dep of derived3.deps) {
    (dep.reactions ??= []).push(derived3);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      unfreeze_derived_effects(
        /** @type {Derived} */
        dep
      );
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
function depends_on_old_values(derived3) {
  if (derived3.v === UNINITIALIZED) return true;
  if (derived3.deps === null) return false;
  for (const dep of derived3.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
function safe_get(signal) {
  return signal && get(signal);
}
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
function exclude_from_object(obj, keys) {
  var result = {};
  for (var key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  for (var symbol of Object.getOwnPropertySymbols(obj)) {
    if (Object.propertyIsEnumerable.call(obj, symbol) && !keys.includes(symbol)) {
      result[symbol] = obj[symbol];
    }
  }
  return result;
}
function deep_read_state(value) {
  if (typeof value !== "object" || !value || value instanceof EventTarget) {
    return;
  }
  if (STATE_SYMBOL in value) {
    deep_read(value);
  } else if (!Array.isArray(value)) {
    for (let key2 in value) {
      const prop2 = value[key2];
      if (typeof prop2 === "object" && prop2 && STATE_SYMBOL in prop2) {
        deep_read(prop2);
      }
    }
  }
}
function deep_read(value, visited = /* @__PURE__ */ new Set()) {
  if (typeof value === "object" && value !== null && // We don't want to traverse DOM elements
  !(value instanceof EventTarget) && !visited.has(value)) {
    visited.add(value);
    if (value instanceof Date) {
      value.getTime();
    }
    for (let key2 in value) {
      try {
        deep_read(value[key2], visited);
      } catch (e) {
      }
    }
    const proto = get_prototype_of(value);
    if (proto !== Object.prototype && proto !== Array.prototype && proto !== Map.prototype && proto !== Set.prototype && proto !== Date.prototype) {
      const descriptors = get_descriptors(proto);
      for (let key2 in descriptors) {
        const get3 = descriptors[key2].get;
        if (get3) {
          try {
            get3.call(value);
          } catch (e) {
          }
        }
      }
    }
  }
}

// node_modules/svelte/src/internal/client/hydratable.js
function hydratable(key2, fn) {
  if (!async_mode_flag) {
    experimental_async_required("hydratable");
  }
  if (hydrating) {
    const store = window.__svelte?.h;
    if (store?.has(key2)) {
      return (
        /** @type {T} */
        store.get(key2)
      );
    }
    if (dev_fallback_default) {
      hydratable_missing_but_required(key2);
    } else {
      hydratable_missing_but_expected(key2);
    }
  }
  return fn();
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
var event_symbol = Symbol("events");
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function replay_events(dom) {
  if (!hydrating) return;
  dom.removeAttribute("onload");
  dom.removeAttribute("onerror");
  const event2 = dom.__e;
  if (event2 !== void 0) {
    dom.__e = void 0;
    queueMicrotask(() => {
      if (dom.isConnected) {
        dom.dispatchEvent(event2);
      }
    });
  }
}
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    if (!options.capture) {
      handle_event_propagation.call(dom, event2);
    }
    if (!event2.cancelBubble) {
      return without_reactive_context(() => {
        return handler?.call(this, event2);
      });
    }
  }
  if (event_name.startsWith("pointer") || event_name.startsWith("touch") || event_name === "wheel") {
    queue_micro_task(() => {
      dom.addEventListener(event_name, target_handler, options);
    });
  } else {
    dom.addEventListener(event_name, target_handler, options);
  }
  return target_handler;
}
function on(element2, type, handler, options = {}) {
  var target_handler = create_event(type, element2, handler, options);
  return () => {
    element2.removeEventListener(type, target_handler, options);
  };
}
function event(event_name, dom, handler, capture2, passive2) {
  var options = { capture: capture2, passive: passive2 };
  var target_handler = create_event(event_name, dom, handler, options);
  if (dom === document.body || // @ts-ignore
  dom === window || // @ts-ignore
  dom === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  dom instanceof HTMLMediaElement) {
    teardown(() => {
      dom.removeEventListener(event_name, target_handler, options);
    });
  }
}
function delegated(event_name, element2, handler) {
  (element2[event_symbol] ??= {})[event_name] = handler;
}
function delegate(events) {
  for (var i = 0; i < events.length; i++) {
    all_registered_events.add(events[i]);
  }
  for (var fn of root_event_handles) {
    fn(events);
  }
}
var last_propagated_event = null;
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2[event_symbol];
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2[event_symbol] = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated2 = current_target[event_symbol]?.[event_name];
        if (delegated2 != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event2.target === current_target)) {
          delegated2.call(current_target, event2);
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2[event_symbol] = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
function apply(thunk, element2, args, component2, loc, has_side_effects = false, remove_parens = false) {
  let handler;
  let error;
  try {
    handler = thunk();
  } catch (e) {
    error = e;
  }
  if (typeof handler !== "function" && (has_side_effects || handler != null || error)) {
    const filename = component2?.[FILENAME];
    const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
    const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? "capture" : "";
    const event_name = args[0]?.type + phase;
    const description = `\`${event_name}\` handler${location}`;
    const suggestion = remove_parens ? "remove the trailing `()`" : "add a leading `() =>`";
    event_handler_invalid(description, suggestion);
    if (error) {
      throw error;
    }
  }
  handler?.apply(element2, args);
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
var policy = (
  // We gotta write it like this because after downleveling the pure comment may end up in the wrong location
  globalThis?.window?.trustedTypes && /* @__PURE__ */ globalThis.window.trustedTypes.createPolicy("svelte-trusted-html", {
    /** @param {string} html */
    createHTML: (html2) => {
      return html2;
    }
  })
);
function create_trusted_html(html2) {
  return (
    /** @type {string} */
    policy?.createHTML(html2) ?? html2
  );
}
function create_fragment_from_html(html2, trusted2 = false) {
  var elem = create_element("template");
  html2 = html2.replaceAll("<!>", "<!---->");
  elem.innerHTML = trusted2 ? create_trusted_html(html2) : html2;
  return elem.content;
}

// node_modules/svelte/src/internal/client/dom/template.js
var TEMPLATE_TAG = IS_XHTML ? "template" : "TEMPLATE";
var SCRIPT_TAG = IS_XHTML ? "script" : "SCRIPT";
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes === null) {
    effect2.nodes = { start, end, a: null, t: null };
  }
}
// @__NO_SIDE_EFFECTS__
function from_html(content, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  var has_start = !content.startsWith("<!>");
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      node = create_fragment_from_html(has_start ? content : "<!>" + content, true);
      if (!is_fragment) node = /** @type {TemplateNode} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_namespace(content, flags2, ns = "svg") {
  var has_start = !content.startsWith("<!>");
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var wrapped = `<${ns}>${has_start ? content : "<!>" + content}</${ns}>`;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (!node) {
      var fragment = (
        /** @type {DocumentFragment} */
        create_fragment_from_html(wrapped, true)
      );
      var root5 = (
        /** @type {Element} */
        get_first_child(fragment)
      );
      if (is_fragment) {
        node = document.createDocumentFragment();
        while (get_first_child(root5)) {
          node.appendChild(
            /** @type {TemplateNode} */
            get_first_child(root5)
          );
        }
      } else {
        node = /** @type {Element} */
        get_first_child(root5);
      }
    }
    var clone2 = (
      /** @type {TemplateNode} */
      node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
// @__NO_SIDE_EFFECTS__
function from_svg(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "svg");
}
// @__NO_SIDE_EFFECTS__
function from_mathml(content, flags2) {
  return /* @__PURE__ */ from_namespace(content, flags2, "math");
}
function fragment_from_tree(structure, ns) {
  var fragment = create_fragment();
  for (var item of structure) {
    if (typeof item === "string") {
      fragment.append(create_text(item));
      continue;
    }
    if (item === void 0 || item[0][0] === "/") {
      fragment.append(create_comment(item ? item[0].slice(3) : ""));
      continue;
    }
    const [name, attributes, ...children] = item;
    const namespace = name === "svg" ? NAMESPACE_SVG : name === "math" ? NAMESPACE_MATHML : ns;
    var element2 = create_element(name, namespace, attributes?.is);
    for (var key2 in attributes) {
      set_attribute(element2, key2, attributes[key2]);
    }
    if (children.length > 0) {
      var target = element2.nodeName === TEMPLATE_TAG ? (
        /** @type {HTMLTemplateElement} */
        element2.content
      ) : element2;
      target.append(
        fragment_from_tree(children, element2.nodeName === "foreignObject" ? void 0 : namespace)
      );
    }
    fragment.append(element2);
  }
  return fragment;
}
// @__NO_SIDE_EFFECTS__
function from_tree(structure, flags2) {
  var is_fragment = (flags2 & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags2 & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      assign_nodes(hydrate_node, null);
      return hydrate_node;
    }
    if (node === void 0) {
      const ns = (flags2 & TEMPLATE_USE_SVG) !== 0 ? NAMESPACE_SVG : (flags2 & TEMPLATE_USE_MATHML) !== 0 ? NAMESPACE_MATHML : void 0;
      node = fragment_from_tree(structure, ns);
      if (!is_fragment) node = /** @type {TemplateNode} */
      get_first_child(node);
    }
    var clone2 = (
      /** @type {TemplateNode} */
      use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
    );
    if (is_fragment) {
      var start = (
        /** @type {TemplateNode} */
        get_first_child(clone2)
      );
      var end = (
        /** @type {TemplateNode} */
        clone2.lastChild
      );
      assign_nodes(start, end);
    } else {
      assign_nodes(clone2, clone2);
    }
    return clone2;
  };
}
function with_script(fn) {
  return () => run_scripts(fn());
}
function run_scripts(node) {
  if (hydrating) return node;
  const is_fragment = node.nodeType === DOCUMENT_FRAGMENT_NODE;
  const scripts = (
    /** @type {HTMLElement} */
    node.nodeName === SCRIPT_TAG ? [
      /** @type {HTMLScriptElement} */
      node
    ] : node.querySelectorAll("script")
  );
  const effect2 = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  for (const script of scripts) {
    const clone2 = create_element("script");
    for (var attribute of script.attributes) {
      clone2.setAttribute(attribute.name, attribute.value);
    }
    clone2.textContent = script.textContent;
    if (is_fragment ? node.firstChild === script : node === script) {
      effect2.nodes.start = clone2;
    }
    if (is_fragment ? node.lastChild === script : node === script) {
      effect2.nodes.end = clone2;
    }
    script.replaceWith(clone2);
  }
  return node;
}
function text(value = "") {
  if (!hydrating) {
    var t = create_text(value + "");
    assign_nodes(t, t);
    return t;
  }
  var node = hydrate_node;
  if (node.nodeType !== TEXT_NODE) {
    node.before(node = create_text());
    set_hydrate_node(node);
  } else {
    merge_text_nodes(
      /** @type {Text} */
      node
    );
  }
  assign_nodes(node, node);
  return node;
}
function comment() {
  if (hydrating) {
    assign_nodes(hydrate_node, null);
    return hydrate_node;
  }
  var frag = document.createDocumentFragment();
  var start = document.createComment("");
  var anchor = create_text();
  frag.append(start, anchor);
  assign_nodes(start, anchor);
  return frag;
}
function append(anchor, dom) {
  if (hydrating) {
    var effect2 = (
      /** @type {Effect & { nodes: EffectNodes }} */
      active_effect
    );
    if ((effect2.f & REACTION_RAN) === 0 || effect2.nodes.end === null) {
      effect2.nodes.end = hydrate_node;
    }
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}
function props_id() {
  if (hydrating && hydrate_node && hydrate_node.nodeType === COMMENT_NODE && hydrate_node.textContent?.startsWith(`$`)) {
    const id = hydrate_node.textContent.substring(1);
    hydrate_next();
    return id;
  }
  (window.__svelte ??= {}).uid ??= 1;
  return `c${window.__svelte.uid++}`;
}

// node_modules/svelte/src/utils.js
var regex_return_characters = /\r/g;
function hash(str) {
  str = str.replace(regex_return_characters, "");
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return (hash2 >>> 0).toString(36);
}
var VOID_ELEMENT_NAMES = [
  "area",
  "base",
  "br",
  "col",
  "command",
  "embed",
  "hr",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function is_void(name) {
  return VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === "!doctype";
}
var RESERVED_WORDS = [
  "arguments",
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "eval",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "implements",
  "import",
  "in",
  "instanceof",
  "interface",
  "let",
  "new",
  "null",
  "package",
  "private",
  "protected",
  "public",
  "return",
  "static",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield"
];
function is_reserved(word) {
  return RESERVED_WORDS.includes(word);
}
function is_capture_event(name) {
  return name.endsWith("capture") && name !== "gotpointercapture" && name !== "lostpointercapture";
}
var DELEGATED_EVENTS = [
  "beforeinput",
  "click",
  "change",
  "dblclick",
  "contextmenu",
  "focusin",
  "focusout",
  "input",
  "keydown",
  "keyup",
  "mousedown",
  "mousemove",
  "mouseout",
  "mouseover",
  "mouseup",
  "pointerdown",
  "pointermove",
  "pointerout",
  "pointerover",
  "pointerup",
  "touchend",
  "touchmove",
  "touchstart"
];
function can_delegate_event(event_name) {
  return DELEGATED_EVENTS.includes(event_name);
}
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "indeterminate",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory",
  "defer",
  "disablepictureinpicture",
  "disableremoteplayback"
];
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
var ATTRIBUTE_ALIASES = {
  // no `class: 'className'` because we handle that separately
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly",
  defaultvalue: "defaultValue",
  defaultchecked: "defaultChecked",
  srcobject: "srcObject",
  novalidate: "noValidate",
  allowfullscreen: "allowFullscreen",
  disablepictureinpicture: "disablePictureInPicture",
  disableremoteplayback: "disableRemotePlayback"
};
function normalize_attribute(name) {
  name = name.toLowerCase();
  return ATTRIBUTE_ALIASES[name] ?? name;
}
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject",
  "noValidate",
  "allowFullscreen",
  "disablePictureInPicture",
  "disableRemotePlayback"
];
function is_dom_property(name) {
  return DOM_PROPERTIES.includes(name);
}
var NON_STATIC_PROPERTIES = ["autofocus", "muted", "defaultValue", "defaultChecked"];
function cannot_be_set_statically(name) {
  return NON_STATIC_PROPERTIES.includes(name);
}
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
var CONTENT_EDITABLE_BINDINGS = ["textContent", "innerHTML", "innerText"];
function is_content_editable_binding(name) {
  return CONTENT_EDITABLE_BINDINGS.includes(name);
}
var LOAD_ERROR_ELEMENTS = [
  "body",
  "embed",
  "iframe",
  "img",
  "link",
  "object",
  "script",
  "style",
  "track"
];
function is_load_error_element(name) {
  return LOAD_ERROR_ELEMENTS.includes(name);
}
var SVG_ELEMENTS = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animate",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "circle",
  "clipPath",
  "color-profile",
  "cursor",
  "defs",
  "desc",
  "discard",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "font",
  "font-face",
  "font-face-format",
  "font-face-name",
  "font-face-src",
  "font-face-uri",
  "foreignObject",
  "g",
  "glyph",
  "glyphRef",
  "hatch",
  "hatchpath",
  "hkern",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshgradient",
  "meshpatch",
  "meshrow",
  "metadata",
  "missing-glyph",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tref",
  "tspan",
  "unknown",
  "use",
  "view",
  "vkern"
];
function is_svg(name) {
  return SVG_ELEMENTS.includes(name);
}
var MATHML_ELEMENTS = [
  "annotation",
  "annotation-xml",
  "maction",
  "math",
  "merror",
  "mfrac",
  "mi",
  "mmultiscripts",
  "mn",
  "mo",
  "mover",
  "mpadded",
  "mphantom",
  "mprescripts",
  "mroot",
  "mrow",
  "ms",
  "mspace",
  "msqrt",
  "mstyle",
  "msub",
  "msubsup",
  "msup",
  "mtable",
  "mtd",
  "mtext",
  "mtr",
  "munder",
  "munderover",
  "semantics"
];
function is_mathml(name) {
  return MATHML_ELEMENTS.includes(name);
}
var STATE_CREATION_RUNES = (
  /** @type {const} */
  [
    "$state",
    "$state.raw",
    "$derived",
    "$derived.by"
  ]
);
var RUNES = (
  /** @type {const} */
  [
    ...STATE_CREATION_RUNES,
    "$state.eager",
    "$state.snapshot",
    "$props",
    "$props.id",
    "$bindable",
    "$effect",
    "$effect.pre",
    "$effect.tracking",
    "$effect.root",
    "$effect.pending",
    "$inspect",
    "$inspect().with",
    "$inspect.trace",
    "$host"
  ]
);
function is_rune(name) {
  return RUNES.includes(
    /** @type {RuneName} */
    name
  );
}
function is_state_creation_rune(name) {
  return STATE_CREATION_RUNES.includes(
    /** @type {StateCreationRuneName} */
    name
  );
}
var RAW_TEXT_ELEMENTS = (
  /** @type {const} */
  ["textarea", "script", "style", "title"]
);
function is_raw_text_element(name) {
  return RAW_TEXT_ELEMENTS.includes(
    /** @type {typeof RAW_TEXT_ELEMENTS[number]} */
    name
  );
}
function sanitize_location(location) {
  return (
    /** @type {T} */
    location?.replace(/\//g, "/\u200B")
  );
}

// node_modules/svelte/src/internal/client/render.js
var should_intro = true;
function set_should_intro(value) {
  should_intro = value;
}
function set_text(text2, value) {
  var str = value == null ? "" : typeof value === "object" ? value + "" : value;
  if (str !== (text2.__t ??= text2.nodeValue)) {
    text2.__t = str;
    text2.nodeValue = str + "";
  }
}
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = get_first_child(target);
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component2, { ...options, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error instanceof Error && error.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error;
    }
    if (error !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error);
    }
    if (options.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component2, options);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
var listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {
  init_operations();
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: () => {
        }
      },
      (anchor_node2) => {
        push({});
        var ctx = (
          /** @type {ComponentContext} */
          component_context
        );
        if (context) ctx.c = context;
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        should_intro = intro;
        component2 = Component(anchor_node2, props) || {};
        should_intro = true;
        if (hydrating) {
          active_effect.nodes.end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        pop();
      }
    );
    var registered_events = /* @__PURE__ */ new Set();
    var event_handle = (events2) => {
      for (var i = 0; i < events2.length; i++) {
        var event_name = events2[i];
        if (registered_events.has(event_name)) continue;
        registered_events.add(event_name);
        var passive2 = is_passive_event(event_name);
        for (const node of [target, document]) {
          var counts = listeners.get(node);
          if (counts === void 0) {
            counts = /* @__PURE__ */ new Map();
            listeners.set(node, counts);
          }
          var count = counts.get(event_name);
          if (count === void 0) {
            node.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
            counts.set(event_name, 1);
          } else {
            counts.set(event_name, count + 1);
          }
        }
      }
    };
    event_handle(array_from(all_registered_events));
    root_event_handles.add(event_handle);
    return () => {
      for (var event_name of registered_events) {
        for (const node of [target, document]) {
          var counts = (
            /** @type {Map<string, number>} */
            listeners.get(node)
          );
          var count = (
            /** @type {number} */
            counts.get(event_name)
          );
          if (--count == 0) {
            node.removeEventListener(event_name, handle_event_propagation);
            counts.delete(event_name);
            if (counts.size === 0) {
              listeners.delete(node);
            }
          } else {
            counts.set(event_name, count);
          }
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    if (STATE_SYMBOL in component2) {
      state_proxy_unmount();
    } else {
      lifecycle_double_unmount();
    }
  }
  return Promise.resolve();
}

// node_modules/svelte/src/internal/shared/validate.js
function validate_void_dynamic_element(tag_fn) {
  const tag2 = tag_fn();
  if (tag2 && is_void(tag2)) {
    dynamic_void_element_content(tag2);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag2 = tag_fn();
  const is_string = typeof tag2 === "string";
  if (tag2 && !is_string) {
    svelte_element_invalid_this_value();
  }
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    store_invalid_shape(name);
  }
}
function prevent_snippet_stringification(fn) {
  fn.toString = () => {
    snippet_without_render_tag();
    return "";
  };
  return fn;
}

// node_modules/svelte/src/internal/client/dom/blocks/branches.js
var BranchManager = class {
  /** @type {TemplateNode} */
  anchor;
  /** @type {Map<Batch, Key>} */
  #batches = /* @__PURE__ */ new Map();
  /**
   * Map of keys to effects that are currently rendered in the DOM.
   * These effects are visible and actively part of the document tree.
   * Example:
   * ```
   * {#if condition}
   * 	foo
   * {:else}
   * 	bar
   * {/if}
   * ```
   * Can result in the entries `true->Effect` and `false->Effect`
   * @type {Map<Key, Effect>}
   */
  #onscreen = /* @__PURE__ */ new Map();
  /**
   * Similar to #onscreen with respect to the keys, but contains branches that are not yet
   * in the DOM, because their insertion is deferred.
   * @type {Map<Key, Branch>}
   */
  #offscreen = /* @__PURE__ */ new Map();
  /**
   * Keys of effects that are currently outroing
   * @type {Set<Key>}
   */
  #outroing = /* @__PURE__ */ new Set();
  /**
   * Whether to pause (i.e. outro) on change, or destroy immediately.
   * This is necessary for `<svelte:element>`
   */
  #transition = true;
  /**
   * @param {TemplateNode} anchor
   * @param {boolean} transition
   */
  constructor(anchor, transition2 = true) {
    this.anchor = anchor;
    this.#transition = transition2;
  }
  #commit = () => {
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    if (!this.#batches.has(batch)) return;
    var key2 = (
      /** @type {Key} */
      this.#batches.get(batch)
    );
    var onscreen = this.#onscreen.get(key2);
    if (onscreen) {
      resume_effect(onscreen);
      this.#outroing.delete(key2);
    } else {
      var offscreen = this.#offscreen.get(key2);
      if (offscreen) {
        this.#onscreen.set(key2, offscreen.effect);
        this.#offscreen.delete(key2);
        offscreen.fragment.lastChild.remove();
        this.anchor.before(offscreen.fragment);
        onscreen = offscreen.effect;
      }
    }
    for (const [b, k] of this.#batches) {
      this.#batches.delete(b);
      if (b === batch) {
        break;
      }
      const offscreen2 = this.#offscreen.get(k);
      if (offscreen2) {
        destroy_effect(offscreen2.effect);
        this.#offscreen.delete(k);
      }
    }
    for (const [k, effect2] of this.#onscreen) {
      if (k === key2 || this.#outroing.has(k)) continue;
      const on_destroy = () => {
        const keys = Array.from(this.#batches.values());
        if (keys.includes(k)) {
          var fragment = document.createDocumentFragment();
          move_effect(effect2, fragment);
          fragment.append(create_text());
          this.#offscreen.set(k, { effect: effect2, fragment });
        } else {
          destroy_effect(effect2);
        }
        this.#outroing.delete(k);
        this.#onscreen.delete(k);
      };
      if (this.#transition || !onscreen) {
        this.#outroing.add(k);
        pause_effect(effect2, on_destroy, false);
      } else {
        on_destroy();
      }
    }
  };
  /**
   * @param {Batch} batch
   */
  #discard = (batch) => {
    this.#batches.delete(batch);
    const keys = Array.from(this.#batches.values());
    for (const [k, branch2] of this.#offscreen) {
      if (!keys.includes(k)) {
        destroy_effect(branch2.effect);
        this.#offscreen.delete(k);
      }
    }
  };
  /**
   *
   * @param {any} key
   * @param {null | ((target: TemplateNode) => void)} fn
   */
  ensure(key2, fn) {
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    if (fn && !this.#onscreen.has(key2) && !this.#offscreen.has(key2)) {
      if (defer) {
        var fragment = document.createDocumentFragment();
        var target = create_text();
        fragment.append(target);
        this.#offscreen.set(key2, {
          effect: branch(() => fn(target)),
          fragment
        });
      } else {
        this.#onscreen.set(
          key2,
          branch(() => fn(this.anchor))
        );
      }
    }
    this.#batches.set(batch, key2);
    if (defer) {
      for (const [k, effect2] of this.#onscreen) {
        if (k === key2) {
          batch.unskip_effect(effect2);
        } else {
          batch.skip_effect(effect2);
        }
      }
      for (const [k, branch2] of this.#offscreen) {
        if (k === key2) {
          batch.unskip_effect(branch2.effect);
        } else {
          batch.skip_effect(branch2.effect);
        }
      }
      batch.oncommit(this.#commit);
      batch.ondiscard(this.#discard);
    } else {
      if (hydrating) {
        this.anchor = hydrate_node;
      }
      this.#commit();
    }
  }
};

// node_modules/svelte/src/internal/client/dom/blocks/snippet.js
function snippet(node, get_snippet, ...args) {
  var branches = new BranchManager(node);
  block(() => {
    const snippet2 = get_snippet() ?? null;
    if (dev_fallback_default && snippet2 == null) {
      invalid_snippet();
    }
    branches.ensure(snippet2, snippet2 && ((anchor) => snippet2(anchor, ...args)));
  }, EFFECT_TRANSPARENT);
}
function wrap_snippet(component2, fn) {
  const snippet2 = (node, ...args) => {
    var previous_component_function = dev_current_component_function;
    set_dev_current_component_function(component2);
    try {
      return fn(node, ...args);
    } finally {
      set_dev_current_component_function(previous_component_function);
    }
  };
  prevent_snippet_stringification(snippet2);
  return snippet2;
}
function createRawSnippet(fn) {
  return (anchor, ...params) => {
    var snippet2 = fn(...params);
    var element2;
    if (hydrating) {
      element2 = /** @type {Element} */
      hydrate_node;
      hydrate_next();
    } else {
      var html2 = snippet2.render().trim();
      var fragment = create_fragment_from_html(html2, true);
      element2 = /** @type {Element} */
      get_first_child(fragment);
      if (dev_fallback_default && (get_next_sibling(element2) !== null || element2.nodeType !== ELEMENT_NODE)) {
        invalid_raw_snippet_render();
      }
      anchor.before(element2);
    }
    const result = snippet2.setup?.(element2);
    assign_nodes(element2, element2);
    if (typeof result === "function") {
      teardown(result);
    }
  };
}

// node_modules/svelte/src/index-client.js
if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: () => {
          if (value !== void 0) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}
function getAbortSignal() {
  if (active_reaction === null) {
    get_abort_signal_outside_reaction();
  }
  return (active_reaction.ac ??= new AbortController()).signal;
}
function onMount(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onMount");
  }
  if (legacy_mode_flag && component_context.l !== null) {
    init_update_callbacks(component_context).m.push(fn);
  } else {
    user_effect(() => {
      const cleanup = untrack(fn);
      if (typeof cleanup === "function") return (
        /** @type {() => void} */
        cleanup
      );
    });
  }
}
function onDestroy(fn) {
  if (component_context === null) {
    lifecycle_outside_component("onDestroy");
  }
  onMount(() => () => untrack(fn));
}
function create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function createEventDispatcher() {
  const active_component_context = component_context;
  if (active_component_context === null) {
    lifecycle_outside_component("createEventDispatcher");
  }
  return (type, detail, options) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      active_component_context.s.$$events?.[
        /** @type {string} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      const event2 = create_custom_event(
        /** @type {string} */
        type,
        detail,
        options
      );
      for (const fn of callbacks) {
        fn.call(active_component_context.x, event2);
      }
      return !event2.defaultPrevented;
    }
    return true;
  };
}
function beforeUpdate(fn) {
  if (component_context === null) {
    lifecycle_outside_component("beforeUpdate");
  }
  if (component_context.l === null) {
    lifecycle_legacy_only("beforeUpdate");
  }
  init_update_callbacks(component_context).b.push(fn);
}
function afterUpdate(fn) {
  if (component_context === null) {
    lifecycle_outside_component("afterUpdate");
  }
  if (component_context.l === null) {
    lifecycle_legacy_only("afterUpdate");
  }
  init_update_callbacks(component_context).a.push(fn);
}
function init_update_callbacks(context) {
  var l = (
    /** @type {ComponentContextLegacy} */
    context.l
  );
  return l.u ??= { a: [], b: [], m: [] };
}

// node_modules/svelte/src/attachments/index.js
function createAttachmentKey() {
  return Symbol(ATTACHMENT_KEY);
}
function fromAction(action2, fn = (
  /** @type {() => T} */
  noop
)) {
  return (element2) => {
    const { update: update2, destroy } = untrack(() => action2(element2, fn()) ?? {});
    if (update2) {
      var ran = false;
      render_effect(() => {
        const arg = fn();
        if (ran) update2(arg);
      });
      ran = true;
    }
    if (destroy) {
      teardown(destroy);
    }
  };
}

// node_modules/svelte/src/internal/client/dev/assign.js
function compare(a, b, property, location) {
  if (a !== b && typeof b === "object" && STATE_SYMBOL in b) {
    assignment_value_stale(
      property,
      /** @type {string} */
      sanitize_location(location)
    );
  }
  return a;
}
function assign(object, property, value, location) {
  return compare(
    object[property] = value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_and(object, property, value, location) {
  return compare(
    object[property] &&= value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_or(object, property, value, location) {
  return compare(
    object[property] ||= value,
    untrack(() => object[property]),
    property,
    location
  );
}
function assign_nullish(object, property, value, location) {
  return compare(
    object[property] ??= value,
    untrack(() => object[property]),
    property,
    location
  );
}

// node_modules/svelte/src/internal/client/dev/css.js
var all_styles = /* @__PURE__ */ new Map();
function register_style(hash2, style) {
  var styles = all_styles.get(hash2);
  if (!styles) {
    styles = /* @__PURE__ */ new Set();
    all_styles.set(hash2, styles);
  }
  styles.add(style);
}
function cleanup_styles(hash2) {
  var styles = all_styles.get(hash2);
  if (!styles) return;
  for (const style of styles) {
    style.remove();
  }
  all_styles.delete(hash2);
}

// node_modules/svelte/src/internal/client/dev/elements.js
function add_locations(fn, filename, locations) {
  return (...args) => {
    const dom = fn(...args);
    var node = hydrating ? dom : dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
    assign_locations(node, filename, locations);
    return dom;
  };
}
function assign_location(element2, filename, location) {
  element2.__svelte_meta = {
    parent: dev_stack,
    loc: { file: filename, line: location[0], column: location[1] }
  };
  if (location[2]) {
    assign_locations(element2.firstChild, filename, location[2]);
  }
}
function assign_locations(node, filename, locations) {
  var i = 0;
  var depth = 0;
  while (node && i < locations.length) {
    if (hydrating && node.nodeType === COMMENT_NODE) {
      var comment2 = (
        /** @type {Comment} */
        node
      );
      if (comment2.data === HYDRATION_START || comment2.data === HYDRATION_START_ELSE) depth += 1;
      else if (comment2.data[0] === HYDRATION_END) depth -= 1;
    }
    if (depth === 0 && node.nodeType === ELEMENT_NODE) {
      assign_location(
        /** @type {Element} */
        node,
        filename,
        locations[i++]
      );
    }
    node = node.nextSibling;
  }
}

// node_modules/svelte/src/internal/client/dev/hmr.js
function hmr(fn) {
  const current = source(fn);
  function wrapper(anchor, props) {
    let component2 = {};
    let instance = {};
    let effect2;
    let ran = false;
    block(() => {
      if (component2 === (component2 = get(current))) {
        return;
      }
      if (effect2) {
        for (var k in instance) delete instance[k];
        destroy_effect(effect2);
      }
      effect2 = branch(() => {
        if (ran) set_should_intro(false);
        Object.defineProperties(
          instance,
          Object.getOwnPropertyDescriptors(
            // @ts-expect-error
            new.target ? new component2(anchor, props) : component2(anchor, props)
          )
        );
        if (ran) set_should_intro(true);
      });
    }, EFFECT_TRANSPARENT);
    ran = true;
    if (hydrating) {
      anchor = hydrate_node;
    }
    return instance;
  }
  wrapper[FILENAME] = fn[FILENAME];
  wrapper[HMR] = {
    fn,
    current,
    update: (incoming) => {
      set2(wrapper[HMR].current, incoming[HMR].fn);
      incoming[HMR].current = wrapper[HMR].current;
    }
  };
  return wrapper;
}

// node_modules/svelte/src/internal/client/dev/ownership.js
function create_ownership_validator(props) {
  const component2 = component_context?.function;
  const parent = component_context?.p?.function;
  return {
    /**
     * @param {string} prop
     * @param {any[]} path
     * @param {any} result
     * @param {number} line
     * @param {number} column
     */
    mutation: (prop2, path, result, line, column) => {
      const name = path[0];
      if (is_bound_or_unset(props, name) || !parent) {
        return result;
      }
      let value = props;
      for (let i = 0; i < path.length - 1; i++) {
        value = value[path[i]];
        if (!value?.[STATE_SYMBOL]) {
          return result;
        }
      }
      const location = sanitize_location(`${component2[FILENAME]}:${line}:${column}`);
      ownership_invalid_mutation(name, location, prop2, parent[FILENAME]);
      return result;
    },
    /**
     * @param {any} key
     * @param {any} child_component
     * @param {() => any} value
     */
    binding: (key2, child_component, value) => {
      if (!is_bound_or_unset(props, key2) && parent && value()?.[STATE_SYMBOL]) {
        ownership_invalid_binding(
          component2[FILENAME],
          key2,
          child_component[FILENAME],
          parent[FILENAME]
        );
      }
    }
  };
}
function is_bound_or_unset(props, prop_name) {
  const is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
  return !!get_descriptor(props, prop_name)?.set || is_entry_props && prop_name in props || !(prop_name in props);
}

// node_modules/svelte/src/internal/client/dev/legacy.js
function check_target(target) {
  if (target) {
    component_api_invalid_new(target[FILENAME] ?? "a component", target.name);
  }
}
function legacy_api() {
  const component2 = component_context?.function;
  function error(method) {
    component_api_changed(method, component2[FILENAME]);
  }
  return {
    $destroy: () => error("$destroy()"),
    $on: () => error("$on(...)"),
    $set: () => error("$set(...)")
  };
}

// node_modules/svelte/src/internal/client/dev/inspect.js
function inspect(get_value, inspector, show_stack = false) {
  validate_effect("$inspect");
  let initial = true;
  let error = (
    /** @type {any} */
    UNINITIALIZED
  );
  eager_effect(() => {
    try {
      var value = get_value();
    } catch (e) {
      error = e;
      return;
    }
    var snap = snapshot(value, true, true);
    untrack(() => {
      if (show_stack) {
        inspector(...snap);
        if (!initial) {
          const stack2 = get_error("$inspect(...)");
          if (stack2) {
            console.groupCollapsed("stack trace");
            console.log(stack2);
            console.groupEnd();
          }
        }
      } else {
        inspector(initial ? "init" : "update", ...snap);
      }
    });
    initial = false;
  });
  render_effect(() => {
    try {
      get_value();
    } catch {
    }
    if (error !== UNINITIALIZED) {
      console.error(error);
      error = UNINITIALIZED;
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/async.js
function async(node, blockers = [], expressions = [], fn) {
  var was_hydrating = hydrating;
  var end = null;
  if (was_hydrating) {
    hydrate_next();
    end = skip_nodes(false);
  }
  if (expressions.length === 0 && blockers.every((b) => b.settled)) {
    fn(node);
    if (was_hydrating) {
      set_hydrate_node(end);
    }
    return;
  }
  var boundary2 = get_boundary();
  var batch = (
    /** @type {Batch} */
    current_batch
  );
  var blocking = boundary2.is_rendered();
  boundary2.update_pending_count(1);
  batch.increment(blocking);
  if (was_hydrating) {
    var previous_hydrate_node = hydrate_node;
    set_hydrate_node(end);
  }
  flatten(blockers, [], expressions, (values) => {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(previous_hydrate_node);
    }
    try {
      for (const d of values) get(d);
      fn(node, ...values);
    } finally {
      if (was_hydrating) {
        set_hydrating(false);
      }
      boundary2.update_pending_count(-1);
      batch.decrement(blocking);
    }
  });
}

// node_modules/svelte/src/internal/client/dev/validation.js
function validate_snippet_args(anchor, ...args) {
  if (typeof anchor !== "object" || !(anchor instanceof Node)) {
    invalid_snippet_arguments();
  }
  for (let arg of args) {
    if (typeof arg !== "function") {
      invalid_snippet_arguments();
    }
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/await.js
var PENDING = 0;
var THEN = 1;
var CATCH = 2;
function await_block(node, get_input, pending_fn, then_fn, catch_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var runes = is_runes();
  var v = (
    /** @type {V} */
    UNINITIALIZED
  );
  var value = runes ? source(v) : mutable_source(v, false, false);
  var error = runes ? source(v) : mutable_source(v, false, false);
  var branches = new BranchManager(node);
  block(() => {
    var input = get_input();
    var destroyed = false;
    let mismatch = hydrating && is_promise(input) === (node.data === HYDRATION_START_ELSE);
    if (mismatch) {
      set_hydrate_node(skip_nodes());
      set_hydrating(false);
    }
    if (is_promise(input)) {
      var restore = capture();
      var resolved = false;
      const resolve = (fn) => {
        if (destroyed) return;
        resolved = true;
        restore(false);
        Batch.ensure();
        if (hydrating) {
          set_hydrating(false);
        }
        try {
          fn();
        } finally {
          unset_context();
          if (!is_flushing_sync) flushSync();
        }
      };
      input.then(
        (v2) => {
          resolve(() => {
            internal_set(value, v2);
            branches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));
          });
        },
        (e) => {
          resolve(() => {
            internal_set(error, e);
            branches.ensure(THEN, catch_fn && ((target) => catch_fn(target, error)));
            if (!catch_fn) {
              throw error.v;
            }
          });
        }
      );
      if (hydrating) {
        branches.ensure(PENDING, pending_fn);
      } else {
        queue_micro_task(() => {
          if (!resolved) {
            resolve(() => {
              branches.ensure(PENDING, pending_fn);
            });
          }
        });
      }
    } else {
      internal_set(value, input);
      branches.ensure(THEN, then_fn && ((target) => then_fn(target, value)));
    }
    if (mismatch) {
      set_hydrating(true);
    }
    return () => {
      destroyed = true;
    };
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(node, fn, elseif = false) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var flags2 = elseif ? EFFECT_TRANSPARENT : 0;
  function update_branch(key2, fn2) {
    if (hydrating) {
      const data = read_hydration_instruction(node);
      var hydrated_key;
      if (data === HYDRATION_START) {
        hydrated_key = 0;
      } else if (data === HYDRATION_START_ELSE) {
        hydrated_key = false;
      } else {
        hydrated_key = parseInt(data.substring(1));
      }
      if (key2 !== hydrated_key) {
        var anchor = skip_nodes();
        set_hydrate_node(anchor);
        branches.anchor = anchor;
        set_hydrating(false);
        branches.ensure(key2, fn2);
        set_hydrating(true);
        return;
      }
    }
    branches.ensure(key2, fn2);
  }
  block(() => {
    var has_branch = false;
    fn((fn2, key2 = 0) => {
      has_branch = true;
      update_branch(key2, fn2);
    });
    if (!has_branch) {
      update_branch(false, null);
    }
  }, flags2);
}

// node_modules/svelte/src/internal/client/dom/blocks/key.js
var NAN = Symbol("NaN");
function key(node, get_key, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  var legacy = !is_runes();
  block(() => {
    var key2 = get_key();
    if (key2 !== key2) {
      key2 = /** @type {any} */
      NAN;
    }
    if (legacy && key2 !== null && typeof key2 === "object") {
      key2 = /** @type {V} */
      {};
    }
    branches.ensure(key2, render_fn);
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/css-props.js
function css_props(element2, get_styles) {
  if (hydrating) {
    set_hydrate_node(get_first_child(element2));
  }
  render_effect(() => {
    var styles = get_styles();
    for (var key2 in styles) {
      var value = styles[key2];
      if (value) {
        element2.style.setProperty(key2, value);
      } else {
        element2.style.removeProperty(key2);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
function index(_, i) {
  return i;
}
function pause_effects(state2, to_destroy, controlled_anchor) {
  var transitions = [];
  var length = to_destroy.length;
  var group;
  var remaining = to_destroy.length;
  for (var i = 0; i < length; i++) {
    let effect2 = to_destroy[i];
    pause_effect(
      effect2,
      () => {
        if (group) {
          group.pending.delete(effect2);
          group.done.add(effect2);
          if (group.pending.size === 0) {
            var groups = (
              /** @type {Set<EachOutroGroup>} */
              state2.outrogroups
            );
            destroy_effects(array_from(group.done));
            groups.delete(group);
            if (groups.size === 0) {
              state2.outrogroups = null;
            }
          }
        } else {
          remaining -= 1;
        }
      },
      false
    );
  }
  if (remaining === 0) {
    var fast_path = transitions.length === 0 && controlled_anchor !== null;
    if (fast_path) {
      var anchor = (
        /** @type {Element} */
        controlled_anchor
      );
      var parent_node = (
        /** @type {Element} */
        anchor.parentNode
      );
      clear_text_content(parent_node);
      parent_node.append(anchor);
      state2.items.clear();
    }
    destroy_effects(to_destroy, !fast_path);
  } else {
    group = {
      pending: new Set(to_destroy),
      done: /* @__PURE__ */ new Set()
    };
    (state2.outrogroups ??= /* @__PURE__ */ new Set()).add(group);
  }
}
function destroy_effects(to_destroy, remove_dom = true) {
  for (var i = 0; i < to_destroy.length; i++) {
    destroy_effect(to_destroy[i], remove_dom);
  }
}
var offscreen_anchor;
function each(node, flags2, get_collection, get_key, render_fn, fallback_fn = null) {
  var anchor = node;
  var items = /* @__PURE__ */ new Map();
  var is_controlled = (flags2 & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      node
    );
    anchor = hydrating ? set_hydrate_node(get_first_child(parent_node)) : parent_node.appendChild(create_text());
  }
  if (hydrating) {
    hydrate_next();
  }
  var fallback2 = null;
  var each_array = derived_safe_equal(() => {
    var collection = get_collection();
    return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
  });
  var array;
  var first_run = true;
  function commit() {
    state2.fallback = fallback2;
    reconcile(state2, array, anchor, flags2, get_key);
    if (fallback2 !== null) {
      if (array.length === 0) {
        if ((fallback2.f & EFFECT_OFFSCREEN) === 0) {
          resume_effect(fallback2);
        } else {
          fallback2.f ^= EFFECT_OFFSCREEN;
          move(fallback2, null, anchor);
        }
      } else {
        pause_effect(fallback2, () => {
          fallback2 = null;
        });
      }
    }
  }
  var effect2 = block(() => {
    array = /** @type {V[]} */
    get(each_array);
    var length = array.length;
    let mismatch = false;
    if (hydrating) {
      var is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;
      if (is_else !== (length === 0)) {
        anchor = skip_nodes();
        set_hydrate_node(anchor);
        set_hydrating(false);
        mismatch = true;
      }
    }
    var keys = /* @__PURE__ */ new Set();
    var batch = (
      /** @type {Batch} */
      current_batch
    );
    var defer = should_defer_append();
    for (var index2 = 0; index2 < length; index2 += 1) {
      if (hydrating && hydrate_node.nodeType === COMMENT_NODE && /** @type {Comment} */
      hydrate_node.data === HYDRATION_END) {
        anchor = /** @type {Comment} */
        hydrate_node;
        mismatch = true;
        set_hydrating(false);
      }
      var value = array[index2];
      var key2 = get_key(value, index2);
      var item = first_run ? null : items.get(key2);
      if (item) {
        if (item.v) internal_set(item.v, value);
        if (item.i) internal_set(item.i, index2);
        if (defer) {
          batch.unskip_effect(item.e);
        }
      } else {
        item = create_item(
          items,
          first_run ? anchor : offscreen_anchor ??= create_text(),
          value,
          key2,
          index2,
          render_fn,
          flags2,
          get_collection
        );
        if (!first_run) {
          item.e.f |= EFFECT_OFFSCREEN;
        }
        items.set(key2, item);
      }
      keys.add(key2);
    }
    if (length === 0 && fallback_fn && !fallback2) {
      if (first_run) {
        fallback2 = branch(() => fallback_fn(anchor));
      } else {
        fallback2 = branch(() => fallback_fn(offscreen_anchor ??= create_text()));
        fallback2.f |= EFFECT_OFFSCREEN;
      }
    }
    if (length > keys.size) {
      if (dev_fallback_default) {
        validate_each_keys(array, get_key);
      } else {
        each_key_duplicate("", "", "");
      }
    }
    if (hydrating && length > 0) {
      set_hydrate_node(skip_nodes());
    }
    if (!first_run) {
      if (defer) {
        for (const [key3, item2] of items) {
          if (!keys.has(key3)) {
            batch.skip_effect(item2.e);
          }
        }
        batch.oncommit(commit);
        batch.ondiscard(() => {
        });
      } else {
        commit();
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
    get(each_array);
  });
  var state2 = { effect: effect2, flags: flags2, items, outrogroups: null, fallback: fallback2 };
  first_run = false;
  if (hydrating) {
    anchor = hydrate_node;
  }
}
function skip_to_branch(effect2) {
  while (effect2 !== null && (effect2.f & BRANCH_EFFECT) === 0) {
    effect2 = effect2.next;
  }
  return effect2;
}
function reconcile(state2, array, anchor, flags2, get_key) {
  var is_animated = (flags2 & EACH_IS_ANIMATED) !== 0;
  var length = array.length;
  var items = state2.items;
  var current = skip_to_branch(state2.effect.first);
  var seen;
  var prev = null;
  var to_animate;
  var matched = [];
  var stashed = [];
  var value;
  var key2;
  var effect2;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array[i];
      key2 = get_key(value, i);
      effect2 = /** @type {EachItem} */
      items.get(key2).e;
      if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
        effect2.nodes?.a?.measure();
        (to_animate ??= /* @__PURE__ */ new Set()).add(effect2);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array[i];
    key2 = get_key(value, i);
    effect2 = /** @type {EachItem} */
    items.get(key2).e;
    if (state2.outrogroups !== null) {
      for (const group of state2.outrogroups) {
        group.pending.delete(effect2);
        group.done.delete(effect2);
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) !== 0) {
      effect2.f ^= EFFECT_OFFSCREEN;
      if (effect2 === current) {
        move(effect2, null, anchor);
      } else {
        var next2 = prev ? prev.next : current;
        if (effect2 === state2.effect.last) {
          state2.effect.last = effect2.prev;
        }
        if (effect2.prev) effect2.prev.next = effect2.next;
        if (effect2.next) effect2.next.prev = effect2.prev;
        link(state2, prev, effect2);
        link(state2, effect2, next2);
        move(effect2, next2, anchor);
        prev = effect2;
        matched = [];
        stashed = [];
        current = skip_to_branch(prev.next);
        continue;
      }
    }
    if ((effect2.f & INERT) !== 0) {
      resume_effect(effect2);
      if (is_animated) {
        effect2.nodes?.a?.unfix();
        (to_animate ??= /* @__PURE__ */ new Set()).delete(effect2);
      }
    }
    if (effect2 !== current) {
      if (seen !== void 0 && seen.has(effect2)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen.delete(stashed[j]);
          }
          link(state2, a.prev, b.next);
          link(state2, prev, a);
          link(state2, b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(effect2);
          move(effect2, current, anchor);
          link(state2, effect2.prev, effect2.next);
          link(state2, effect2, prev === null ? state2.effect.first : prev.next);
          link(state2, prev, effect2);
          prev = effect2;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current !== effect2) {
        (seen ??= /* @__PURE__ */ new Set()).add(current);
        stashed.push(current);
        current = skip_to_branch(current.next);
      }
      if (current === null) {
        continue;
      }
    }
    if ((effect2.f & EFFECT_OFFSCREEN) === 0) {
      matched.push(effect2);
    }
    prev = effect2;
    current = skip_to_branch(effect2.next);
  }
  if (state2.outrogroups !== null) {
    for (const group of state2.outrogroups) {
      if (group.pending.size === 0) {
        destroy_effects(array_from(group.done));
        state2.outrogroups?.delete(group);
      }
    }
    if (state2.outrogroups.size === 0) {
      state2.outrogroups = null;
    }
  }
  if (current !== null || seen !== void 0) {
    var to_destroy = [];
    if (seen !== void 0) {
      for (effect2 of seen) {
        if ((effect2.f & INERT) === 0) {
          to_destroy.push(effect2);
        }
      }
    }
    while (current !== null) {
      if ((current.f & INERT) === 0 && current !== state2.fallback) {
        to_destroy.push(current);
      }
      current = skip_to_branch(current.next);
    }
    var destroy_length = to_destroy.length;
    if (destroy_length > 0) {
      var controlled_anchor = (flags2 & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
      if (is_animated) {
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].nodes?.a?.measure();
        }
        for (i = 0; i < destroy_length; i += 1) {
          to_destroy[i].nodes?.a?.fix();
        }
      }
      pause_effects(state2, to_destroy, controlled_anchor);
    }
  }
  if (is_animated) {
    queue_micro_task(() => {
      if (to_animate === void 0) return;
      for (effect2 of to_animate) {
        effect2.nodes?.a?.apply();
      }
    });
  }
}
function create_item(items, anchor, value, key2, index2, render_fn, flags2, get_collection) {
  var v = (flags2 & EACH_ITEM_REACTIVE) !== 0 ? (flags2 & EACH_ITEM_IMMUTABLE) === 0 ? mutable_source(value, false, false) : source(value) : null;
  var i = (flags2 & EACH_INDEX_REACTIVE) !== 0 ? source(index2) : null;
  if (dev_fallback_default && v) {
    v.trace = () => {
      get_collection()[i?.v ?? index2];
    };
  }
  return {
    v,
    i,
    e: branch(() => {
      render_fn(anchor, v ?? value, i ?? index2, get_collection);
      return () => {
        items.delete(key2);
      };
    })
  };
}
function move(effect2, next2, anchor) {
  if (!effect2.nodes) return;
  var node = effect2.nodes.start;
  var end = effect2.nodes.end;
  var dest = next2 && (next2.f & EFFECT_OFFSCREEN) === 0 ? (
    /** @type {EffectNodes} */
    next2.nodes.start
  ) : anchor;
  while (node !== null) {
    var next_node = (
      /** @type {TemplateNode} */
      get_next_sibling(node)
    );
    dest.before(node);
    if (node === end) {
      return;
    }
    node = next_node;
  }
}
function link(state2, prev, next2) {
  if (prev === null) {
    state2.effect.first = next2;
  } else {
    prev.next = next2;
  }
  if (next2 === null) {
    state2.effect.last = prev;
  } else {
    next2.prev = prev;
  }
}
function validate_each_keys(array, key_fn) {
  const keys = /* @__PURE__ */ new Map();
  const length = array.length;
  for (let i = 0; i < length; i++) {
    const key2 = key_fn(array[i], i);
    if (keys.has(key2)) {
      const a = String(keys.get(key2));
      const b = String(i);
      let k = String(key2);
      if (k.startsWith("[object ")) k = null;
      each_key_duplicate(a, b, k);
    }
    keys.set(key2, i);
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/html.js
function check_hash(element2, server_hash, value) {
  if (!server_hash || server_hash === hash(String(value ?? ""))) return;
  let location;
  const loc = element2.__svelte_meta?.loc;
  if (loc) {
    location = `near ${loc.file}:${loc.line}:${loc.column}`;
  } else if (dev_current_component_function?.[FILENAME]) {
    location = `in ${dev_current_component_function[FILENAME]}`;
  }
  hydration_html_changed(sanitize_location(location));
}
function html(node, get_value, svg = false, mathml = false, skip_warning = false) {
  var anchor = node;
  var value = "";
  template_effect(() => {
    var effect2 = (
      /** @type {Effect} */
      active_effect
    );
    if (value === (value = get_value() ?? "")) {
      if (hydrating) hydrate_next();
      return;
    }
    if (effect2.nodes !== null) {
      remove_effect_dom(
        effect2.nodes.start,
        /** @type {TemplateNode} */
        effect2.nodes.end
      );
      effect2.nodes = null;
    }
    if (value === "") return;
    if (hydrating) {
      var hash2 = (
        /** @type {Comment} */
        hydrate_node.data
      );
      var next2 = hydrate_next();
      var last = next2;
      while (next2 !== null && (next2.nodeType !== COMMENT_NODE || /** @type {Comment} */
      next2.data !== "")) {
        last = next2;
        next2 = get_next_sibling(next2);
      }
      if (next2 === null) {
        hydration_mismatch();
        throw HYDRATION_ERROR;
      }
      if (dev_fallback_default && !skip_warning) {
        check_hash(
          /** @type {Element} */
          next2.parentNode,
          hash2,
          value
        );
      }
      assign_nodes(hydrate_node, last);
      anchor = set_hydrate_node(next2);
      return;
    }
    var html2 = value + "";
    if (svg) html2 = `<svg>${html2}</svg>`;
    else if (mathml) html2 = `<math>${html2}</math>`;
    var node2 = create_fragment_from_html(html2);
    if (svg || mathml) {
      node2 = /** @type {Element} */
      get_first_child(node2);
    }
    assign_nodes(
      /** @type {TemplateNode} */
      get_first_child(node2),
      /** @type {TemplateNode} */
      node2.lastChild
    );
    if (svg || mathml) {
      while (get_first_child(node2)) {
        anchor.before(
          /** @type {TemplateNode} */
          get_first_child(node2)
        );
      }
    } else {
      anchor.before(node2);
    }
  });
}

// node_modules/svelte/src/internal/client/dom/blocks/slot.js
function slot(anchor, $$props, name, slot_props, fallback_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var slot_fn = $$props.$$slots?.[name];
  var is_interop = false;
  if (slot_fn === true) {
    slot_fn = $$props[name === "default" ? "children" : name];
    is_interop = true;
  }
  if (slot_fn === void 0) {
    if (fallback_fn !== null) {
      fallback_fn(anchor);
    }
  } else {
    slot_fn(anchor, is_interop ? () => slot_props : slot_props);
  }
}
function sanitize_slots(props) {
  const sanitized = {};
  if (props.children) sanitized.default = true;
  for (const key2 in props.$$slots) {
    sanitized[key2] = true;
  }
  return sanitized;
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js
function component(node, get_component, render_fn) {
  if (hydrating) {
    hydrate_next();
  }
  var branches = new BranchManager(node);
  block(() => {
    var component2 = get_component() ?? null;
    branches.ensure(component2, component2 && ((target) => render_fn(target, component2)));
  }, EFFECT_TRANSPARENT);
}

// node_modules/svelte/src/internal/client/timing.js
var now = true_default ? () => performance.now() : () => Date.now();
var raf = {
  // don't access requestAnimationFrame eagerly outside method
  // this allows basic testing of user code without JSDOM
  // bunder will eval and remove ternary when the user's app is built
  tick: (
    /** @param {any} _ */
    (_) => (true_default ? requestAnimationFrame : noop)(_)
  ),
  now: () => now(),
  tasks: /* @__PURE__ */ new Set()
};

// node_modules/svelte/src/internal/client/loop.js
function run_tasks() {
  const now2 = raf.now();
  raf.tasks.forEach((task) => {
    if (!task.c(now2)) {
      raf.tasks.delete(task);
      task.f();
    }
  });
  if (raf.tasks.size !== 0) {
    raf.tick(run_tasks);
  }
}
function loop(callback) {
  let task;
  if (raf.tasks.size === 0) {
    raf.tick(run_tasks);
  }
  return {
    promise: new Promise((fulfill) => {
      raf.tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      raf.tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/internal/client/dom/elements/transitions.js
function dispatch_event(element2, type) {
  without_reactive_context(() => {
    element2.dispatchEvent(new CustomEvent(type));
  });
}
function css_property_to_camelcase(style) {
  if (style === "float") return "cssFloat";
  if (style === "offset") return "cssOffset";
  if (style.startsWith("--")) return style;
  const parts = style.split("-");
  if (parts.length === 1) return parts[0];
  return parts[0] + parts.slice(1).map(
    /** @param {any} word */
    (word) => word[0].toUpperCase() + word.slice(1)
  ).join("");
}
function css_to_keyframe(css) {
  const keyframe = {};
  const parts = css.split(";");
  for (const part of parts) {
    const [property, value] = part.split(":");
    if (!property || value === void 0) break;
    const formatted_property = css_property_to_camelcase(property.trim());
    keyframe[formatted_property] = value.trim();
  }
  return keyframe;
}
var linear = (t) => t;
var animation_effect_override = null;
function set_animation_effect_override(v) {
  animation_effect_override = v;
}
function animation(element2, get_fn, get_params) {
  var effect2 = animation_effect_override ?? /** @type {Effect} */
  active_effect;
  var nodes = (
    /** @type {EffectNodes} */
    effect2.nodes
  );
  var from;
  var to;
  var animation2;
  var original_styles = null;
  nodes.a ??= {
    element: element2,
    measure() {
      from = this.element.getBoundingClientRect();
    },
    apply() {
      animation2?.abort();
      to = this.element.getBoundingClientRect();
      if (from.left !== to.left || from.right !== to.right || from.top !== to.top || from.bottom !== to.bottom) {
        const options = get_fn()(this.element, { from, to }, get_params?.());
        animation2 = animate(this.element, options, void 0, 1, () => {
          animation2?.abort();
          animation2 = void 0;
        });
      }
    },
    fix() {
      if (element2.getAnimations().length) return;
      var { position, width, height } = getComputedStyle(element2);
      if (position !== "absolute" && position !== "fixed") {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        original_styles = {
          position: style.position,
          width: style.width,
          height: style.height,
          transform: style.transform
        };
        style.position = "absolute";
        style.width = width;
        style.height = height;
        var to2 = element2.getBoundingClientRect();
        if (from.left !== to2.left || from.top !== to2.top) {
          var transform = `translate(${from.left - to2.left}px, ${from.top - to2.top}px)`;
          style.transform = style.transform ? `${style.transform} ${transform}` : transform;
        }
      }
    },
    unfix() {
      if (original_styles) {
        var style = (
          /** @type {HTMLElement | SVGElement} */
          element2.style
        );
        style.position = original_styles.position;
        style.width = original_styles.width;
        style.height = original_styles.height;
        style.transform = original_styles.transform;
      }
    }
  };
  nodes.a.element = element2;
}
function transition(flags2, element2, get_fn, get_params) {
  var is_intro = (flags2 & TRANSITION_IN) !== 0;
  var is_outro = (flags2 & TRANSITION_OUT) !== 0;
  var is_both = is_intro && is_outro;
  var is_global = (flags2 & TRANSITION_GLOBAL) !== 0;
  var direction = is_both ? "both" : is_intro ? "in" : "out";
  var current_options;
  var inert = element2.inert;
  var overflow = element2.style.overflow;
  var intro;
  var outro;
  function get_options() {
    return without_reactive_context(() => {
      return current_options ??= get_fn()(element2, get_params?.() ?? /** @type {P} */
      {}, {
        direction
      });
    });
  }
  var transition2 = {
    is_global,
    in() {
      element2.inert = inert;
      if (!is_intro) {
        outro?.abort();
        outro?.reset?.();
        return;
      }
      if (!is_outro) {
        intro?.abort();
      }
      intro = animate(element2, get_options(), outro, 1, () => {
        dispatch_event(element2, "introend");
        intro?.abort();
        intro = current_options = void 0;
        element2.style.overflow = overflow;
      });
    },
    out(fn) {
      if (!is_outro) {
        fn?.();
        current_options = void 0;
        return;
      }
      element2.inert = true;
      outro = animate(element2, get_options(), intro, 0, () => {
        dispatch_event(element2, "outroend");
        fn?.();
      });
    },
    stop: () => {
      intro?.abort();
      outro?.abort();
    }
  };
  var e = (
    /** @type {Effect & { nodes: EffectNodes }} */
    active_effect
  );
  (e.nodes.t ??= []).push(transition2);
  if (is_intro && should_intro) {
    var run4 = is_global;
    if (!run4) {
      var block2 = (
        /** @type {Effect | null} */
        e.parent
      );
      while (block2 && (block2.f & EFFECT_TRANSPARENT) !== 0) {
        while (block2 = block2.parent) {
          if ((block2.f & BLOCK_EFFECT) !== 0) break;
        }
      }
      run4 = !block2 || (block2.f & REACTION_RAN) !== 0;
    }
    if (run4) {
      effect(() => {
        untrack(() => transition2.in());
      });
    }
  }
}
function animate(element2, options, counterpart, t2, on_finish) {
  var is_intro = t2 === 1;
  if (is_function(options)) {
    var a;
    var aborted2 = false;
    queue_micro_task(() => {
      if (aborted2) return;
      var o = options({ direction: is_intro ? "in" : "out" });
      a = animate(element2, o, counterpart, t2, on_finish);
    });
    return {
      abort: () => {
        aborted2 = true;
        a?.abort();
      },
      deactivate: () => a.deactivate(),
      reset: () => a.reset(),
      t: () => a.t()
    };
  }
  counterpart?.deactivate();
  if (!options?.duration && !options?.delay) {
    dispatch_event(element2, is_intro ? "introstart" : "outrostart");
    on_finish();
    return {
      abort: noop,
      deactivate: noop,
      reset: noop,
      t: () => t2
    };
  }
  const { delay: delay2 = 0, css, tick: tick2, easing = linear } = options;
  var keyframes = [];
  if (is_intro && counterpart === void 0) {
    if (tick2) {
      tick2(0, 1);
    }
    if (css) {
      var styles = css_to_keyframe(css(0, 1));
      keyframes.push(styles, styles);
    }
  }
  var get_t = () => 1 - t2;
  var animation2 = element2.animate(keyframes, { duration: delay2, fill: "forwards" });
  animation2.onfinish = () => {
    animation2.cancel();
    dispatch_event(element2, is_intro ? "introstart" : "outrostart");
    var t1 = counterpart?.t() ?? 1 - t2;
    counterpart?.abort();
    var delta = t2 - t1;
    var duration = (
      /** @type {number} */
      options.duration * Math.abs(delta)
    );
    var keyframes2 = [];
    if (duration > 0) {
      var needs_overflow_hidden = false;
      if (css) {
        var n = Math.ceil(duration / (1e3 / 60));
        for (var i = 0; i <= n; i += 1) {
          var t = t1 + delta * easing(i / n);
          var styles2 = css_to_keyframe(css(t, 1 - t));
          keyframes2.push(styles2);
          needs_overflow_hidden ||= styles2.overflow === "hidden";
        }
      }
      if (needs_overflow_hidden) {
        element2.style.overflow = "hidden";
      }
      get_t = () => {
        var time = (
          /** @type {number} */
          /** @type {globalThis.Animation} */
          animation2.currentTime
        );
        return t1 + delta * easing(time / duration);
      };
      if (tick2) {
        loop(() => {
          if (animation2.playState !== "running") return false;
          var t3 = get_t();
          tick2(t3, 1 - t3);
          return true;
        });
      }
    }
    animation2 = element2.animate(keyframes2, { duration, fill: "forwards" });
    animation2.onfinish = () => {
      get_t = () => t2;
      tick2?.(t2, 1 - t2);
      on_finish();
    };
  };
  return {
    abort: () => {
      if (animation2) {
        animation2.cancel();
        animation2.effect = null;
        animation2.onfinish = noop;
      }
    },
    deactivate: () => {
      on_finish = noop;
    },
    reset: () => {
      if (t2 === 0) {
        tick2?.(1, 0);
      }
    },
    t: () => get_t()
  };
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-element.js
function element(node, get_tag, is_svg2, render_fn, get_namespace, location) {
  let was_hydrating = hydrating;
  if (hydrating) {
    hydrate_next();
  }
  var filename = dev_fallback_default && location && component_context?.function[FILENAME];
  var element2 = null;
  if (hydrating && hydrate_node.nodeType === ELEMENT_NODE) {
    element2 = /** @type {Element} */
    hydrate_node;
    hydrate_next();
  }
  var anchor = (
    /** @type {TemplateNode} */
    hydrating ? hydrate_node : node
  );
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  var branches = new BranchManager(anchor, false);
  block(() => {
    const next_tag = get_tag() || null;
    var ns = get_namespace ? get_namespace() : is_svg2 || next_tag === "svg" ? NAMESPACE_SVG : void 0;
    if (next_tag === null) {
      branches.ensure(null, null);
      set_should_intro(true);
      return;
    }
    branches.ensure(next_tag, (anchor2) => {
      if (next_tag) {
        element2 = hydrating ? (
          /** @type {Element} */
          element2
        ) : create_element(next_tag, ns);
        if (dev_fallback_default && location) {
          element2.__svelte_meta = {
            parent: dev_stack,
            loc: {
              file: filename,
              line: location[0],
              column: location[1]
            }
          };
        }
        assign_nodes(element2, element2);
        if (render_fn) {
          if (hydrating && is_raw_text_element(next_tag)) {
            element2.append(document.createComment(""));
          }
          var child_anchor = hydrating ? get_first_child(element2) : element2.appendChild(create_text());
          if (hydrating) {
            if (child_anchor === null) {
              set_hydrating(false);
            } else {
              set_hydrate_node(child_anchor);
            }
          }
          set_animation_effect_override(parent_effect);
          render_fn(element2, child_anchor);
          set_animation_effect_override(null);
        }
        active_effect.nodes.end = element2;
        anchor2.before(element2);
      }
      if (hydrating) {
        set_hydrate_node(anchor2);
      }
    });
    set_should_intro(true);
    return () => {
      if (next_tag) {
        set_should_intro(false);
      }
    };
  }, EFFECT_TRANSPARENT);
  teardown(() => {
    set_should_intro(true);
  });
  if (was_hydrating) {
    set_hydrating(true);
    set_hydrate_node(anchor);
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
function head(hash2, render_fn) {
  let previous_hydrate_node = null;
  let was_hydrating = hydrating;
  var anchor;
  if (hydrating) {
    previous_hydrate_node = hydrate_node;
    var head_anchor = get_first_child(document.head);
    while (head_anchor !== null && (head_anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    head_anchor.data !== hash2)) {
      head_anchor = get_next_sibling(head_anchor);
    }
    if (head_anchor === null) {
      set_hydrating(false);
    } else {
      var start = (
        /** @type {TemplateNode} */
        get_next_sibling(head_anchor)
      );
      head_anchor.remove();
      set_hydrate_node(start);
    }
  }
  if (!hydrating) {
    anchor = document.head.appendChild(create_text());
  }
  try {
    block(() => render_fn(anchor), HEAD_EFFECT);
  } finally {
    if (was_hydrating) {
      set_hydrating(true);
      set_hydrate_node(
        /** @type {TemplateNode} */
        previous_hydrate_node
      );
    }
  }
}

// node_modules/svelte/src/internal/client/dom/css.js
function append_styles(anchor, css) {
  effect(() => {
    var root5 = anchor.getRootNode();
    var target = (
      /** @type {ShadowRoot} */
      root5.host ? (
        /** @type {ShadowRoot} */
        root5
      ) : (
        /** @type {Document} */
        root5.head ?? /** @type {Document} */
        root5.ownerDocument.head
      )
    );
    if (!target.querySelector("#" + css.hash)) {
      const style = create_element("style");
      style.id = css.hash;
      style.textContent = css.code;
      target.appendChild(style);
      if (dev_fallback_default) {
        register_style(css.hash, style);
      }
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/actions.js
function action(dom, action2, get_value) {
  effect(() => {
    var payload = untrack(() => action2(dom, get_value?.()) || {});
    if (get_value && payload?.update) {
      var inited = false;
      var prev = (
        /** @type {any} */
        {}
      );
      render_effect(() => {
        var value = get_value();
        deep_read_state(value);
        if (inited && safe_not_equal(prev, value)) {
          prev = value;
          payload.update(value);
        }
      });
      inited = true;
    }
    if (payload?.destroy) {
      return () => (
        /** @type {Function} */
        payload.destroy()
      );
    }
  });
}

// node_modules/svelte/src/internal/client/dom/elements/attachments.js
function attach(node, get_fn) {
  var fn = void 0;
  var e;
  managed(() => {
    if (fn !== (fn = get_fn())) {
      if (e) {
        destroy_effect(e);
        e = null;
      }
      if (fn) {
        e = branch(() => {
          effect(() => (
            /** @type {(node: Element) => void} */
            fn(node)
          ));
        });
      }
    }
  });
}

// node_modules/svelte/src/escaping.js
var ATTR_REGEX = /[&"<]/g;
var CONTENT_REGEX = /[&<]/g;
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern.lastIndex = 0;
  let escaped = "";
  let last = 0;
  while (pattern.test(str)) {
    const i = pattern.lastIndex - 1;
    const ch = str[i];
    escaped += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped + str.substring(last);
}

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/svelte/src/internal/shared/attributes.js
var replacements = {
  translate: /* @__PURE__ */ new Map([
    [true, "yes"],
    [false, "no"]
  ])
};
function attr(name, value, is_boolean = false) {
  if (name === "hidden" && value !== "until-found") {
    is_boolean = true;
  }
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? `=""` : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value ?? "";
  }
}
var whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a = 0;
        while ((a = classname.indexOf(key2, a)) >= 0) {
          var b = a + len;
          if ((a === 0 || whitespace.includes(classname[a - 1])) && (b === classname.length || whitespace.includes(classname[b]))) {
            classname = (a === 0 ? "" : classname.substring(0, a)) + classname.substring(b + 1);
          } else {
            a = b;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles2(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i = 0; i < len; i++) {
        var c = value[i];
        if (in_comment) {
          if (c === "/" && value[i - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c) {
            in_str = false;
          }
        } else if (c === "/" && value[i + 1] === "*") {
          in_comment = true;
        } else if (c === '"' || c === "'") {
          in_str = c;
        } else if (c === "(") {
          in_apo++;
        } else if (c === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c === ":" && name_index === -1) {
            name_index = i;
          } else if (c === ";" || i === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c !== ";") {
                  i++;
                }
                var property = value.substring(start_index, i).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles2(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles2(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}

// node_modules/svelte/src/internal/client/dom/elements/class.js
function set_class(dom, is_html, value, hash2, prev_classes, next_classes) {
  var prev = dom.__className;
  if (hydrating || prev !== value || prev === void 0) {
    var next_class_name = to_class(value, hash2, next_classes);
    if (!hydrating || next_class_name !== dom.getAttribute("class")) {
      if (next_class_name == null) {
        dom.removeAttribute("class");
      } else if (is_html) {
        dom.className = next_class_name;
      } else {
        dom.setAttribute("class", next_class_name);
      }
    }
    dom.__className = value;
  } else if (next_classes && prev_classes !== next_classes) {
    for (var key2 in next_classes) {
      var is_present = !!next_classes[key2];
      if (prev_classes == null || is_present !== !!prev_classes[key2]) {
        dom.classList.toggle(key2, is_present);
      }
    }
  }
  return next_classes;
}

// node_modules/svelte/src/internal/client/dom/elements/style.js
function update_styles(dom, prev = {}, next2, priority) {
  for (var key2 in next2) {
    var value = next2[key2];
    if (prev[key2] !== value) {
      if (next2[key2] == null) {
        dom.style.removeProperty(key2);
      } else {
        dom.style.setProperty(key2, value, priority);
      }
    }
  }
}
function set_style(dom, value, prev_styles, next_styles) {
  var prev = dom.__style;
  if (hydrating || prev !== value) {
    var next_style_attr = to_style(value, next_styles);
    if (!hydrating || next_style_attr !== dom.getAttribute("style")) {
      if (next_style_attr == null) {
        dom.removeAttribute("style");
      } else {
        dom.style.cssText = next_style_attr;
      }
    }
    dom.__style = value;
  } else if (next_styles) {
    if (Array.isArray(next_styles)) {
      update_styles(dom, prev_styles?.[0], next_styles[0]);
      update_styles(dom, prev_styles?.[1], next_styles[1], "important");
    } else {
      update_styles(dom, prev_styles, next_styles);
    }
  }
  return next_styles;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/select.js
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
      return select_multiple_invalid_value();
    }
    for (var option of select.options) {
      option.selected = value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (is(option_value, value)) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function init_select(select) {
  var observer = new MutationObserver(() => {
    select_option(select, select.__value);
  });
  observer.observe(select, {
    // Listen to option element changes
    childList: true,
    subtree: true,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: true,
    attributeFilter: ["value"]
  });
  teardown(() => {
    observer.disconnect();
  });
}
function bind_select_value(select, get3, set3 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  var mounting = true;
  listen_to_event_and_reset_event(select, "change", (is_reset) => {
    var query = is_reset ? "[selected]" : ":checked";
    var value;
    if (select.multiple) {
      value = [].map.call(select.querySelectorAll(query), get_option_value);
    } else {
      var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
      select.querySelector("option:not([disabled])");
      value = selected_option && get_option_value(selected_option);
    }
    set3(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  });
  effect(() => {
    var value = get3();
    if (select === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    select_option(select, value, mounting);
    if (mounting && value === void 0) {
      var selected_option = select.querySelector(":checked");
      if (selected_option !== null) {
        value = get_option_value(selected_option);
        set3(value);
      }
    }
    select.__value = value;
    mounting = false;
  });
  init_select(select);
}
function get_option_value(option) {
  if ("__value" in option) {
    return option.__value;
  } else {
    return option.value;
  }
}

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
var CLASS = Symbol("class");
var STYLE = Symbol("style");
var IS_CUSTOM_ELEMENT = Symbol("is custom element");
var IS_HTML = Symbol("is html");
var LINK_TAG = IS_XHTML ? "link" : "LINK";
var INPUT_TAG = IS_XHTML ? "input" : "INPUT";
var OPTION_TAG = IS_XHTML ? "option" : "OPTION";
var SELECT_TAG = IS_XHTML ? "select" : "SELECT";
var PROGRESS_TAG = IS_XHTML ? "progress" : "PROGRESS";
function remove_input_defaults(input) {
  if (!hydrating) return;
  var already_removed = false;
  var remove_defaults = () => {
    if (already_removed) return;
    already_removed = true;
    if (input.hasAttribute("value")) {
      var value = input.value;
      set_attribute2(input, "value", null);
      input.value = value;
    }
    if (input.hasAttribute("checked")) {
      var checked = input.checked;
      set_attribute2(input, "checked", null);
      input.checked = checked;
    }
  };
  input.__on_r = remove_defaults;
  queue_micro_task(remove_defaults);
  add_form_reset_listener();
}
function set_value(element2, value) {
  var attributes = get_attributes(element2);
  if (attributes.value === (attributes.value = // treat null and undefined the same for the initial value
  value ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  element2.value === value && (value !== 0 || element2.nodeName !== PROGRESS_TAG)) {
    return;
  }
  element2.value = value ?? "";
}
function set_checked(element2, checked) {
  var attributes = get_attributes(element2);
  if (attributes.checked === (attributes.checked = // treat null and undefined the same for the initial value
  checked ?? void 0)) {
    return;
  }
  element2.checked = checked;
}
function set_selected(element2, selected) {
  if (selected) {
    if (!element2.hasAttribute("selected")) {
      element2.setAttribute("selected", "");
    }
  } else {
    element2.removeAttribute("selected");
  }
}
function set_default_checked(element2, checked) {
  const existing_value = element2.checked;
  element2.defaultChecked = checked;
  element2.checked = existing_value;
}
function set_default_value(element2, value) {
  const existing_value = element2.value;
  element2.defaultValue = value;
  element2.value = existing_value;
}
function set_attribute2(element2, attribute, value, skip_warning) {
  var attributes = get_attributes(element2);
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "srcset" || attribute === "href" && element2.nodeName === LINK_TAG) {
      if (!skip_warning) {
        check_src_in_dev_hydration(element2, attribute, value ?? "");
      }
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value)) return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value == null) {
    element2.removeAttribute(attribute);
  } else if (typeof value !== "string" && get_setters(element2).includes(attribute)) {
    element2[attribute] = value;
  } else {
    element2.setAttribute(attribute, value);
  }
}
function set_xlink_attribute(dom, attribute, value) {
  dom.setAttributeNS("http://www.w3.org/1999/xlink", attribute, value);
}
function set_custom_element_data(node, prop2, value) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  let was_hydrating = hydrating;
  if (hydrating) {
    set_hydrating(false);
  }
  set_active_reaction(null);
  set_active_effect(null);
  try {
    if (
      // `style` should use `set_attribute` rather than the setter
      prop2 !== "style" && // Don't compute setters for custom elements while they aren't registered yet,
      // because during their upgrade/instantiation they might add more setters.
      // Instead, fall back to a simple "an object, then set as property" heuristic.
      (setters_cache.has(node.getAttribute("is") || node.nodeName) || // customElements may not be available in browser extension contexts
      !customElements || customElements.get(node.getAttribute("is") || node.nodeName.toLowerCase()) ? get_setters(node).includes(prop2) : value && typeof value === "object")
    ) {
      node[prop2] = value;
    } else {
      set_attribute2(node, prop2, value == null ? value : String(value));
    }
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
    if (was_hydrating) {
      set_hydrating(true);
    }
  }
}
function set_attributes(element2, prev, next2, css_hash, should_remove_defaults = false, skip_warning = false) {
  if (hydrating && should_remove_defaults && element2.nodeName === INPUT_TAG) {
    var input = (
      /** @type {HTMLInputElement} */
      element2
    );
    var attribute = input.type === "checkbox" ? "defaultChecked" : "defaultValue";
    if (!(attribute in next2)) {
      remove_input_defaults(input);
    }
  }
  var attributes = get_attributes(element2);
  var is_custom_element = attributes[IS_CUSTOM_ELEMENT];
  var preserve_attribute_case = !attributes[IS_HTML];
  let is_hydrating_custom_element = hydrating && is_custom_element;
  if (is_hydrating_custom_element) {
    set_hydrating(false);
  }
  var current = prev || {};
  var is_option_element = element2.nodeName === OPTION_TAG;
  for (var key2 in prev) {
    if (!(key2 in next2)) {
      next2[key2] = null;
    }
  }
  if (next2.class) {
    next2.class = clsx2(next2.class);
  } else if (css_hash || next2[CLASS]) {
    next2.class = null;
  }
  if (next2[STYLE]) {
    next2.style ??= null;
  }
  var setters = get_setters(element2);
  for (const key3 in next2) {
    let value = next2[key3];
    if (is_option_element && key3 === "value" && value == null) {
      element2.value = element2.__value = "";
      current[key3] = value;
      continue;
    }
    if (key3 === "class") {
      var is_html = element2.namespaceURI === "http://www.w3.org/1999/xhtml";
      set_class(element2, is_html, value, css_hash, prev?.[CLASS], next2[CLASS]);
      current[key3] = value;
      current[CLASS] = next2[CLASS];
      continue;
    }
    if (key3 === "style") {
      set_style(element2, value, prev?.[STYLE], next2[STYLE]);
      current[key3] = value;
      current[STYLE] = next2[STYLE];
      continue;
    }
    var prev_value = current[key3];
    if (value === prev_value && !(value === void 0 && element2.hasAttribute(key3))) {
      continue;
    }
    current[key3] = value;
    var prefix = key3[0] + key3[1];
    if (prefix === "$$") continue;
    if (prefix === "on") {
      const opts = {};
      const event_handle_key = "$$" + key3;
      let event_name = key3.slice(2);
      var is_delegated = can_delegate_event(event_name);
      if (is_capture_event(event_name)) {
        event_name = event_name.slice(0, -7);
        opts.capture = true;
      }
      if (!is_delegated && prev_value) {
        if (value != null) continue;
        element2.removeEventListener(event_name, current[event_handle_key], opts);
        current[event_handle_key] = null;
      }
      if (is_delegated) {
        delegated(event_name, element2, value);
        delegate([event_name]);
      } else if (value != null) {
        let handle = function(evt) {
          current[key3].call(this, evt);
        };
        current[event_handle_key] = create_event(event_name, element2, handle, opts);
      }
    } else if (key3 === "style") {
      set_attribute2(element2, key3, value);
    } else if (key3 === "autofocus") {
      autofocus(
        /** @type {HTMLElement} */
        element2,
        Boolean(value)
      );
    } else if (!is_custom_element && (key3 === "__value" || key3 === "value" && value != null)) {
      element2.value = element2.__value = value;
    } else if (key3 === "selected" && is_option_element) {
      set_selected(
        /** @type {HTMLOptionElement} */
        element2,
        value
      );
    } else {
      var name = key3;
      if (!preserve_attribute_case) {
        name = normalize_attribute(name);
      }
      var is_default = name === "defaultValue" || name === "defaultChecked";
      if (value == null && !is_custom_element && !is_default) {
        attributes[key3] = null;
        if (name === "value" || name === "checked") {
          let input2 = (
            /** @type {HTMLInputElement} */
            element2
          );
          const use_default = prev === void 0;
          if (name === "value") {
            let previous = input2.defaultValue;
            input2.removeAttribute(name);
            input2.defaultValue = previous;
            input2.value = input2.__value = use_default ? previous : null;
          } else {
            let previous = input2.defaultChecked;
            input2.removeAttribute(name);
            input2.defaultChecked = previous;
            input2.checked = use_default ? previous : false;
          }
        } else {
          element2.removeAttribute(key3);
        }
      } else if (is_default || setters.includes(name) && (is_custom_element || typeof value !== "string")) {
        element2[name] = value;
        if (name in attributes) attributes[name] = UNINITIALIZED;
      } else if (typeof value !== "function") {
        set_attribute2(element2, name, value, skip_warning);
      }
    }
  }
  if (is_hydrating_custom_element) {
    set_hydrating(true);
  }
  return current;
}
function attribute_effect(element2, fn, sync = [], async2 = [], blockers = [], css_hash, should_remove_defaults = false, skip_warning = false) {
  flatten(blockers, sync, async2, (values) => {
    var prev = void 0;
    var effects = {};
    var is_select = element2.nodeName === SELECT_TAG;
    var inited = false;
    managed(() => {
      var next2 = fn(...values.map(get));
      var current = set_attributes(
        element2,
        prev,
        next2,
        css_hash,
        should_remove_defaults,
        skip_warning
      );
      if (inited && is_select && "value" in next2) {
        select_option(
          /** @type {HTMLSelectElement} */
          element2,
          next2.value
        );
      }
      for (let symbol of Object.getOwnPropertySymbols(effects)) {
        if (!next2[symbol]) destroy_effect(effects[symbol]);
      }
      for (let symbol of Object.getOwnPropertySymbols(next2)) {
        var n = next2[symbol];
        if (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {
          if (effects[symbol]) destroy_effect(effects[symbol]);
          effects[symbol] = branch(() => attach(element2, () => n));
        }
        current[symbol] = n;
      }
      prev = current;
    });
    if (is_select) {
      var select = (
        /** @type {HTMLSelectElement} */
        element2
      );
      effect(() => {
        select_option(
          select,
          /** @type {Record<string | symbol, any>} */
          prev.value,
          true
        );
        init_select(select);
      });
    }
    inited = true;
  });
}
function get_attributes(element2) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    element2.__attributes ??= {
      [IS_CUSTOM_ELEMENT]: element2.nodeName.includes("-"),
      [IS_HTML]: element2.namespaceURI === NAMESPACE_HTML
    }
  );
}
var setters_cache = /* @__PURE__ */ new Map();
function get_setters(element2) {
  var cache_key = element2.getAttribute("is") || element2.nodeName;
  var setters = setters_cache.get(cache_key);
  if (setters) return setters;
  setters_cache.set(cache_key, setters = []);
  var descriptors;
  var proto = element2;
  var element_proto = Element.prototype;
  while (element_proto !== proto) {
    descriptors = get_descriptors(proto);
    for (var key2 in descriptors) {
      if (descriptors[key2].set) {
        setters.push(key2);
      }
    }
    proto = get_prototype_of(proto);
  }
  return setters;
}
function check_src_in_dev_hydration(element2, attribute, value) {
  if (!dev_fallback_default) return;
  if (attribute === "srcset" && srcset_url_equal(element2, value)) return;
  if (src_url_equal(element2.getAttribute(attribute) ?? "", value)) return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, element2.innerHTML && "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url) return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset);
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}

// node_modules/svelte/src/internal/client/dom/elements/customizable-select.js
var supported = null;
function is_supported() {
  if (supported === null) {
    var select = create_element("select");
    select.innerHTML = "<option><span>t</span></option>";
    supported = /** @type {Element} */
    select.firstChild?.firstChild?.nodeType === 1;
  }
  return supported;
}
function selectedcontent(element2, update_element) {
  if (!is_supported()) return;
  attach(element2, () => () => {
    const select = element2.closest("select");
    if (!select) return;
    const observer = new MutationObserver((entries) => {
      var selected = false;
      for (const entry of entries) {
        if (entry.target === element2) {
          return;
        }
        selected ||= !!entry.target.parentElement?.closest("option")?.selected;
      }
      if (selected) {
        element2.replaceWith(element2 = /** @type {HTMLElement} */
        element2.cloneNode(true));
        update_element(element2);
      }
    });
    observer.observe(select, {
      childList: true,
      characterData: true,
      subtree: true
    });
    return () => {
      observer.disconnect();
    };
  });
}
function customizable_select(element2, rich_fn) {
  var was_hydrating = hydrating;
  if (!is_supported()) {
    set_hydrating(false);
    element2.textContent = "";
    element2.append(create_comment(""));
  }
  try {
    rich_fn();
  } finally {
    if (was_hydrating) {
      if (hydrating) {
        reset(element2);
      } else {
        set_hydrating(true);
        set_hydrate_node(element2);
      }
    }
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/document.js
function bind_active_element(update2) {
  listen(document, ["focusin", "focusout"], (event2) => {
    if (event2 && event2.type === "focusout" && /** @type {FocusEvent} */
    event2.relatedTarget) {
      return;
    }
    update2(document.activeElement);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/input.js
function bind_value(input, get3, set3 = get3) {
  var batches2 = /* @__PURE__ */ new WeakSet();
  listen_to_event_and_reset_event(input, "input", async (is_reset) => {
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = is_reset ? input.defaultValue : input.value;
    value = is_numberlike_input(input) ? to_number(value) : value;
    set3(value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
    await tick();
    if (value !== (value = get3())) {
      var start = input.selectionStart;
      var end = input.selectionEnd;
      var length = input.value.length;
      input.value = value ?? "";
      if (end !== null) {
        var new_length = input.value.length;
        if (start === end && end === length && new_length > length) {
          input.selectionStart = new_length;
          input.selectionEnd = new_length;
        } else {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, new_length);
        }
      }
    }
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.defaultValue !== input.value || // If defaultValue is set, then value == defaultValue
    // TODO Svelte 6: remove input.value check and set to empty string?
    untrack(get3) == null && input.value
  ) {
    set3(is_numberlike_input(input) ? to_number(input.value) : input.value);
    if (current_batch !== null) {
      batches2.add(current_batch);
    }
  }
  render_effect(() => {
    if (dev_fallback_default && input.type === "checkbox") {
      bind_invalid_checkbox_value();
    }
    var value = get3();
    if (input === document.activeElement) {
      var batch = (
        /** @type {Batch} */
        previous_batch ?? current_batch
      );
      if (batches2.has(batch)) {
        return;
      }
    }
    if (is_numberlike_input(input) && value === to_number(input.value)) {
      return;
    }
    if (input.type === "date" && !value && !input.value) {
      return;
    }
    if (value !== input.value) {
      input.value = value ?? "";
    }
  });
}
var pending2 = /* @__PURE__ */ new Set();
function bind_group(inputs, group_index, input, get3, set3 = get3) {
  var is_checkbox = input.getAttribute("type") === "checkbox";
  var binding_group = inputs;
  let hydration_mismatch2 = false;
  if (group_index !== null) {
    for (var index2 of group_index) {
      binding_group = binding_group[index2] ??= [];
    }
  }
  binding_group.push(input);
  listen_to_event_and_reset_event(
    input,
    "change",
    () => {
      var value = input.__value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      }
      set3(value);
    },
    // TODO better default value handling
    () => set3(is_checkbox ? [] : null)
  );
  render_effect(() => {
    var value = get3();
    if (hydrating && input.defaultChecked !== input.checked) {
      hydration_mismatch2 = true;
      return;
    }
    if (is_checkbox) {
      value = value || [];
      input.checked = value.includes(input.__value);
    } else {
      input.checked = is(input.__value, value);
    }
  });
  teardown(() => {
    var index3 = binding_group.indexOf(input);
    if (index3 !== -1) {
      binding_group.splice(index3, 1);
    }
  });
  if (!pending2.has(binding_group)) {
    pending2.add(binding_group);
    queue_micro_task(() => {
      binding_group.sort((a, b) => a.compareDocumentPosition(b) === 4 ? -1 : 1);
      pending2.delete(binding_group);
    });
  }
  queue_micro_task(() => {
    if (hydration_mismatch2) {
      var value;
      if (is_checkbox) {
        value = get_binding_group_value(binding_group, value, input.checked);
      } else {
        var hydration_input = binding_group.find((input2) => input2.checked);
        value = hydration_input?.__value;
      }
      set3(value);
    }
  });
}
function bind_checked(input, get3, set3 = get3) {
  listen_to_event_and_reset_event(input, "change", (is_reset) => {
    var value = is_reset ? input.defaultChecked : input.checked;
    set3(value);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the update value from the input instead.
    hydrating && input.defaultChecked !== input.checked || // If defaultChecked is set, then checked == defaultChecked
    untrack(get3) == null
  ) {
    set3(input.checked);
  }
  render_effect(() => {
    var value = get3();
    input.checked = Boolean(value);
  });
}
function get_binding_group_value(group, __value, checked) {
  var value = /* @__PURE__ */ new Set();
  for (var i = 0; i < group.length; i += 1) {
    if (group[i].checked) {
      value.add(group[i].__value);
    }
  }
  if (!checked) {
    value.delete(__value);
  }
  return Array.from(value);
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function to_number(value) {
  return value === "" ? null : +value;
}
function bind_files(input, get3, set3 = get3) {
  listen_to_event_and_reset_event(input, "change", () => {
    set3(input.files);
  });
  if (
    // If we are hydrating and the value has since changed,
    // then use the updated value from the input instead.
    hydrating && input.files
  ) {
    set3(input.files);
  }
  render_effect(() => {
    input.files = get3();
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/media.js
function time_ranges_to_array(ranges) {
  var array = [];
  for (var i = 0; i < ranges.length; i += 1) {
    array.push({ start: ranges.start(i), end: ranges.end(i) });
  }
  return array;
}
function bind_current_time(media, get3, set3 = get3) {
  var raf_id;
  var value;
  var callback = () => {
    cancelAnimationFrame(raf_id);
    if (!media.paused) {
      raf_id = requestAnimationFrame(callback);
    }
    var next_value = media.currentTime;
    if (value !== next_value) {
      set3(value = next_value);
    }
  };
  raf_id = requestAnimationFrame(callback);
  media.addEventListener("timeupdate", callback);
  render_effect(() => {
    var next_value = Number(get3());
    if (value !== next_value && !isNaN(
      /** @type {any} */
      next_value
    )) {
      media.currentTime = value = next_value;
    }
  });
  teardown(() => {
    cancelAnimationFrame(raf_id);
    media.removeEventListener("timeupdate", callback);
  });
}
function bind_buffered(media, set3) {
  var current;
  listen(media, ["loadedmetadata", "progress", "timeupdate", "seeking"], () => {
    var ranges = media.buffered;
    if (!current || current.length !== ranges.length || current.some((range, i) => ranges.start(i) !== range.start || ranges.end(i) !== range.end)) {
      current = time_ranges_to_array(ranges);
      set3(current);
    }
  });
}
function bind_seekable(media, set3) {
  listen(media, ["loadedmetadata"], () => set3(time_ranges_to_array(media.seekable)));
}
function bind_played(media, set3) {
  listen(media, ["timeupdate"], () => set3(time_ranges_to_array(media.played)));
}
function bind_seeking(media, set3) {
  listen(media, ["seeking", "seeked"], () => set3(media.seeking));
}
function bind_ended(media, set3) {
  listen(media, ["timeupdate", "ended"], () => set3(media.ended));
}
function bind_ready_state(media, set3) {
  listen(
    media,
    ["loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "emptied"],
    () => set3(media.readyState)
  );
}
function bind_playback_rate(media, get3, set3 = get3) {
  effect(() => {
    var value = Number(get3());
    if (value !== media.playbackRate && !isNaN(value)) {
      media.playbackRate = value;
    }
  });
  effect(() => {
    listen(media, ["ratechange"], () => {
      set3(media.playbackRate);
    });
  });
}
function bind_paused(media, get3, set3 = get3) {
  var paused = get3();
  var update2 = () => {
    if (paused !== media.paused) {
      set3(paused = media.paused);
    }
  };
  listen(media, ["play", "pause", "canplay"], update2, paused == null);
  effect(() => {
    if ((paused = !!get3()) !== media.paused) {
      if (paused) {
        media.pause();
      } else {
        media.play().catch((error) => {
          set3(paused = true);
          throw error;
        });
      }
    }
  });
}
function bind_volume(media, get3, set3 = get3) {
  var callback = () => {
    set3(media.volume);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = Number(get3());
    if (value !== media.volume && !isNaN(value)) {
      media.volume = value;
    }
  });
}
function bind_muted(media, get3, set3 = get3) {
  var callback = () => {
    set3(media.muted);
  };
  if (get3() == null) {
    callback();
  }
  listen(media, ["volumechange"], callback, false);
  render_effect(() => {
    var value = !!get3();
    if (media.muted !== value) media.muted = value;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/navigator.js
function bind_online(update2) {
  listen(window, ["online", "offline"], () => {
    update2(navigator.onLine);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/props.js
function bind_prop(props, prop2, value) {
  var desc = get_descriptor(props, prop2);
  if (desc && desc.set) {
    props[prop2] = value;
    teardown(() => {
      props[prop2] = null;
    });
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** */
  #listeners = /* @__PURE__ */ new WeakMap();
  /** @type {ResizeObserver | undefined} */
  #observer;
  /** @type {ResizeObserverOptions} */
  #options;
  /** @static */
  static entries = /* @__PURE__ */ new WeakMap();
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    this.#options = options;
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    var listeners2 = this.#listeners.get(element2) || /* @__PURE__ */ new Set();
    listeners2.add(listener);
    this.#listeners.set(element2, listeners2);
    this.#getObserver().observe(element2, this.#options);
    return () => {
      var listeners3 = this.#listeners.get(element2);
      listeners3.delete(listener);
      if (listeners3.size === 0) {
        this.#listeners.delete(element2);
        this.#observer.unobserve(element2);
      }
    };
  }
  #getObserver() {
    return this.#observer ?? (this.#observer = new ResizeObserver(
      /** @param {any} entries */
      (entries) => {
        for (var entry of entries) {
          _ResizeObserverSingleton.entries.set(entry.target, entry);
          for (var listener of this.#listeners.get(entry.target) || []) {
            listener(entry);
          }
        }
      }
    ));
  }
};
var resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function bind_resize_observer(element2, type, set3) {
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  var unsub = observer.observe(
    element2,
    /** @param {any} entry */
    (entry) => set3(entry[type])
  );
  teardown(unsub);
}
function bind_element_size(element2, type, set3) {
  var unsub = resize_observer_border_box.observe(element2, () => set3(element2[type]));
  effect(() => {
    untrack(() => set3(element2[type]));
    return unsub;
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/this.js
function is_bound_this(bound_value, element_or_component) {
  return bound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component;
}
function bind_this(element_or_component = {}, update2, get_value, get_parts) {
  effect(() => {
    var old_parts;
    var parts;
    render_effect(() => {
      old_parts = parts;
      parts = get_parts?.() || [];
      untrack(() => {
        if (element_or_component !== get_value(...parts)) {
          update2(element_or_component, ...parts);
          if (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {
            update2(null, ...old_parts);
          }
        }
      });
    });
    return () => {
      queue_micro_task(() => {
        if (parts && is_bound_this(get_value(...parts), element_or_component)) {
          update2(null, ...parts);
        }
      });
    };
  });
  return element_or_component;
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/universal.js
function bind_content_editable(property, element2, get3, set3 = get3) {
  element2.addEventListener("input", () => {
    set3(element2[property]);
  });
  render_effect(() => {
    var value = get3();
    if (element2[property] !== value) {
      if (value == null) {
        var non_null_value = element2[property];
        set3(non_null_value);
      } else {
        element2[property] = value + "";
      }
    }
  });
}
function bind_property(property, event_name, element2, set3, get3) {
  var handler = () => {
    set3(element2[property]);
  };
  element2.addEventListener(event_name, handler);
  if (get3) {
    render_effect(() => {
      element2[property] = get3();
    });
  } else {
    handler();
  }
  if (element2 === document.body || element2 === window || element2 === document) {
    teardown(() => {
      element2.removeEventListener(event_name, handler);
    });
  }
}
function bind_focused(element2, set3) {
  listen(element2, ["focus", "blur"], () => {
    set3(element2 === document.activeElement);
  });
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/window.js
function bind_window_scroll(type, get3, set3 = get3) {
  var is_scrolling_x = type === "x";
  var target_handler = () => without_reactive_context(() => {
    scrolling = true;
    clearTimeout(timeout);
    timeout = setTimeout(clear2, 100);
    set3(window[is_scrolling_x ? "scrollX" : "scrollY"]);
  });
  addEventListener("scroll", target_handler, {
    passive: true
  });
  var scrolling = false;
  var timeout;
  var clear2 = () => {
    scrolling = false;
  };
  var first = true;
  render_effect(() => {
    var latest_value = get3();
    if (first) {
      first = false;
    } else if (!scrolling && latest_value != null) {
      scrolling = true;
      clearTimeout(timeout);
      if (is_scrolling_x) {
        scrollTo(latest_value, window.scrollY);
      } else {
        scrollTo(window.scrollX, latest_value);
      }
      timeout = setTimeout(clear2, 100);
    }
  });
  effect(target_handler);
  teardown(() => {
    removeEventListener("scroll", target_handler);
  });
}
function bind_window_size(type, set3) {
  listen(window, ["resize"], () => without_reactive_context(() => set3(window[type])));
}

// node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js
function trusted(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.isTrusted) {
      fn?.apply(this, args);
    }
  };
}
function self(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    if (event2.target === this) {
      fn?.apply(this, args);
    }
  };
}
function stopPropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopPropagation();
    return fn?.apply(this, args);
  };
}
function once(fn) {
  var ran = false;
  return function(...args) {
    if (ran) return;
    ran = true;
    return fn?.apply(this, args);
  };
}
function stopImmediatePropagation(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.stopImmediatePropagation();
    return fn?.apply(this, args);
  };
}
function preventDefault(fn) {
  return function(...args) {
    var event2 = (
      /** @type {Event} */
      args[0]
    );
    event2.preventDefault();
    return fn?.apply(this, args);
  };
}
function passive(node, [event2, handler]) {
  user_pre_effect(() => {
    return on(node, event2, handler() ?? noop, {
      passive: true
    });
  });
}
function nonpassive(node, [event2, handler]) {
  user_pre_effect(() => {
    return on(node, event2, handler() ?? noop, {
      passive: false
    });
  });
}

// node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js
function init(immutable = false) {
  const context = (
    /** @type {ComponentContextLegacy} */
    component_context
  );
  const callbacks = context.l.u;
  if (!callbacks) return;
  let props = () => deep_read_state(context.s);
  if (immutable) {
    let version = 0;
    let prev = (
      /** @type {Record<string, any>} */
      {}
    );
    const d = derived(() => {
      let changed = false;
      const props2 = context.s;
      for (const key2 in props2) {
        if (props2[key2] !== prev[key2]) {
          prev[key2] = props2[key2];
          changed = true;
        }
      }
      if (changed) version++;
      return version;
    });
    props = () => get(d);
  }
  if (callbacks.b.length) {
    user_pre_effect(() => {
      observe_all(context, props);
      run_all(callbacks.b);
    });
  }
  user_effect(() => {
    const fns = untrack(() => callbacks.m.map(run));
    return () => {
      for (const fn of fns) {
        if (typeof fn === "function") {
          fn();
        }
      }
    };
  });
  if (callbacks.a.length) {
    user_effect(() => {
      observe_all(context, props);
      run_all(callbacks.a);
    });
  }
}
function observe_all(context, props) {
  if (context.l.s) {
    for (const signal of context.l.s) get(signal);
  }
  props();
}

// node_modules/svelte/src/internal/client/dom/legacy/misc.js
function reactive_import(fn) {
  var s = source(0);
  return function() {
    if (arguments.length === 1) {
      set2(s, get(s) + 1);
      return arguments[0];
    } else {
      get(s);
      return fn();
    }
  };
}
function bubble_event($$props, event2) {
  var events = (
    /** @type {Record<string, Function[] | Function>} */
    $$props.$$events?.[event2.type]
  );
  var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];
  for (var fn of callbacks) {
    fn.call(this, event2);
  }
}
function add_legacy_event_listener($$props, event_name, event_callback) {
  $$props.$$events ||= {};
  $$props.$$events[event_name] ||= [];
  $$props.$$events[event_name].push(event_callback);
}
function update_legacy_props($$new_props) {
  for (var key2 in $$new_props) {
    if (key2 in this) {
      this[key2] = $$new_props[key2];
    }
  }
}

// node_modules/svelte/src/store/utils.js
function subscribe_to_store(store, run4, invalidate) {
  if (store == null) {
    run4(void 0);
    if (invalidate) invalidate(void 0);
    return noop;
  }
  const unsub = untrack(
    () => store.subscribe(
      run4,
      // @ts-expect-error
      invalidate
    )
  );
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}

// node_modules/svelte/src/store/shared/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set3(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set3(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run4, invalidate = noop) {
    const subscriber = [run4, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set3, update2) || noop;
    }
    run4(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set3, update: update2, subscribe };
}
function derived2(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set3, update2) => {
    let started = false;
    const values = [];
    let pending3 = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending3) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set3, update2);
      if (auto) {
        set3(result);
      } else {
        cleanup = typeof result === "function" ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe_to_store(
        store,
        (value) => {
          values[i] = value;
          pending3 &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending3 |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function readonly(store) {
  return {
    // @ts-expect-error TODO i suspect the bind is unnecessary
    subscribe: store.subscribe.bind(store)
  };
}
function get2(store) {
  let value;
  subscribe_to_store(store, (_) => value = _)();
  return value;
}

// node_modules/svelte/src/internal/client/reactivity/store.js
var is_store_binding = false;
var IS_UNMOUNTED = Symbol();
function store_get(store, store_name, stores) {
  const entry = stores[store_name] ??= {
    store: null,
    source: mutable_source(void 0),
    unsubscribe: noop
  };
  if (dev_fallback_default) {
    entry.source.label = store_name;
  }
  if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
    entry.unsubscribe();
    entry.store = store ?? null;
    if (store == null) {
      entry.source.v = void 0;
      entry.unsubscribe = noop;
    } else {
      var is_synchronous_callback = true;
      entry.unsubscribe = subscribe_to_store(store, (v) => {
        if (is_synchronous_callback) {
          entry.source.v = v;
        } else {
          set2(entry.source, v);
        }
      });
      is_synchronous_callback = false;
    }
  }
  if (store && IS_UNMOUNTED in stores) {
    return get2(store);
  }
  return get(entry.source);
}
function store_unsub(store, store_name, stores) {
  let entry = stores[store_name];
  if (entry && entry.store !== store) {
    entry.unsubscribe();
    entry.unsubscribe = noop;
  }
  return store;
}
function store_set(store, value) {
  store.set(value);
  return value;
}
function invalidate_store(stores, store_name) {
  var entry = stores[store_name];
  if (entry.store !== null) {
    store_set(entry.store, entry.source.v);
  }
}
function setup_stores() {
  const stores = {};
  function cleanup() {
    teardown(() => {
      for (var store_name in stores) {
        const ref = stores[store_name];
        ref.unsubscribe();
      }
      define_property(stores, IS_UNMOUNTED, {
        enumerable: false,
        value: true
      });
    });
  }
  return [stores, cleanup];
}
function store_mutate(store, expression, new_value) {
  store.set(new_value);
  return expression;
}
function update_store(store, store_value, d = 1) {
  store.set(store_value + d);
  return store_value;
}
function update_pre_store(store, store_value, d = 1) {
  const value = store_value + d;
  store.set(value);
  return value;
}
function mark_store_binding() {
  is_store_binding = true;
}
function capture_store_binding(fn) {
  var previous_is_store_binding = is_store_binding;
  try {
    is_store_binding = false;
    return [fn(), is_store_binding];
  } finally {
    is_store_binding = previous_is_store_binding;
  }
}

// node_modules/svelte/src/internal/client/reactivity/props.js
function update_prop(fn, d = 1) {
  const value = fn();
  fn(value + d);
  return value;
}
function update_pre_prop(fn, d = 1) {
  const value = fn() + d;
  fn(value);
  return value;
}
var rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    return target.props[key2];
  },
  set(target, key2) {
    if (dev_fallback_default) {
      props_rest_readonly(`${target.name}.${String(key2)}`);
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
// @__NO_SIDE_EFFECTS__
function rest_props(props, exclude, name) {
  return new Proxy(
    dev_fallback_default ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },
    rest_props_handler
  );
}
var legacy_rest_props_handler = {
  get(target, key2) {
    if (target.exclude.includes(key2)) return;
    get(target.version);
    return key2 in target.special ? target.special[key2]() : target.props[key2];
  },
  set(target, key2, value) {
    if (!(key2 in target.special)) {
      var previous_effect = active_effect;
      try {
        set_active_effect(target.parent_effect);
        target.special[key2] = prop(
          {
            get [key2]() {
              return target.props[key2];
            }
          },
          /** @type {string} */
          key2,
          PROPS_IS_UPDATED
        );
      } finally {
        set_active_effect(previous_effect);
      }
    }
    target.special[key2](value);
    update(target.version);
    return true;
  },
  getOwnPropertyDescriptor(target, key2) {
    if (target.exclude.includes(key2)) return;
    if (key2 in target.props) {
      return {
        enumerable: true,
        configurable: true,
        value: target.props[key2]
      };
    }
  },
  deleteProperty(target, key2) {
    if (target.exclude.includes(key2)) return true;
    target.exclude.push(key2);
    update(target.version);
    return true;
  },
  has(target, key2) {
    if (target.exclude.includes(key2)) return false;
    return key2 in target.props;
  },
  ownKeys(target) {
    return Reflect.ownKeys(target.props).filter((key2) => !target.exclude.includes(key2));
  }
};
function legacy_rest_props(props, exclude) {
  return new Proxy(
    {
      props,
      exclude,
      special: {},
      version: source(0),
      // TODO this is only necessary because we need to track component
      // destruction inside `prop`, because of `bind:this`, but it
      // seems likely that we can simplify `bind:this` instead
      parent_effect: (
        /** @type {Effect} */
        active_effect
      )
    },
    legacy_rest_props_handler
  );
}
var spread_props_handler = {
  get(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key2 in p) return p[key2];
    }
  },
  set(target, key2, value) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      const desc = get_descriptor(p, key2);
      if (desc && desc.set) {
        desc.set(value);
        return true;
      }
    }
    return false;
  },
  getOwnPropertyDescriptor(target, key2) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p)) p = p();
      if (typeof p === "object" && p !== null && key2 in p) {
        const descriptor = get_descriptor(p, key2);
        if (descriptor && !descriptor.configurable) {
          descriptor.configurable = true;
        }
        return descriptor;
      }
    }
  },
  has(target, key2) {
    if (key2 === STATE_SYMBOL || key2 === LEGACY_PROPS) return false;
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (p != null && key2 in p) return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p)) p = p();
      if (!p) continue;
      for (const key2 in p) {
        if (!keys.includes(key2)) keys.push(key2);
      }
      for (const key2 of Object.getOwnPropertySymbols(p)) {
        if (!keys.includes(key2)) keys.push(key2);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key2, flags2, fallback2) {
  var runes = !legacy_mode_flag || (flags2 & PROPS_IS_RUNES) !== 0;
  var bindable = (flags2 & PROPS_IS_BINDABLE) !== 0;
  var lazy = (flags2 & PROPS_IS_LAZY_INITIAL) !== 0;
  var fallback_value = (
    /** @type {V} */
    fallback2
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (fallback_dirty) {
      fallback_dirty = false;
      fallback_value = lazy ? untrack(
        /** @type {() => V} */
        fallback2
      ) : (
        /** @type {V} */
        fallback2
      );
    }
    return fallback_value;
  };
  var setter;
  if (bindable) {
    var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;
    setter = get_descriptor(props, key2)?.set ?? (is_entry_props && key2 in props ? (v) => props[key2] = v : void 0);
  }
  var initial_value;
  var is_store_sub = false;
  if (bindable) {
    [initial_value, is_store_sub] = capture_store_binding(() => (
      /** @type {V} */
      props[key2]
    ));
  } else {
    initial_value = /** @type {V} */
    props[key2];
  }
  if (initial_value === void 0 && fallback2 !== void 0) {
    initial_value = get_fallback();
    if (setter) {
      if (runes) props_invalid_value(key2);
      setter(initial_value);
    }
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value === void 0) return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key2]
      );
      if (value !== void 0) {
        fallback_value = /** @type {V} */
        void 0;
      }
      return value === void 0 ? fallback_value : value;
    };
  }
  if (runes && (flags2 & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return (
      /** @type {() => V} */
      (function(value, mutation) {
        if (arguments.length > 0) {
          if (!runes || !mutation || legacy_parent || is_store_sub) {
            setter(mutation ? getter() : value);
          }
          return value;
        }
        return getter();
      })
    );
  }
  var overridden = false;
  var d = ((flags2 & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
    overridden = false;
    return getter();
  });
  if (dev_fallback_default) {
    d.label = key2;
  }
  if (bindable) get(d);
  var parent_effect = (
    /** @type {Effect} */
    active_effect
  );
  return (
    /** @type {() => V} */
    (function(value, mutation) {
      if (arguments.length > 0) {
        const new_value = mutation ? get(d) : runes && bindable ? proxy(value) : value;
        set2(d, new_value);
        overridden = true;
        if (fallback_value !== void 0) {
          fallback_value = new_value;
        }
        return value;
      }
      if (is_destroying_effect && overridden || (parent_effect.f & DESTROYED) !== 0) {
        return d.v;
      }
      return get(d);
    })
  );
}

// node_modules/svelte/src/internal/client/validate.js
function validate_binding(binding, blockers, get_object, get_property, line, column) {
  run_after_blockers(blockers, () => {
    var warned = false;
    var filename = dev_current_component_function?.[FILENAME];
    render_effect(() => {
      if (warned) return;
      var [object, is_store_sub] = capture_store_binding(get_object);
      if (is_store_sub) return;
      var property = get_property();
      var ran = false;
      var effect2 = render_effect(() => {
        if (ran) return;
        object[property];
      });
      ran = true;
      if (effect2.deps === null) {
        var location = `${filename}:${line}:${column}`;
        binding_property_non_reactive(binding, location);
        warned = true;
      }
    });
  });
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
function asClassComponent(component2) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options) {
      super({
        component: component2,
        ...options
      });
    }
  };
}
var Svelte4Component = class {
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = (key2, value) => {
      var s = mutable_source(value, false, false);
      sources.set(key2, s);
      return s;
    };
    const props = new Proxy(
      { ...options.props || {}, $$events: {} },
      {
        get(target, prop2) {
          return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          if (prop2 === LEGACY_PROPS) return true;
          get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value) {
          set2(sources.get(prop2) ?? add_source(prop2, value), value);
          return Reflect.set(target, prop2, value);
        }
      }
    );
    this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: options.intro ?? false,
      recover: options.recover
    });
    if (!async_mode_flag && (!options?.props?.$$host || options.sync === false)) {
      flushSync();
    }
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    this.#events[event2] = this.#events[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    this.#events[event2].push(cb);
    return () => {
      this.#events[event2] = this.#events[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};
function run3(fn) {
  user_pre_effect(() => {
    fn();
    var effect2 = (
      /** @type {import('#client').Effect} */
      active_effect
    );
    if ((effect2.f & DIRTY) !== 0) {
      let filename = "a file (we can't know which one)";
      if (dev_fallback_default) {
        filename = dev_current_component_function?.[FILENAME] ?? filename;
      }
      legacy_recursive_reactive_block(filename);
      set_signal_status(effect2, MAYBE_DIRTY);
    }
  });
}
function handlers(...handlers2) {
  return function(event2) {
    const { stopImmediatePropagation: stopImmediatePropagation2 } = event2;
    let stopped = false;
    event2.stopImmediatePropagation = () => {
      stopped = true;
      stopImmediatePropagation2.call(event2);
    };
    const errors = [];
    for (const handler of handlers2) {
      try {
        handler?.call(this, event2);
      } catch (e) {
        errors.push(e);
      }
      if (stopped) {
        break;
      }
    }
    for (let error of errors) {
      queueMicrotask(() => {
        throw error;
      });
    }
  };
}
function createBubbler() {
  const active_component_context = component_context;
  if (active_component_context === null) {
    lifecycle_outside_component("createBubbler");
  }
  return (type) => (event2) => {
    const events = (
      /** @type {Record<string, Function | Function[]>} */
      active_component_context.s.$$events?.[
        /** @type {any} */
        type
      ]
    );
    if (events) {
      const callbacks = is_array(events) ? events.slice() : [events];
      for (const fn of callbacks) {
        fn.call(active_component_context.x, event2);
      }
      return !event2.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /** The Svelte component constructor */
    $$ctor;
    /** Slots */
    $$s;
    /** @type {any} The Svelte component instance */
    $$c;
    /** Whether or not the custom element is connected */
    $$cn = false;
    /** @type {Record<string, any>} Component props data */
    $$d = {};
    /** `true` if currently in the process of reflecting component props back to attributes */
    $$r = false;
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    $$p_d = {};
    /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
    $$l = {};
    /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
    $$l_u = /* @__PURE__ */ new Map();
    /** @type {any} The managed render effect for reflecting attributes */
    $$me;
    /** @type {ShadowRoot | null} The ShadowRoot of the custom element */
    $$shadowRoot = null;
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {ShadowRootInit | undefined} shadow_root_init
     */
    constructor($$componentCtor, $$slots, shadow_root_init) {
      super();
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (shadow_root_init) {
        this.$$shadowRoot = this.attachShadow(shadow_root_init);
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const slot2 = create_element("slot");
            if (name !== "default") slot2.name = name;
            append(anchor, slot2);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key2 in this.$$p_d) {
          if (!(key2 in this.$$d) && this[key2] !== void 0) {
            this.$$d[key2] = this[key2];
            delete this[key2];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.$$shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            this.$$r = true;
            for (const key2 of object_keys(this.$$c)) {
              if (!this.$$p_d[key2]?.reflect) continue;
              this.$$d[key2] = this.$$c[key2];
              const attribute_value = get_custom_element_value(
                key2,
                this.$$d[key2],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key2].attribute || key2);
              } else {
                this.setAttribute(this.$$p_d[key2].attribute || key2, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key2) => this.$$p_d[key2].attribute === attribute_name || !this.$$p_d[key2].attribute && key2.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type = props_definition[prop2]?.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}
function create_custom_element(Component, props_definition, slots, exports, shadow_root_init, extend) {
  let Class = class extends SvelteElement {
    constructor() {
      super(Component, slots, shadow_root_init);
      this.$$p_d = props_definition;
    }
    static get observedAttributes() {
      return object_keys(props_definition).map(
        (key2) => (props_definition[key2].attribute || key2).toLowerCase()
      );
    }
  };
  object_keys(props_definition).forEach((prop2) => {
    define_property(Class.prototype, prop2, {
      get() {
        return this.$$c && prop2 in this.$$c ? this.$$c[prop2] : this.$$d[prop2];
      },
      set(value) {
        value = get_custom_element_value(prop2, value, props_definition);
        this.$$d[prop2] = value;
        var component2 = this.$$c;
        if (component2) {
          var setter = get_descriptor(component2, prop2)?.get;
          if (setter) {
            component2[prop2] = value;
          } else {
            component2.$set({ [prop2]: value });
          }
        }
      }
    });
  });
  exports.forEach((property) => {
    define_property(Class.prototype, property, {
      get() {
        return this.$$c?.[property];
      }
    });
  });
  if (extend) {
    Class = extend(Class);
  }
  Component.element = /** @type {any} */
  Class;
  return Class;
}

// node_modules/svelte/src/internal/client/dev/console-log.js
function log_if_contains_state(method, ...objects) {
  untrack(() => {
    try {
      let has_state = false;
      const transformed = [];
      for (const obj of objects) {
        if (obj && typeof obj === "object" && STATE_SYMBOL in obj) {
          transformed.push(snapshot(obj, true));
          has_state = true;
        } else {
          transformed.push(obj);
        }
      }
      if (has_state) {
        console_log_state(method);
        console.log("%c[snapshot]", "color: grey", ...transformed);
      }
    } catch {
    }
  });
  return objects;
}

// src/ui/bridge/context.ts
var CONTEXT_KEY = Symbol("cr-context");
function setCRContext(ctx) {
  setContext(CONTEXT_KEY, ctx);
}
function getCRContext() {
  return getContext(CONTEXT_KEY);
}

// src/ui/bridge/reactive.svelte.ts
function createQueueStore(taskQueue) {
  let status = state(proxy(taskQueue.getStatus()));
  let tasks = state(proxy(taskQueue.getAllTasks()));
  const unsubscribe = taskQueue.subscribe(() => {
    set2(status, taskQueue.getStatus(), true);
    set2(tasks, taskQueue.getAllTasks(), true);
  });
  return {
    get status() {
      return get(status);
    },
    get tasks() {
      return get(tasks);
    },
    destroy: unsubscribe
  };
}
function createActiveFileStore(workspace) {
  let activeFile = state(proxy(workspace.getActiveFile()));
  const ref = workspace.on("active-leaf-change", () => {
    set2(activeFile, workspace.getActiveFile(), true);
  });
  return {
    get file() {
      return get(activeFile);
    },
    destroy: () => workspace.offref(ref)
  };
}
function createPipelineStore(orchestrators) {
  let activePipeline = state(null);
  const unsubCreate = orchestrators.create.subscribe((event2) => {
    if (event2.type === "pipeline_completed" || event2.type === "pipeline_failed") {
      if (get(activePipeline)?.pipelineId === event2.pipelineId) {
        set2(activePipeline, null);
      }
    } else {
      set2(activePipeline, event2.context, true);
    }
  });
  const unsubAmend = orchestrators.amend.subscribe((event2) => {
    if (event2.type === "pipeline_completed" || event2.type === "pipeline_failed") {
      if (get(activePipeline)?.pipelineId === event2.pipelineId) {
        set2(activePipeline, null);
      }
    } else {
      set2(activePipeline, event2.context, true);
    }
  });
  const unsubMerge = orchestrators.merge.subscribe((event2) => {
    if (event2.type === "pipeline_completed" || event2.type === "pipeline_failed") {
      if (get(activePipeline)?.pipelineId === event2.pipelineId) {
        set2(activePipeline, null);
      }
    } else {
      set2(activePipeline, event2.context, true);
    }
  });
  return {
    get pipeline() {
      return get(activePipeline);
    },
    destroy: () => {
      unsubCreate();
      unsubAmend();
      unsubMerge();
    }
  };
}
function createDuplicatesStore(duplicateManager) {
  let pairs2 = state(proxy(duplicateManager.getPendingPairs()));
  const unsubscribe = duplicateManager.subscribe((updatedPairs) => {
    set2(pairs2, updatedPairs.filter((p) => p.status === "pending"), true);
  });
  return {
    get pairs() {
      return get(pairs2);
    },
    destroy: unsubscribe
  };
}
function createSnapshotsStore(undoManager) {
  let snapshots = state(proxy([]));
  let loading = state(false);
  async function refresh() {
    set2(loading, true);
    const result = await undoManager.listSnapshots();
    if (result.ok) {
      set2(snapshots, result.value, true);
    }
    set2(loading, false);
  }
  void refresh();
  return {
    get snapshots() {
      return get(snapshots);
    },
    get loading() {
      return get(loading);
    },
    refresh,
    destroy: () => {
    }
  };
}

// src/ui/svelte/workbench/WorkbenchRoot.svelte
var root = from_html(`<div class="cr-workbench-root svelte-18mbrhr"><section class="cr-section svelte-18mbrhr" aria-label="\u521B\u5EFA"><!></section> <section class="cr-section svelte-18mbrhr" aria-label="\u961F\u5217"><!></section> <section class="cr-section svelte-18mbrhr" aria-label="\u91CD\u590D\u5BF9"><!></section> <section class="cr-section svelte-18mbrhr" aria-label="\u5386\u53F2"><!></section></div>`);
var $$css = {
  hash: "svelte-18mbrhr",
  code: ".cr-workbench-root.svelte-18mbrhr {max-width:900px;margin:0 auto;padding:var(--cr-space-4) var(--cr-space-3);display:flex;flex-direction:column;gap:var(--cr-space-4);}.cr-section.svelte-18mbrhr {width:100%;}"
};
function WorkbenchRoot($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css);
  const components = $$props.plugin.getComponents();
  setCRContext({
    container: components.container,
    i18n: components.i18n,
    app: $$props.plugin.app
  });
  const queueStore = createQueueStore(components.taskQueue);
  const activeFileStore = createActiveFileStore($$props.plugin.app.workspace);
  const duplicatesStore = createDuplicatesStore(components.duplicateManager);
  const snapshotsStore = createSnapshotsStore(components.undoManager);
  user_effect(() => {
    return () => {
      queueStore.destroy();
      activeFileStore.destroy();
      duplicatesStore.destroy();
      snapshotsStore.destroy();
    };
  });
  var div = root();
  var section = child(div);
  var node = child(section);
  CreateSection(node, {
    get activeFile() {
      return activeFileStore.file;
    }
  });
  reset(section);
  var section_1 = sibling(section, 2);
  var node_1 = child(section_1);
  QueueSection(node_1, {
    get status() {
      return queueStore.status;
    },
    get tasks() {
      return queueStore.tasks;
    }
  });
  reset(section_1);
  var section_2 = sibling(section_1, 2);
  var node_2 = child(section_2);
  DuplicatesSection(node_2, {
    get pairs() {
      return duplicatesStore.pairs;
    }
  });
  reset(section_2);
  var section_3 = sibling(section_2, 2);
  var node_3 = child(section_3);
  HistorySection(node_3, {
    get snapshots() {
      return snapshotsStore.snapshots;
    },
    get activeFile() {
      return activeFileStore.file;
    },
    get onRefresh() {
      return snapshotsStore.refresh;
    }
  });
  reset(section_3);
  reset(div);
  append($$anchor, div);
  pop();
}

// src/ui/bridge/mount.ts
function mountSvelteComponent(target, component2, props) {
  const instance = mount(component2, { target, props });
  return {
    destroy: () => unmount(instance)
  };
}

// src/ui/svelte/workbench-view.ts
var import_obsidian9 = require("obsidian");
var VIEW_TYPE_CR_WORKBENCH = "cr-workbench";
var WorkbenchView = class extends import_obsidian9.ItemView {
  cleanup = null;
  plugin;
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CR_WORKBENCH;
  }
  getDisplayText() {
    return "Cognitive Razor";
  }
  getIcon() {
    return "brain";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("cr-scope");
    const { destroy } = mountSvelteComponent(container, WorkbenchRoot, {
      plugin: this.plugin
    });
    this.cleanup = destroy;
  }
  async onClose() {
    this.cleanup?.();
    this.cleanup = null;
  }
};

// src/ui/svelte/diff/DiffRoot.svelte
var root2 = from_html(`<div class="cr-diff-tab svelte-18nrcsf" role="document"><div class="cr-diff-header svelte-18nrcsf"><span class="cr-diff-type-label svelte-18nrcsf"> </span> <span class="cr-diff-note-name svelte-18nrcsf"> </span></div> <div class="cr-diff-body svelte-18nrcsf"><!></div> <!></div>`);
var $$css2 = {
  hash: "svelte-18nrcsf",
  code: ".cr-diff-tab.svelte-18nrcsf {display:flex;flex-direction:column;height:100%;overflow:hidden;}.cr-diff-header.svelte-18nrcsf {display:flex;align-items:center;gap:var(--cr-space-2);padding:var(--cr-space-3) var(--cr-space-4);border-bottom:1px solid var(--cr-border);flex-shrink:0;}.cr-diff-type-label.svelte-18nrcsf {font-size:var(--cr-font-sm, 13px);color:var(--cr-text-muted);padding:2px 8px;border-radius:var(--cr-radius-sm, 4px);background:var(--cr-bg-secondary);}.cr-diff-note-name.svelte-18nrcsf {font-size:var(--cr-font-base, 14px);color:var(--cr-text-primary);font-weight:500;}.cr-diff-body.svelte-18nrcsf {flex:1;overflow-y:auto;min-height:0;}"
};
function DiffRoot($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css2);
  const $state = () => store_get($$props.state, "$state", $$stores);
  const [$$stores, $$cleanup] = setup_stores();
  const components = $$props.plugin.getComponents();
  setCRContext({
    container: components.container,
    i18n: components.i18n,
    app: $$props.plugin.app
  });
  const t = components.i18n.t();
  let selectedName = $state()("");
  const modeLabels = {
    amend: t.diff?.modeAmend ?? "\u4FEE\u8BA2",
    merge: t.diff?.modeMerge ?? "\u5408\u5E76",
    snapshot: t.diff?.modeSnapshot ?? "\u5FEB\u7167\u6062\u590D"
  };
  let modeLabel = user_derived(() => modeLabels[$$props.state.mode] ?? "Diff");
  function handleAccept() {
    if ($$props.state.mode === "merge") {
      $$props.state.onAccept({ selectedName });
    } else {
      $$props.state.onAccept();
    }
  }
  function handleReject() {
    $$props.state.onReject();
  }
  function handleKeydown(e) {
    if (e.key === "Enter" && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      handleAccept();
    }
    if (e.key === "Escape") {
      e.preventDefault();
      handleReject();
    }
  }
  var div = root2();
  event("keydown", $window, handleKeydown);
  var div_1 = child(div);
  var span = child(div_1);
  var text2 = child(span, true);
  reset(span);
  var span_1 = sibling(span, 2);
  var text_1 = child(span_1, true);
  reset(span_1);
  reset(div_1);
  var div_2 = sibling(div_1, 2);
  var node = child(div_2);
  DiffContent(node, {
    get oldContent() {
      return $$props.state.oldContent;
    },
    get newContent() {
      return $$props.state.newContent;
    }
  });
  reset(div_2);
  var node_1 = sibling(div_2, 2);
  DiffToolbar(node_1, {
    get mode() {
      return $$props.state.mode;
    },
    onaccept: handleAccept,
    onreject: handleReject,
    children: ($$anchor2, $$slotProps) => {
      var fragment = comment();
      var node_2 = first_child(fragment);
      {
        var consequent = ($$anchor3) => {
          MergeNameSelect($$anchor3, {
            get names() {
              return $$props.state.mergeNames;
            },
            get selected() {
              return selectedName;
            },
            set selected($$value) {
              selectedName = $$value;
            }
          });
        };
        if_block(node_2, ($$render) => {
          if ($$props.state.mode === "merge" && $$props.state.mergeNames) $$render(consequent);
        });
      }
      append($$anchor2, fragment);
    },
    $$slots: { default: true }
  });
  reset(div);
  template_effect(() => {
    set_text(text2, get(modeLabel));
    set_text(text_1, $$props.state.noteName);
  });
  append($$anchor, div);
  pop();
  $$cleanup();
}

// src/ui/svelte/diff-view.ts
var import_obsidian10 = require("obsidian");
var VIEW_TYPE_CR_DIFF = "cr-diff";
var DiffTabView = class extends import_obsidian10.ItemView {
  cleanup = null;
  plugin;
  viewState = null;
  /** 标记用户是否已做出决策（接受/拒绝） */
  decided = false;
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CR_DIFF;
  }
  getDisplayText() {
    if (this.viewState) {
      const modeLabels = {
        amend: "\u4FEE\u8BA2",
        merge: "\u5408\u5E76",
        snapshot: "\u5FEB\u7167\u6062\u590D"
      };
      const label2 = modeLabels[this.viewState.mode] ?? "Diff";
      return `${label2}: ${this.viewState.noteName}`;
    }
    return "Diff";
  }
  getIcon() {
    return "file-diff";
  }
  /** 设置 Diff 状态并挂载组件 */
  setDiffState(state2) {
    this.viewState = state2;
    this.decided = false;
    if (this.containerEl.children[1]) {
      this.mountComponent();
    }
  }
  /** 获取当前笔记名称（用于复用检测） */
  getNoteName() {
    return this.viewState?.noteName ?? null;
  }
  async onOpen() {
    if (this.viewState) {
      this.mountComponent();
    }
  }
  mountComponent() {
    this.cleanup?.();
    this.cleanup = null;
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("cr-scope");
    if (!this.viewState) return;
    const wrappedState = {
      ...this.viewState,
      onAccept: (data) => {
        this.decided = true;
        this.viewState?.onAccept(data);
      },
      onReject: () => {
        this.decided = true;
        this.viewState?.onReject();
      }
    };
    const { destroy } = mountSvelteComponent(container, DiffRoot, {
      state: wrappedState,
      plugin: this.plugin
    });
    this.cleanup = destroy;
  }
  async onClose() {
    if (!this.decided && this.viewState) {
      this.viewState.onReject();
    }
    this.cleanup?.();
    this.cleanup = null;
    this.viewState = null;
  }
};

// src/ui/svelte/settings/SettingsRoot.svelte
var root3 = from_html(`<div class="cr-settings-root svelte-13pj4e3"><!> <div class="cr-settings-content svelte-13pj4e3" role="tabpanel"><!></div></div>`);
var $$css3 = {
  hash: "svelte-13pj4e3",
  code: ".cr-settings-root.svelte-13pj4e3 {display:flex;flex-direction:column;min-height:0;}.cr-settings-content.svelte-13pj4e3 {padding:var(--cr-space-4) var(--cr-space-3);flex:1;}"
};
function SettingsRoot($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css3);
  const components = $$props.plugin.getComponents();
  const i18n = components.i18n;
  setCRContext({
    container: components.container,
    i18n: components.i18n,
    app: $$props.plugin.app
  });
  let activeTab = state("general");
  function handleTabChange(tab) {
    set2(activeTab, tab, true);
  }
  var div = root3();
  var node = child(div);
  SettingsNav(node, {
    get activeTab() {
      return get(activeTab);
    },
    onTabChange: handleTabChange,
    get i18n() {
      return i18n;
    }
  });
  var div_1 = sibling(node, 2);
  var node_1 = child(div_1);
  {
    var consequent = ($$anchor2) => {
      GeneralTab($$anchor2, {});
    };
    var consequent_1 = ($$anchor2) => {
      ProvidersTab($$anchor2, {});
    };
    var consequent_2 = ($$anchor2) => {
      AdvancedTab($$anchor2, {});
    };
    var consequent_3 = ($$anchor2) => {
      SystemTab($$anchor2, {});
    };
    if_block(node_1, ($$render) => {
      if (get(activeTab) === "general") $$render(consequent);
      else if (get(activeTab) === "providers") $$render(consequent_1, 1);
      else if (get(activeTab) === "advanced") $$render(consequent_2, 2);
      else if (get(activeTab) === "system") $$render(consequent_3, 3);
    });
  }
  reset(div_1);
  reset(div);
  template_effect(($0) => set_attribute2(div_1, "aria-label", $0), [() => i18n.t(`settings.tabs.${get(activeTab)}`)]);
  append($$anchor, div);
  pop();
}

// src/ui/svelte/settings-tab.ts
var import_obsidian11 = require("obsidian");
var CRSettingTab = class extends import_obsidian11.PluginSettingTab {
  cleanup = null;
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("cr-scope");
    const { destroy } = mountSvelteComponent(containerEl, SettingsRoot, {
      plugin: this.plugin
    });
    this.cleanup = destroy;
  }
  hide() {
    this.cleanup?.();
    this.cleanup = null;
  }
};

// src/ui/command-utils.ts
var COMMAND_PREFIX = "cognitive-razor";
var COMMAND_IDS = {
  // 核心命令（设计文档第 12 章）
  CREATE_CONCEPT: `${COMMAND_PREFIX}:create-concept`,
  OPEN_WORKBENCH: `${COMMAND_PREFIX}:open-workbench`,
  IMPROVE_NOTE: `${COMMAND_PREFIX}:improve-note`,
  MERGE_DUPLICATES: `${COMMAND_PREFIX}:merge-duplicates`,
  EXPAND_CURRENT_NOTE: `${COMMAND_PREFIX}:expand-current-note`,
  INSERT_IMAGE: `${COMMAND_PREFIX}:insert-image`,
  VERIFY_CURRENT_NOTE: `${COMMAND_PREFIX}:verify-current-note`,
  RETRY_FAILED: `${COMMAND_PREFIX}:retry-failed`,
  // 重要功能（阶段 2）
  VIEW_DUPLICATES: `${COMMAND_PREFIX}:view-duplicates`,
  RESUME_QUEUE: `${COMMAND_PREFIX}:resume-queue`,
  CLEAR_QUEUE: `${COMMAND_PREFIX}:clear-queue`,
  VIEW_OPERATION_HISTORY: `${COMMAND_PREFIX}:view-operation-history`,
  // 队列管理（已整合到工作台）
  PAUSE_QUEUE: `${COMMAND_PREFIX}:pause-queue`
};
function getCoreCommandIds() {
  return [
    COMMAND_IDS.OPEN_WORKBENCH,
    COMMAND_IDS.CREATE_CONCEPT,
    COMMAND_IDS.IMPROVE_NOTE,
    COMMAND_IDS.MERGE_DUPLICATES,
    COMMAND_IDS.EXPAND_CURRENT_NOTE
  ];
}
function isValidCommandId(commandId) {
  const pattern = /^cognitive-razor:[a-z]+(-[a-z]+)*$/;
  return pattern.test(commandId);
}

// src/ui/feedback.ts
var import_obsidian12 = require("obsidian");
var DURATION = {
  success: 3e3,
  warning: 5e3,
  error: 6e3,
  undoable: 8e3
};
var DEDUPE_WINDOW_MS = 2e3;
var lastNotice = null;
function shouldSuppress(level, message) {
  if (!lastNotice) return false;
  const now2 = Date.now();
  if (lastNotice.level === level && lastNotice.message === message && now2 - lastNotice.timestamp < DEDUPE_WINDOW_MS) {
    return true;
  }
  return false;
}
function recordNotice(level, message) {
  lastNotice = { level, message, timestamp: Date.now() };
}
function resetDedupeState() {
  lastNotice = null;
}
function showSuccess(message) {
  if (shouldSuppress("success", message)) return;
  recordNotice("success", message);
  new import_obsidian12.Notice(message, DURATION.success);
}
function showWarning(message) {
  if (shouldSuppress("warning", message)) return;
  recordNotice("warning", message);
  new import_obsidian12.Notice(message, DURATION.warning);
}
function showError(error, fallback2) {
  const message = typeof error === "string" ? error : safeErrorMessage(error, fallback2);
  if (shouldSuppress("error", message)) return;
  recordNotice("error", message);
  new import_obsidian12.Notice(message, DURATION.error);
}
function formatInfo(message) {
  return message;
}
function showUndoToast(message, options) {
  if (shouldSuppress("undoable", message)) return () => {
  };
  recordNotice("undoable", message);
  const notice = new import_obsidian12.Notice("", 0);
  const el = notice.noticeEl;
  el.empty();
  el.addClass("cr-undo-toast", "cr-scope");
  const container = el.createDiv({ cls: "cr-undo-toast-container" });
  const icon = container.createDiv({ cls: "cr-undo-toast-icon" });
  icon.setAttr("aria-hidden", "true");
  (0, import_obsidian12.setIcon)(icon, "rotate-ccw");
  const content = container.createDiv({ cls: "cr-undo-toast-content" });
  content.createDiv({ text: message, cls: "cr-undo-toast-message" });
  if (options.filePath) {
    const fileName = options.filePath.split("/").pop() || options.filePath;
    content.createDiv({ text: fileName, cls: "cr-undo-toast-file" });
  }
  let triggered = false;
  const undoBtn = container.createEl("button", {
    text: "\u64A4\u9500",
    cls: "cr-undo-toast-button",
    attr: { "aria-label": `\u64A4\u9500: ${message}` }
  });
  const dismiss = () => {
    clearTimeout(timer);
    notice.hide();
  };
  undoBtn.addEventListener("click", () => {
    if (triggered) return;
    triggered = true;
    options.onUndo();
    dismiss();
  });
  const bar = container.createDiv({ cls: "cr-undo-toast-progress" });
  const fill = bar.createDiv({ cls: "cr-undo-toast-progress-fill" });
  const duration = DURATION.undoable;
  fill.style.width = "100%";
  const prefersReduced = typeof window !== "undefined" && typeof window.matchMedia === "function" && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  if (!prefersReduced) {
    fill.style.transition = `width ${duration}ms linear`;
    setTimeout(() => {
      fill.style.width = "0%";
    }, 10);
  }
  const timer = setTimeout(dismiss, duration);
  return dismiss;
}

// src/ui/command-dispatcher.ts
var CommandDispatcher = class {
  plugin;
  commands = /* @__PURE__ */ new Map();
  taskQueue = null;
  constructor(plugin, taskQueue) {
    this.plugin = plugin;
    this.taskQueue = taskQueue || null;
  }
  /**
   * 获取 i18n 文本
   */
  t(path) {
    try {
      const keys = path.split(".");
      let current = this.plugin.getI18n().t();
      for (const key2 of keys) {
        if (current && typeof current === "object" && key2 in current) {
          current = current[key2];
        } else {
          return path;
        }
      }
      return typeof current === "string" ? current : path;
    } catch {
      return path;
    }
  }
  /**
   * 记录错误日志
   */
  logError(context, error, extra) {
    const logger = this.plugin.getComponents().logger;
    if (logger) {
      logger.error("CommandDispatcher", context, error instanceof Error ? error : new Error(String(error)), extra);
    }
  }
  /**
   * 设置 TaskQueue（用于延迟初始化）
   */
  setTaskQueue(taskQueue) {
    this.taskQueue = taskQueue;
  }
  /**
   * 注册所有命令
   */
  registerAllCommands() {
    this.registerWorkbenchCommands();
    this.registerConceptCommands();
    this.registerImproveCommands();
    this.registerExpandCommands();
    this.registerMergeCommands();
    this.registerUtilityCommands();
    this.registerFileMenu();
  }
  /**
   * 注册工具类命令
   */
  registerUtilityCommands() {
    const t = this.plugin.getI18n().t();
    this.registerCommand({
      id: COMMAND_IDS.INSERT_IMAGE,
      name: this.t("workbench.buttons.insertImage"),
      icon: "image",
      editorRequired: true,
      handler: async () => {
        await this.openWorkbench();
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.VERIFY_CURRENT_NOTE,
      name: this.t("workbench.buttons.verify"),
      icon: "check",
      editorRequired: true,
      handler: async () => {
        const verifyOrchestrator = this.plugin.getComponents().verifyOrchestrator;
        if (!verifyOrchestrator) {
          showWarning(this.t("workbench.notifications.orchestratorNotInitialized"));
          return;
        }
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          showWarning(this.t("workbench.notifications.openMarkdownFirst"));
          return;
        }
        const result = verifyOrchestrator.startVerifyPipeline(activeFile.path);
        if (!result.ok) {
          showError(formatMessage(t.workbench.notifications.startFailed, { message: result.error.message }));
          return;
        }
        showSuccess(this.t("workbench.notifications.verifyStarted"));
        await this.openWorkbench();
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.VIEW_DUPLICATES,
      name: t.workbench.duplicates.title,
      icon: "copy",
      handler: async () => {
        await this.openWorkbench();
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.PAUSE_QUEUE,
      name: t.workbench.queueStatus.pauseQueue,
      icon: "pause",
      handler: async () => {
        const taskQueue = this.taskQueue ?? this.plugin.getComponents().taskQueue;
        if (!taskQueue) {
          showWarning(t.workbench.notifications.systemNotInitialized);
          return;
        }
        await taskQueue.pause();
        showSuccess(t.workbench.notifications.queuePaused);
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.RESUME_QUEUE,
      name: t.workbench.queueStatus.resumeQueue,
      icon: "play",
      handler: async () => {
        const taskQueue = this.taskQueue ?? this.plugin.getComponents().taskQueue;
        if (!taskQueue) {
          showWarning(t.workbench.notifications.systemNotInitialized);
          return;
        }
        await taskQueue.resume();
        showSuccess(t.workbench.queueStatus.queueResumed);
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.RETRY_FAILED,
      name: t.workbench.queueStatus.retryFailed,
      icon: "refresh-cw",
      handler: async () => {
        const taskQueue = this.taskQueue ?? this.plugin.getComponents().taskQueue;
        if (!taskQueue) {
          showWarning(t.workbench.notifications.systemNotInitialized);
          return;
        }
        const result = await taskQueue.retryFailed();
        if (!result.ok) {
          showError(`${t.common.error}: ${result.error.message}`);
          return;
        }
        showSuccess(`${t.workbench.notifications.retryComplete}: ${result.value}`);
        await this.openWorkbench();
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.CLEAR_QUEUE,
      name: t.workbench.queueStatus.clearPending || "\u6E05\u7A7A\u961F\u5217",
      icon: "trash",
      handler: async () => {
        const taskQueue = this.taskQueue ?? this.plugin.getComponents().taskQueue;
        if (!taskQueue) {
          showWarning(t.workbench.notifications.systemNotInitialized);
          return;
        }
        const tasks = taskQueue.getAllTasks();
        const cancellable = tasks.filter((t2) => t2.state === "Pending");
        let cancelled = 0;
        for (const task of cancellable) {
          try {
            taskQueue.cancel(task.id);
            cancelled++;
          } catch (error) {
            this.logError("\u53D6\u6D88\u4EFB\u52A1\u5931\u8D25", error, { taskId: task.id });
          }
        }
        showSuccess(`${t.workbench.notifications.clearComplete}: ${cancelled}`);
      }
    });
    this.registerCommand({
      id: COMMAND_IDS.VIEW_OPERATION_HISTORY,
      name: t.workbench.recentOps.title,
      icon: "history",
      handler: async () => {
        await this.openWorkbench();
      }
    });
  }
  /**
   * 注册文件菜单（右键菜单）
   */
  registerFileMenu() {
    const t = this.plugin.getI18n().t();
    const workspace = this.plugin.app.workspace;
    this.plugin.registerEvent(
      workspace.on("file-menu", (menu, file) => {
        if (file.extension !== "md") return;
        menu.addItem((item) => {
          item.setTitle(t.commands.improveNote).setIcon("sparkles").onClick(async () => {
            await this.improveNote(file.path);
          });
        });
      })
    );
  }
  /**
   * 注册修订命令
   * Amend 命令直接调用 AmendOrchestrator，工作台内联面板由用户在工作台中操作
   */
  registerImproveCommands() {
    this.registerCommand({
      id: COMMAND_IDS.IMPROVE_NOTE,
      name: this.t("commands.improveNote"),
      icon: "sparkles",
      handler: async () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          await this.improveNote(activeFile.path);
        }
      },
      checkCallback: (checking) => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          return false;
        }
        if (!checking) {
          void this.improveNote(activeFile.path);
        }
        return true;
      }
    });
  }
  /**
   * 注册拓展命令
   * 打开工作台，拓展由内联面板处理
   */
  registerExpandCommands() {
    this.registerCommand({
      id: COMMAND_IDS.EXPAND_CURRENT_NOTE,
      name: this.t("commands.expandNote"),
      icon: "git-branch",
      handler: async () => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          await this.openWorkbench();
        }
      },
      checkCallback: (checking) => {
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (!activeFile || activeFile.extension !== "md") {
          return false;
        }
        if (!checking) {
          void this.openWorkbench();
        }
        return true;
      }
    });
  }
  /**
   * 注册合并重复对命令
   * 打开工作台，提示用户在重复对区选择操作
   */
  registerMergeCommands() {
    this.registerCommand({
      id: COMMAND_IDS.MERGE_DUPLICATES,
      name: this.t("commands.mergeDuplicates"),
      icon: "git-merge",
      handler: async () => {
        await this.openMergeFromWorkbench();
      }
    });
  }
  /**
   * 从工作台打开合并流程
   */
  async openMergeFromWorkbench() {
    await this.openWorkbench();
    const components = this.plugin.getComponents();
    const duplicateManager = components.duplicateManager;
    const pendingPairs = duplicateManager.getPendingPairs();
    if (pendingPairs.length === 0) {
      showWarning(this.t("workbench.notifications.noPendingDuplicates"));
      return;
    }
    showSuccess(formatMessage(
      this.t("workbench.notifications.pendingDuplicatesHint"),
      { count: pendingPairs.length }
    ));
  }
  /**
   * 注册工作台相关命令
   */
  registerWorkbenchCommands() {
    this.registerCommand({
      id: COMMAND_IDS.OPEN_WORKBENCH,
      name: this.t("commands.openWorkbench"),
      icon: "brain",
      handler: async () => {
        await this.openWorkbench();
      }
    });
  }
  /**
   * 注册概念创建命令
   * 打开工作台，聚焦 CreateSection 搜索框
   */
  registerConceptCommands() {
    this.registerCommand({
      id: COMMAND_IDS.CREATE_CONCEPT,
      name: this.t("commands.createConcept"),
      icon: "plus",
      handler: async () => {
        await this.openWorkbench();
      }
    });
  }
  /**
   * 注册单个命令
   */
  registerCommand(def) {
    this.commands.set(def.id, def);
    if (def.editorRequired) {
      this.plugin.addCommand({
        id: def.id,
        name: def.name,
        icon: def.icon,
        editorCallback: async () => {
          try {
            await def.handler();
          } catch (error) {
            this.logError(`\u547D\u4EE4\u6267\u884C\u5931\u8D25: ${def.id}`, error, { commandId: def.id });
            showError(error, this.t("workbench.notifications.commandFailed"));
          }
        },
        hotkeys: def.hotkeys
      });
    } else if (def.checkCallback) {
      this.plugin.addCommand({
        id: def.id,
        name: def.name,
        icon: def.icon,
        checkCallback: (checking) => {
          try {
            return def.checkCallback(checking);
          } catch (error) {
            this.logError(`\u547D\u4EE4\u68C0\u67E5\u5931\u8D25: ${def.id}`, error, { commandId: def.id });
            return false;
          }
        },
        hotkeys: def.hotkeys
      });
    } else {
      this.plugin.addCommand({
        id: def.id,
        name: def.name,
        icon: def.icon,
        callback: async () => {
          try {
            await def.handler();
          } catch (error) {
            this.logError(`\u547D\u4EE4\u6267\u884C\u5931\u8D25: ${def.id}`, error, { commandId: def.id });
            showError(error, this.t("workbench.notifications.commandFailed"));
          }
        },
        hotkeys: def.hotkeys
      });
    }
  }
  /**
   * 执行命令
   */
  async executeCommand(commandId) {
    const def = this.commands.get(commandId);
    if (!def) {
      const error = new Error(`\u672A\u627E\u5230\u547D\u4EE4: ${commandId}`);
      this.logError("\u6267\u884C\u547D\u4EE4\u5931\u8D25\uFF1A\u547D\u4EE4\u4E0D\u5B58\u5728", error, { commandId });
      throw error;
    }
    await def.handler();
  }
  /**
   * 获取所有命令
   */
  getAllCommands() {
    return Array.from(this.commands.values());
  }
  /**
   * 获取命令定义
   */
  getCommand(commandId) {
    return this.commands.get(commandId);
  }
  /**
   * 检查命令是否已注册
   */
  hasCommand(commandId) {
    return this.commands.has(commandId);
  }
  /**
   * 获取核心命令 ID 列表
   */
  static getCoreCommandIds() {
    return getCoreCommandIds();
  }
  /**
   * 验证命令 ID 格式
   */
  static isValidCommandId(commandId) {
    return isValidCommandId(commandId);
  }
  // ========================================================================
  // 命令实现
  // ========================================================================
  /**
   * 打开工作台（Svelte WorkbenchView）
   * 如果已打开则聚焦，否则在右侧边栏创建
   */
  async openWorkbench() {
    const { workspace } = this.plugin.app;
    const existing = workspace.getLeavesOfType(VIEW_TYPE_CR_WORKBENCH);
    if (existing.length > 0) {
      workspace.revealLeaf(existing[0]);
      return;
    }
    const leaf = workspace.getRightLeaf(false);
    if (leaf) {
      await leaf.setViewState({
        type: VIEW_TYPE_CR_WORKBENCH,
        active: true
      });
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * 修订笔记
   * 打开工作台，用户通过工作台内联面板输入修订指令
   */
  async improveNote(filePath) {
    try {
      const activeFile = this.plugin.app.workspace.getActiveFile();
      if (!activeFile || activeFile.path !== filePath) {
        showWarning(this.t("workbench.notifications.openMarkdownFirst"));
        return;
      }
      await this.openWorkbench();
    } catch (error) {
      this.logError("\u4FEE\u8BA2\u64CD\u4F5C\u5931\u8D25", error);
      showError(error, this.t("workbench.notifications.startFailed"));
    }
  }
};

// src/ui/svelte/wizard/WizardRoot.svelte
var root_4 = from_html(`<div></div>`);
var root_1 = from_html(`<div><span class="cr-wizard-progress__dot svelte-1y318w3"><!></span> <span class="cr-wizard-progress__label svelte-1y318w3"> </span></div> <!>`, 1);
var root4 = from_html(`<div class="cr-wizard svelte-1y318w3"><div class="cr-wizard-progress svelte-1y318w3" role="navigation" aria-label="Wizard steps"></div> <div class="cr-wizard-content svelte-1y318w3"><!></div></div>`);
var $$css4 = {
  hash: "svelte-1y318w3",
  code: ".cr-wizard.svelte-1y318w3 {display:flex;flex-direction:column;gap:var(--cr-space-6, 24px);padding:var(--cr-space-4, 16px) 0;}\r\n\r\n    /* \u8FDB\u5EA6\u6307\u793A\u5668 */.cr-wizard-progress.svelte-1y318w3 {display:flex;align-items:center;justify-content:center;gap:0;padding:0 var(--cr-space-4, 16px);}.cr-wizard-progress__step.svelte-1y318w3 {display:flex;flex-direction:column;align-items:center;gap:var(--cr-space-1, 4px);flex-shrink:0;}.cr-wizard-progress__dot.svelte-1y318w3 {width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:600;border:2px solid var(--cr-border);color:var(--cr-text-muted);background:var(--cr-bg-base);transition:all 0.2s ease;}.cr-wizard-progress__step.is-active.svelte-1y318w3 .cr-wizard-progress__dot:where(.svelte-1y318w3) {border-color:var(--cr-interactive-accent);color:var(--cr-interactive-accent);background:var(--cr-bg-accent-muted, rgba(var(--cr-accent-rgb, 99, 102, 241), 0.1));}.cr-wizard-progress__step.is-done.svelte-1y318w3 .cr-wizard-progress__dot:where(.svelte-1y318w3) {border-color:var(--cr-interactive-accent);background:var(--cr-interactive-accent);color:white;}.cr-wizard-progress__label.svelte-1y318w3 {font-size:11px;color:var(--cr-text-faint);white-space:nowrap;}.cr-wizard-progress__step.is-active.svelte-1y318w3 .cr-wizard-progress__label:where(.svelte-1y318w3) {color:var(--cr-text-normal);font-weight:500;}.cr-wizard-progress__line.svelte-1y318w3 {flex:1;height:2px;background:var(--cr-border);margin:0 var(--cr-space-2, 8px);margin-bottom:20px;min-width:24px;transition:background 0.2s ease;}.cr-wizard-progress__line.is-done.svelte-1y318w3 {background:var(--cr-interactive-accent);}\r\n\r\n    /* \u6B65\u9AA4\u5185\u5BB9\u533A */.cr-wizard-content.svelte-1y318w3 {padding:0 var(--cr-space-2, 8px);}"
};
function WizardRoot($$anchor, $$props) {
  push($$props, true);
  append_styles($$anchor, $$css4);
  const components = $$props.plugin.getComponents();
  setCRContext({
    container: components.container,
    i18n: components.i18n,
    app: $$props.plugin.app
  });
  const ctx = getCRContext();
  const i18n = ctx.i18n;
  const STEPS = ["welcome", "provider", "directory", "complete"];
  let currentStep = state("welcome");
  let currentIndex = user_derived(() => STEPS.indexOf(get(currentStep)));
  let stepLabels = user_derived(() => [
    i18n.t("setupWizard.steps.welcome"),
    i18n.t("setupWizard.steps.provider"),
    i18n.t("setupWizard.steps.directory"),
    i18n.t("setupWizard.steps.complete")
  ]);
  function goNext() {
    const idx = STEPS.indexOf(get(currentStep));
    if (idx < STEPS.length - 1) {
      set2(currentStep, STEPS[idx + 1], true);
    }
  }
  function goBack() {
    const idx = STEPS.indexOf(get(currentStep));
    if (idx > 0) {
      set2(currentStep, STEPS[idx - 1], true);
    }
  }
  function handleComplete() {
    $$props.oncomplete();
  }
  var div = root4();
  var div_1 = child(div);
  each(div_1, 22, () => STEPS, (step) => step, ($$anchor2, step, i) => {
    var fragment = root_1();
    var div_2 = first_child(fragment);
    let classes;
    var span = child(div_2);
    var node = child(span);
    {
      var consequent = ($$anchor3) => {
        var text2 = text("\u2713");
        append($$anchor3, text2);
      };
      var alternate = ($$anchor3) => {
        var text_1 = text();
        template_effect(() => set_text(text_1, get(i) + 1));
        append($$anchor3, text_1);
      };
      if_block(node, ($$render) => {
        if (get(i) < get(currentIndex)) $$render(consequent);
        else $$render(alternate, false);
      });
    }
    reset(span);
    var span_1 = sibling(span, 2);
    var text_2 = child(span_1, true);
    reset(span_1);
    reset(div_2);
    var node_1 = sibling(div_2, 2);
    {
      var consequent_1 = ($$anchor3) => {
        var div_3 = root_4();
        let classes_1;
        template_effect(() => classes_1 = set_class(div_3, 1, "cr-wizard-progress__line svelte-1y318w3", null, classes_1, { "is-done": get(i) < get(currentIndex) }));
        append($$anchor3, div_3);
      };
      if_block(node_1, ($$render) => {
        if (get(i) < STEPS.length - 1) $$render(consequent_1);
      });
    }
    template_effect(() => {
      classes = set_class(div_2, 1, "cr-wizard-progress__step svelte-1y318w3", null, classes, {
        "is-active": get(i) === get(currentIndex),
        "is-done": get(i) < get(currentIndex)
      });
      set_attribute2(div_2, "aria-current", get(i) === get(currentIndex) ? "step" : void 0);
      set_text(text_2, get(stepLabels)[get(i)]);
    });
    append($$anchor2, fragment);
  });
  reset(div_1);
  var div_4 = sibling(div_1, 2);
  var node_2 = child(div_4);
  {
    var consequent_2 = ($$anchor2) => {
      WelcomeStep($$anchor2, { onnext: goNext });
    };
    var consequent_3 = ($$anchor2) => {
      ProviderStep($$anchor2, { onnext: goNext, onback: goBack });
    };
    var consequent_4 = ($$anchor2) => {
      DirectoryStep($$anchor2, { onnext: goNext, onback: goBack });
    };
    var consequent_5 = ($$anchor2) => {
      CompleteStep($$anchor2, { oncomplete: handleComplete });
    };
    if_block(node_2, ($$render) => {
      if (get(currentStep) === "welcome") $$render(consequent_2);
      else if (get(currentStep) === "provider") $$render(consequent_3, 1);
      else if (get(currentStep) === "directory") $$render(consequent_4, 2);
      else if (get(currentStep) === "complete") $$render(consequent_5, 3);
    });
  }
  reset(div_4);
  reset(div);
  append($$anchor, div);
  pop();
}

// src/ui/svelte/setup-wizard.ts
var import_obsidian14 = require("obsidian");
var SetupWizard = class extends import_obsidian14.Modal {
  plugin;
  cleanup = null;
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("cr-scope");
    modalEl.setAttr("role", "dialog");
    modalEl.setAttr("aria-modal", "true");
    const { destroy } = mountSvelteComponent(contentEl, WizardRoot, {
      plugin: this.plugin,
      oncomplete: () => this.close()
    });
    this.cleanup = destroy;
  }
  onClose() {
    this.cleanup?.();
    this.cleanup = null;
  }
};

// src/ui/modal-manager.ts
var MODULE = "ModalManager";
var ModalManager = class {
  /** 按类型追踪当前打开的 Modal（同类型最多一个） */
  activeModals = /* @__PURE__ */ new Map();
  logger;
  constructor(deps) {
    this.logger = deps.logger;
  }
  /**
   * 显示 Svelte Modal
   *
   * 通用方法：将 Svelte 组件挂载到 document.body 的临时容器中。
   * 若同类型 Modal 已打开，返回 false 并阻止重复打开。
   *
   * @param type Modal 类型标识
   * @param component Svelte 组件
   * @param props 组件 props
   * @returns 是否成功打开
   */
  show(type, component2, props) {
    if (this.activeModals.has(type)) {
      this.logger.debug(MODULE, `\u540C\u7C7B\u578B Modal \u5DF2\u6253\u5F00\uFF0C\u963B\u6B62\u91CD\u590D\u6253\u5F00`, { type });
      return false;
    }
    const container = document.createElement("div");
    container.classList.add("cr-modal-container", `cr-modal-container--${type}`);
    document.body.appendChild(container);
    const { destroy } = mountSvelteComponent(container, component2, props);
    this.activeModals.set(type, { type, container, destroy });
    this.logger.debug(MODULE, `Modal \u5DF2\u6253\u5F00`, { type });
    return true;
  }
  /**
   * 关闭指定类型的 Modal
   */
  close(type) {
    const active = this.activeModals.get(type);
    if (!active) return;
    active.destroy();
    active.container.remove();
    this.activeModals.delete(type);
    this.logger.debug(MODULE, `Modal \u5DF2\u5173\u95ED`, { type });
  }
  /**
   * 检查某类型 Modal 是否已打开
   */
  isOpen(type) {
    return this.activeModals.has(type);
  }
  /**
   * 关闭所有 Modal（Plugin 卸载时调用）
   */
  closeAll() {
    const types = [...this.activeModals.keys()];
    for (const type of types) {
      this.close(type);
    }
    if (types.length > 0) {
      this.logger.debug(MODULE, `\u6240\u6709 Modal \u5DF2\u5173\u95ED`, { count: types.length });
    }
  }
  /**
   * 释放资源
   */
  dispose() {
    this.closeAll();
  }
};

// main.ts
var import_obsidian15 = require("obsidian");
var SERVICE_TOKENS = {
  // Data 层
  fileStorage: Symbol("FileStorage"),
  logger: Symbol("Logger"),
  settingsStore: Symbol("SettingsStore"),
  validator: Symbol("Validator"),
  // Core 层
  i18n: Symbol("I18n"),
  cruidCache: Symbol("CruidCache"),
  vectorIndex: Symbol("VectorIndex"),
  lockManager: Symbol("LockManager"),
  undoManager: Symbol("UndoManager"),
  providerManager: Symbol("ProviderManager"),
  promptManager: Symbol("PromptManager"),
  duplicateManager: Symbol("DuplicateManager"),
  taskRunner: Symbol("TaskRunner"),
  taskQueue: Symbol("TaskQueue"),
  pipelineStateStore: Symbol("PipelineStateStore"),
  createOrchestrator: Symbol("CreateOrchestrator"),
  amendOrchestrator: Symbol("AmendOrchestrator"),
  mergeOrchestrator: Symbol("MergeOrchestrator"),
  verifyOrchestrator: Symbol("VerifyOrchestrator"),
  expandOrchestrator: Symbol("ExpandOrchestrator"),
  imageInsertOrchestrator: Symbol("ImageInsertOrchestrator"),
  // UI 层
  modalManager: Symbol("ModalManager"),
  commandDispatcher: Symbol("CommandDispatcher")
};
var CognitiveRazorPlugin = class extends import_obsidian15.Plugin {
  /** 服务容器 */
  container;
  // 设置（保留公开属性，供 SettingsTab 等 UI 组件访问）
  settings;
  settingsStore;
  // 事件取消订阅列表
  unsubscribers = [];
  // 网络离线状态
  isOffline = false;
  /** 插件加载 — 仅负责组装、启动和错误边界 */
  async onload() {
    try {
      this.container = new ServiceContainer();
      await this.initializeDataLayerOnly();
      this.app.workspace.onLayoutReady(() => {
        void this.initializeAfterLayout();
      });
    } catch (error) {
      this.showSafeMode(error);
    }
  }
  /**
   * 外部设置变更回调 (Obsidian 1.5.7+)
   * 当 data.json 被外部修改时触发（如 Obsidian Sync）
   */
  async onExternalSettingsChange() {
    const logger = this.tryResolve(SERVICE_TOKENS.logger);
    logger?.info("CognitiveRazorPlugin", "\u68C0\u6D4B\u5230\u5916\u90E8\u8BBE\u7F6E\u53D8\u66F4\uFF0C\u91CD\u65B0\u52A0\u8F7D\u8BBE\u7F6E");
    try {
      const loadResult = await this.settingsStore.loadSettings();
      if (loadResult.ok) {
        this.settings = this.settingsStore.getSettings();
        logger?.debug("CognitiveRazorPlugin", "\u5916\u90E8\u8BBE\u7F6E\u53D8\u66F4\u5DF2\u52A0\u8F7D");
      }
    } catch (error) {
      logger?.error("CognitiveRazorPlugin", "\u91CD\u65B0\u52A0\u8F7D\u8BBE\u7F6E\u5931\u8D25", error);
    }
  }
  /**
   * 插件卸载 — 委托 ServiceContainer 逆序释放资源
   */
  async onunload() {
    const logger = this.tryResolve(SERVICE_TOKENS.logger);
    logger?.info("CognitiveRazorPlugin", "\u5F00\u59CB\u5378\u8F7D\u63D2\u4EF6");
    try {
      const taskQueue = this.tryResolve(SERVICE_TOKENS.taskQueue);
      if (taskQueue) {
        await taskQueue.pause();
        taskQueue.stop();
        await taskQueue.dispose();
        logger?.debug("CognitiveRazorPlugin", "\u4EFB\u52A1\u961F\u5217\u5DF2\u6682\u505C\u5E76\u505C\u6B62\u8C03\u5EA6\u5668");
      }
      this.tryResolve(SERVICE_TOKENS.createOrchestrator)?.dispose();
      this.tryResolve(SERVICE_TOKENS.amendOrchestrator)?.dispose();
      this.tryResolve(SERVICE_TOKENS.mergeOrchestrator)?.dispose();
      this.tryResolve(SERVICE_TOKENS.verifyOrchestrator)?.dispose();
      this.tryResolve(SERVICE_TOKENS.cruidCache)?.dispose();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_CR_WORKBENCH);
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_CR_DIFF);
      logger?.debug("CognitiveRazorPlugin", "\u89C6\u56FE\u5DF2\u5378\u8F7D");
      for (const unsub of this.unsubscribers) {
        try {
          unsub();
        } catch (e) {
          logger?.warn("CognitiveRazorPlugin", "\u53D6\u6D88\u8BA2\u9605\u65F6\u51FA\u9519", { error: e });
        }
      }
      this.unsubscribers = [];
      this.container?.disposeAll();
      logger?.info("CognitiveRazorPlugin", "\u63D2\u4EF6\u5378\u8F7D\u5B8C\u6210");
    } catch (error) {
      logger?.error("CognitiveRazorPlugin", "\u63D2\u4EF6\u5378\u8F7D\u5931\u8D25", error);
    }
  }
  // ========================================================================
  // 初始化流程（委托给 ServiceContainer）
  // ========================================================================
  /**
   * Data 层初始化（onload 中执行，轻量且必要）
   * 仅初始化 Data 层和加载设置，不执行耗时操作
   */
  async initializeDataLayerOnly() {
    await this.registerDataLayer();
    await this.loadSettings();
  }
  /**
   * Layout Ready 后的完整初始化（Core + UI + 事件订阅）
   * 耗时操作（向量加载、缓存构建等）在此阶段执行，不阻塞 Obsidian 启动
   */
  async initializeAfterLayout() {
    try {
      const logger = this.container.resolve(SERVICE_TOKENS.logger);
      logger.info("CognitiveRazorPlugin", "Cognitive Razor \u63D2\u4EF6\u521D\u59CB\u5316\u5F00\u59CB\uFF08Layout Ready\uFF09", {
        event: "PLUGIN_INIT",
        version: this.manifest.version,
        minAppVersion: this.manifest.minAppVersion
      });
      await this.registerCoreLayer();
      this.registerUILayer();
      this.subscribeToEvents();
      logger.info("CognitiveRazorPlugin", "Cognitive Razor \u63D2\u4EF6\u521D\u59CB\u5316\u5B8C\u6210", {
        event: "PLUGIN_INIT_COMPLETE",
        version: this.manifest.version,
        logLevel: this.settings.logLevel
      });
    } catch (error) {
      this.showSafeMode(error);
    }
  }
  /**
   * 注册并初始化 Data 层服务
   * 如果此层失败，将抛出异常触发安全模式
   */
  async registerDataLayer() {
    await this.initializeDataDirectory();
    const pluginDir = `${this.app.vault.configDir}/plugins/${this.manifest.id}`;
    const fileStorage = new FileStorage(this.app.vault, pluginDir);
    const initResult = await fileStorage.initialize();
    if (!initResult.ok) {
      throw new Error(`FileStorage \u521D\u59CB\u5316\u5931\u8D25: ${initResult.error.message}`);
    }
    this.container.registerInstance(SERVICE_TOKENS.fileStorage, fileStorage, "data");
    const logFilePath = "data/app.log";
    const initialLogLevel = this.settings?.logLevel || DEFAULT_SETTINGS.logLevel;
    const logger = new Logger(
      logFilePath,
      {
        write: async (path, content) => {
          const result = await fileStorage.write(path, content);
          if (!result.ok) {
            throw new Error(`\u5199\u5165\u65E5\u5FD7\u6587\u4EF6\u5931\u8D25: ${result.error.message}`);
          }
        },
        read: async (path) => {
          const result = await fileStorage.read(path);
          if (!result.ok) {
            if (result.error.code === "E300") return "";
            throw new Error(`\u8BFB\u53D6\u65E5\u5FD7\u6587\u4EF6\u5931\u8D25: ${result.error.message}`);
          }
          return result.value;
        },
        exists: async (path) => {
          return await fileStorage.exists(path);
        }
      },
      initialLogLevel
    );
    await logger.initialize();
    this.container.registerInstance(SERVICE_TOKENS.logger, logger, "data");
    logger.info("CognitiveRazorPlugin", "\u6570\u636E\u5C42\u7EC4\u4EF6\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 注册并初始化 Core 层服务
   */
  async registerCoreLayer() {
    const logger = this.container.resolve(SERVICE_TOKENS.logger);
    const fileStorage = this.container.resolve(SERVICE_TOKENS.fileStorage);
    logger.info("CognitiveRazorPlugin", "\u5E94\u7528\u5C42\u7EC4\u4EF6\u521D\u59CB\u5316\u5F00\u59CB");
    const i18n = new I18n(this.settings.language);
    i18n.setLogger(logger);
    this.container.registerInstance(SERVICE_TOKENS.i18n, i18n, "core");
    logger.debug("CognitiveRazorPlugin", "i18n \u521D\u59CB\u5316\u5B8C\u6210", { language: this.settings.language });
    const cruidCache = new CruidCache(this.app, logger, (ref) => this.registerEvent(ref));
    cruidCache.start({ fallbackToRead: false });
    this.container.registerInstance(SERVICE_TOKENS.cruidCache, cruidCache, "core");
    logger.debug("CognitiveRazorPlugin", "CruidCache \u5DF2\u542F\u52A8");
    const embeddingModel = this.settings.taskModels?.index?.model || "text-embedding-3-small";
    const embeddingDimension = this.settings.taskModels?.index?.embeddingDimension ?? this.settings.embeddingDimension ?? 1536;
    const vectorIndex = new VectorIndex(
      fileStorage,
      embeddingModel,
      embeddingDimension,
      logger,
      cruidCache,
      (cb, ms) => this.registerInterval(window.setInterval(cb, ms))
    );
    const loadResult = await vectorIndex.load();
    if (!loadResult.ok) {
      logger.error("CognitiveRazorPlugin", "VectorIndex \u52A0\u8F7D\u5931\u8D25", void 0, { error: loadResult.error });
    }
    this.container.registerInstance(SERVICE_TOKENS.vectorIndex, vectorIndex, "core");
    logger.debug("CognitiveRazorPlugin", "VectorIndex \u521D\u59CB\u5316\u5B8C\u6210", { stats: vectorIndex.getStats() });
    const validator = new Validator();
    this.container.registerInstance(SERVICE_TOKENS.validator, validator, "core");
    const lockManager = new SimpleLockManager();
    this.container.registerInstance(SERVICE_TOKENS.lockManager, lockManager, "core");
    const undoManager = new UndoManager(
      fileStorage,
      logger,
      "data/snapshots",
      this.settings.maxSnapshots,
      this.settings.maxSnapshotAgeDays ?? 30
    );
    const undoInitResult = await undoManager.initialize();
    if (!undoInitResult.ok) {
      logger.error("CognitiveRazorPlugin", "UndoManager \u521D\u59CB\u5316\u5931\u8D25", void 0, { error: undoInitResult.error });
    }
    this.container.registerInstance(SERVICE_TOKENS.undoManager, undoManager, "core");
    const maxAgeDays = this.settings.maxSnapshotAgeDays ?? 30;
    const maxAgeMs = maxAgeDays * 24 * 60 * 60 * 1e3;
    const cleanupResult = await undoManager.cleanupExpiredSnapshots(maxAgeMs);
    if (cleanupResult.ok && cleanupResult.value > 0) {
      logger.info("CognitiveRazorPlugin", `\u6E05\u7406\u4E86 ${cleanupResult.value} \u4E2A\u8FC7\u671F\u5FEB\u7167`, {
        maxAgeDays,
        cleanedCount: cleanupResult.value
      });
    }
    const providerManager = new ProviderManager(this.settingsStore, logger);
    const unsubNetwork = providerManager.subscribeNetworkStatus((online, error) => {
      this.handleNetworkStatusChange(online, error?.error?.message);
    });
    this.unsubscribers.push(unsubNetwork);
    this.container.registerInstance(SERVICE_TOKENS.providerManager, providerManager, "core");
    logger.debug("CognitiveRazorPlugin", "ProviderManager \u521D\u59CB\u5316\u5B8C\u6210", {
      providersCount: providerManager.getConfiguredProviders().length
    });
    const promptsDir = "prompts";
    const promptManager = new PromptManager(fileStorage, logger, promptsDir);
    const baseComponentsResult = await promptManager.preloadAllBaseComponents();
    if (!baseComponentsResult.ok) {
      logger.warn("CognitiveRazorPlugin", "\u57FA\u7840\u7EC4\u4EF6\u52A0\u8F7D\u5931\u8D25\uFF08\u975E\u81F4\u547D\u9519\u8BEF\uFF09", { error: baseComponentsResult.error });
    }
    const preloadResult = await promptManager.preloadAllTemplates();
    if (!preloadResult.ok) {
      logger.error("CognitiveRazorPlugin", "PromptManager \u6A21\u677F\u52A0\u8F7D\u5931\u8D25", void 0, { error: preloadResult.error, promptsDir });
    }
    this.container.registerInstance(SERVICE_TOKENS.promptManager, promptManager, "core");
    const duplicateManager = new DuplicateManager(
      vectorIndex,
      fileStorage,
      logger,
      this.settingsStore,
      lockManager,
      "data/duplicate-pairs.json"
    );
    const dupInitResult = await duplicateManager.initialize();
    if (!dupInitResult.ok) {
      logger.error("CognitiveRazorPlugin", "DuplicateManager \u521D\u59CB\u5316\u5931\u8D25", void 0, { error: dupInitResult.error });
    }
    this.container.registerInstance(SERVICE_TOKENS.duplicateManager, duplicateManager, "core");
    logger.debug("CognitiveRazorPlugin", "DuplicateManager \u521D\u59CB\u5316\u5B8C\u6210", {
      pendingPairs: duplicateManager.getPendingPairs().length
    });
    cruidCache.onDelete(({ cruid, path }) => {
      void this.cleanupAfterNoteDeleted(cruid, path);
    });
    const taskRunner = new TaskRunner({
      providerManager,
      promptManager,
      validator,
      undoManager,
      logger,
      vectorIndex,
      settingsStore: this.settingsStore,
      app: this.app
    });
    this.container.registerInstance(SERVICE_TOKENS.taskRunner, taskRunner, "core");
    const taskQueue = new TaskQueue(lockManager, fileStorage, logger, this.settingsStore, "data/queue-state.json");
    const queueInitResult = await taskQueue.initialize();
    if (!queueInitResult.ok) {
      logger.error("CognitiveRazorPlugin", "TaskQueue \u521D\u59CB\u5316\u5931\u8D25", void 0, { error: queueInitResult.error });
    }
    taskQueue.setTaskRunner(taskRunner);
    this.container.registerInstance(SERVICE_TOKENS.taskQueue, taskQueue, "core");
    logger.debug("CognitiveRazorPlugin", "TaskQueue \u521D\u59CB\u5316\u5B8C\u6210", { status: taskQueue.getStatus() });
    const pipelineStateStore = new PipelineStateStore(fileStorage, logger);
    this.container.registerInstance(SERVICE_TOKENS.pipelineStateStore, pipelineStateStore, "core");
    const noteRepository = new NoteRepository(this.app, logger);
    const contentRenderer = new ContentRenderer();
    const orchestratorDeps = {
      app: this.app,
      noteRepository,
      taskQueue,
      taskRunner,
      vectorIndex,
      duplicateManager,
      undoManager,
      lockManager,
      promptManager,
      contentRenderer,
      schemaRegistry,
      settingsStore: this.settingsStore,
      cruidCache,
      logger,
      i18n,
      pipelineStateStore,
      providerManager
    };
    const createOrchestrator = new CreateOrchestrator(orchestratorDeps);
    this.container.registerInstance(SERVICE_TOKENS.createOrchestrator, createOrchestrator, "core");
    const amendOrchestrator = new AmendOrchestrator(orchestratorDeps);
    this.container.registerInstance(SERVICE_TOKENS.amendOrchestrator, amendOrchestrator, "core");
    const mergeOrchestrator = new MergeOrchestrator(orchestratorDeps);
    this.container.registerInstance(SERVICE_TOKENS.mergeOrchestrator, mergeOrchestrator, "core");
    const verifyOrchestrator = new VerifyOrchestrator(orchestratorDeps);
    this.container.registerInstance(SERVICE_TOKENS.verifyOrchestrator, verifyOrchestrator, "core");
    const expandOrchestrator = new ExpandOrchestrator(orchestratorDeps, {
      createOrchestrator,
      fileStorage
    });
    this.container.registerInstance(SERVICE_TOKENS.expandOrchestrator, expandOrchestrator, "core");
    const imageInsertOrchestrator = new ImageInsertOrchestrator(orchestratorDeps);
    this.container.registerInstance(SERVICE_TOKENS.imageInsertOrchestrator, imageInsertOrchestrator, "core");
    const restoreResult = await pipelineStateStore.restoreToOrchestrators([
      createOrchestrator,
      amendOrchestrator,
      mergeOrchestrator,
      verifyOrchestrator
    ]);
    if (restoreResult.ok && restoreResult.value > 0) {
      logger.info("CognitiveRazorPlugin", `\u5DF2\u6062\u590D ${restoreResult.value} \u6761\u7BA1\u7EBF\u72B6\u6001`);
    }
    logger.info("CognitiveRazorPlugin", "\u5E94\u7528\u5C42\u7EC4\u4EF6\u521D\u59CB\u5316\u5B8C\u6210");
  }
  /**
   * 注册 UI 层服务
   */
  registerUILayer() {
    const logger = this.container.resolve(SERVICE_TOKENS.logger);
    const taskQueue = this.container.resolve(SERVICE_TOKENS.taskQueue);
    logger.debug("CognitiveRazorPlugin", "\u5F00\u59CB\u521D\u59CB\u5316 UI \u5C42");
    const needsSetup = this.checkNeedsSetup();
    if (needsSetup) {
      this.app.workspace.onLayoutReady(() => {
        this.showSetupWizard();
      });
    }
    this.registerViews();
    const modalManager = new ModalManager({ logger });
    this.container.registerInstance(SERVICE_TOKENS.modalManager, modalManager, "ui");
    logger.debug("CognitiveRazorPlugin", "ModalManager \u521D\u59CB\u5316\u5B8C\u6210");
    const commandDispatcher = new CommandDispatcher(this, taskQueue);
    commandDispatcher.registerAllCommands();
    this.container.registerInstance(SERVICE_TOKENS.commandDispatcher, commandDispatcher, "ui");
    logger.debug("CognitiveRazorPlugin", "\u547D\u4EE4\u6CE8\u518C\u5B8C\u6210");
    this.addSettingTab(new CRSettingTab(this.app, this));
    logger.info("CognitiveRazorPlugin", "UI \u5C42\u521D\u59CB\u5316\u5B8C\u6210");
  }
  // ========================================================================
  // 安全模式
  // ========================================================================
  /**
   * 安全模式：Data 层初始化失败时仅显示错误信息和设置入口
   * 不加载 Core 和 UI 层
   *
   * @see 需求 20.2, 20.3
   */
  showSafeMode(error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const logger = this.tryResolve(SERVICE_TOKENS.logger);
    if (logger) {
      logger.error("CognitiveRazorPlugin", "\u63D2\u4EF6\u8FDB\u5165\u5B89\u5168\u6A21\u5F0F", error, {
        event: "SAFE_MODE"
      });
    }
    new import_obsidian15.Notice(`Cognitive Razor \u521D\u59CB\u5316\u5931\u8D25\uFF0C\u5DF2\u8FDB\u5165\u5B89\u5168\u6A21\u5F0F: ${errorMessage}`, 1e4);
    this.addSettingTab(new CRSettingTab(this.app, this));
  }
  // ========================================================================
  // 辅助方法
  // ========================================================================
  /**
   * 安全解析服务（容器未初始化或服务未注册时返回 undefined）
   */
  tryResolve(token) {
    try {
      return this.container?.resolve(token);
    } catch {
      return void 0;
    }
  }
  /**
   * 初始化数据目录结构
   */
  async initializeDataDirectory() {
    const dataDir = `${this.manifest.dir}/data`;
    const adapter = this.app.vault.adapter;
    const directories = [
      dataDir,
      `${dataDir}/snapshots`,
      `${dataDir}/vectors`,
      `${dataDir}/vectors/Domain`,
      `${dataDir}/vectors/Issue`,
      `${dataDir}/vectors/Theory`,
      `${dataDir}/vectors/Entity`,
      `${dataDir}/vectors/Mechanism`
    ];
    for (const dir of directories) {
      const exists = await adapter.exists(dir);
      if (!exists) {
        await adapter.mkdir(dir);
      }
    }
  }
  /**
   * 加载设置
   */
  async loadSettings() {
    const logger = this.container.resolve(SERVICE_TOKENS.logger);
    logger.info("CognitiveRazorPlugin", "\u5F00\u59CB\u52A0\u8F7D\u8BBE\u7F6E");
    this.settingsStore = new SettingsStore(this);
    const loadResult = await this.settingsStore.loadSettings();
    if (!loadResult.ok) {
      logger.error("CognitiveRazorPlugin", "\u52A0\u8F7D\u8BBE\u7F6E\u5931\u8D25", void 0, { error: loadResult.error });
      this.settings = { ...DEFAULT_SETTINGS };
      logger.warn("CognitiveRazorPlugin", "\u4F7F\u7528\u9ED8\u8BA4\u8BBE\u7F6E");
    } else {
      this.settings = this.settingsStore.getSettings();
      logger.info("CognitiveRazorPlugin", "\u8BBE\u7F6E\u52A0\u8F7D\u6210\u529F", {
        version: this.settings.version,
        language: this.settings.language,
        providersCount: Object.keys(this.settings.providers).length
      });
    }
    this.container.registerInstance(SERVICE_TOKENS.settingsStore, this.settingsStore, "data");
    if (this.settings.logLevel) {
      logger.setLogLevel(this.settings.logLevel);
      logger.debug("CognitiveRazorPlugin", "\u65E5\u5FD7\u914D\u7F6E\u5DF2\u540C\u6B65", { logLevel: this.settings.logLevel });
    }
  }
  /**
   * 检查是否需要首次配置
   */
  checkNeedsSetup() {
    return Object.keys(this.settings.providers).length === 0;
  }
  /**
   * 显示配置向导
   */
  showSetupWizard() {
    const logger = this.tryResolve(SERVICE_TOKENS.logger);
    logger?.info("CognitiveRazorPlugin", "\u663E\u793A\u9996\u6B21\u914D\u7F6E\u5411\u5BFC");
    const wizard = new SetupWizard(this.app, this);
    wizard.open();
  }
  /**
   * 注册视图
   */
  registerViews() {
    const logger = this.container.resolve(SERVICE_TOKENS.logger);
    logger.debug("CognitiveRazorPlugin", "\u5F00\u59CB\u6CE8\u518C\u89C6\u56FE");
    this.registerView(
      VIEW_TYPE_CR_WORKBENCH,
      (leaf) => {
        const view = new WorkbenchView(leaf, this);
        logger.debug("CognitiveRazorPlugin", "WorkbenchView \u89C6\u56FE\u5DF2\u521B\u5EFA");
        return view;
      }
    );
    this.registerView(
      VIEW_TYPE_CR_DIFF,
      (leaf) => {
        const view = new DiffTabView(leaf, this);
        logger.debug("CognitiveRazorPlugin", "DiffTabView \u89C6\u56FE\u5DF2\u521B\u5EFA");
        return view;
      }
    );
    logger.info("CognitiveRazorPlugin", "\u89C6\u56FE\u6CE8\u518C\u5B8C\u6210", { views: [VIEW_TYPE_CR_WORKBENCH, VIEW_TYPE_CR_DIFF] });
  }
  /**
   * 订阅事件
   */
  subscribeToEvents() {
    const logger = this.container.resolve(SERVICE_TOKENS.logger);
    const taskQueue = this.container.resolve(SERVICE_TOKENS.taskQueue);
    const duplicateManager = this.container.resolve(SERVICE_TOKENS.duplicateManager);
    const i18n = this.container.resolve(SERVICE_TOKENS.i18n);
    logger.debug("CognitiveRazorPlugin", "\u5F00\u59CB\u8BA2\u9605\u4E8B\u4EF6");
    const unsubQueue = taskQueue.subscribe((event2) => {
      const status = taskQueue.getStatus();
      logger.debug("CognitiveRazorPlugin", "\u961F\u5217\u4E8B\u4EF6", { event: event2, status });
    });
    this.unsubscribers.push(unsubQueue);
    const unsubSettings = this.settingsStore.subscribe((newSettings) => {
      this.settings = newSettings;
      if (i18n && newSettings.language !== i18n.getLanguage()) {
        i18n.setLanguage(newSettings.language);
        logger.debug("CognitiveRazorPlugin", "\u8BED\u8A00\u5DF2\u5207\u6362", { language: newSettings.language });
      }
      logger.debug("CognitiveRazorPlugin", "\u8BBE\u7F6E\u5DF2\u66F4\u65B0", {
        logLevel: newSettings.logLevel,
        concurrency: newSettings.concurrency,
        providersCount: Object.keys(newSettings.providers).length
      });
    });
    this.unsubscribers.push(unsubSettings);
    const unsubDuplicates = duplicateManager.subscribe((pairs2) => {
      logger.debug("CognitiveRazorPlugin", "\u91CD\u590D\u5BF9\u53D8\u66F4", { count: pairs2.length });
    });
    this.unsubscribers.push(unsubDuplicates);
    logger.info("CognitiveRazorPlugin", "\u4E8B\u4EF6\u8BA2\u9605\u5B8C\u6210");
  }
  /**
   * 处理网络状态变更
   */
  handleNetworkStatusChange(online, reason) {
    const i18n = this.tryResolve(SERVICE_TOKENS.i18n);
    const t = i18n?.t();
    if (online) {
      if (this.isOffline) {
        this.isOffline = false;
        if (t) new import_obsidian15.Notice(t.notices.networkRestored);
      }
      return;
    }
    if (!this.isOffline) {
      this.isOffline = true;
      const taskQueue = this.tryResolve(SERVICE_TOKENS.taskQueue);
      if (taskQueue) void taskQueue.pause();
      if (t) {
        new import_obsidian15.Notice(reason ? `${t.notices.networkOffline}: ${reason}` : t.notices.networkOffline);
      }
    }
  }
  /**
   * 清理已删除笔记关联的数据
   */
  async cleanupAfterNoteDeleted(cruid, path) {
    const logger = this.tryResolve(SERVICE_TOKENS.logger);
    const vectorIndex = this.tryResolve(SERVICE_TOKENS.vectorIndex);
    const duplicateManager = this.tryResolve(SERVICE_TOKENS.duplicateManager);
    try {
      if (vectorIndex) {
        const result = await vectorIndex.delete(cruid);
        if (!result.ok && result.error.code !== "E004") {
          logger?.warn("CognitiveRazorPlugin", "\u5220\u9664\u7B14\u8BB0\u540E\u6E05\u7406\u5411\u91CF\u7D22\u5F15\u5931\u8D25", {
            cruid,
            path,
            error: result.error
          });
        }
      }
      if (duplicateManager) {
        const result = await duplicateManager.removePairsByNodeId(cruid);
        if (!result.ok) {
          logger?.warn("CognitiveRazorPlugin", "\u5220\u9664\u7B14\u8BB0\u540E\u6E05\u7406\u91CD\u590D\u5BF9\u5931\u8D25", {
            cruid,
            path,
            error: result.error
          });
        }
      }
    } catch (error) {
      logger?.error("CognitiveRazorPlugin", "\u5220\u9664\u7B14\u8BB0\u540E\u6E05\u7406\u5173\u8054\u6570\u636E\u5F02\u5E38", error, {
        cruid,
        path
      });
    }
  }
  // ========================================================================
  // 公开 API（向后兼容，供 UI 组件访问）
  // ========================================================================
  /**
   * 获取 i18n 实例
   */
  getI18n() {
    return this.container.resolve(SERVICE_TOKENS.i18n);
  }
  /**
   * 获取组件（供其他模块使用）
   * 所有服务通过 ServiceContainer 解析，UI 组件不直接依赖 Plugin 实例获取服务
   *
   * @see 需求 1.4, 1.5
   */
  getComponents() {
    return {
      container: this.container,
      settings: this.settings,
      settingsStore: this.container.resolve(SERVICE_TOKENS.settingsStore),
      i18n: this.container.resolve(SERVICE_TOKENS.i18n),
      fileStorage: this.container.resolve(SERVICE_TOKENS.fileStorage),
      logger: this.container.resolve(SERVICE_TOKENS.logger),
      validator: this.container.resolve(SERVICE_TOKENS.validator),
      cruidCache: this.container.resolve(SERVICE_TOKENS.cruidCache),
      vectorIndex: this.container.resolve(SERVICE_TOKENS.vectorIndex),
      lockManager: this.container.resolve(SERVICE_TOKENS.lockManager),
      undoManager: this.container.resolve(SERVICE_TOKENS.undoManager),
      providerManager: this.container.resolve(SERVICE_TOKENS.providerManager),
      promptManager: this.container.resolve(SERVICE_TOKENS.promptManager),
      duplicateManager: this.container.resolve(SERVICE_TOKENS.duplicateManager),
      taskQueue: this.container.resolve(SERVICE_TOKENS.taskQueue),
      taskRunner: this.container.resolve(SERVICE_TOKENS.taskRunner),
      createOrchestrator: this.container.resolve(SERVICE_TOKENS.createOrchestrator),
      amendOrchestrator: this.container.resolve(SERVICE_TOKENS.amendOrchestrator),
      mergeOrchestrator: this.container.resolve(SERVICE_TOKENS.mergeOrchestrator),
      verifyOrchestrator: this.container.resolve(SERVICE_TOKENS.verifyOrchestrator),
      expandOrchestrator: this.container.resolve(SERVICE_TOKENS.expandOrchestrator),
      imageInsertOrchestrator: this.container.resolve(SERVICE_TOKENS.imageInsertOrchestrator)
    };
  }
};
